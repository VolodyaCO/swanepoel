#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of shell archive."
# Contents:  read.me envelope.man envelope.f smooth.f efc.f initpt.f
#   env.f pchic.f pchfe.f savenv.f r1mach.f test.dat test.env test.tan
# Wrapped by marje@hemlock on Thu Oct  7 13:53:17 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'read.me' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'read.me'\"
else
echo shar: Extracting \"'read.me'\" \(1655 characters\)
sed "s/^X//" >'read.me' <<'END_OF_FILE'
X
X
X                               Envelope Program
X
X                                (Version 2.01)
X
X
XThis shar file contains documentation and Fortran source code for the envelope 
Xprogram, not including routines in the Volksgrapher graphics library.  
XDocumentation is in the file envelope.man.  The main program is in the file 
Xenvelope.f.  The routines for smoothing the data are in the files smooth.f and 
Xefc.f.  The routines for the envelope calculation are in the files initpt.f, 
Xenv.f, pchic.f, and pchfe.f.  A routine for saving the results is in the file 
Xsavenv.f.  Machine constants are in the file r1mach.f; you must uncomment the 
Xcorrect set of constants for the type of machine you are using.  These 
Xroutines must be linked with the Volksgrapher routines found separately in the 
XVG shar file.  All of the plotting is done from the main program in two 
Xsections near the end labelled "Plot results on screen" and "Create plot file 
Xfor high-quality output", and it should be fairly simple to replace these with 
Xcalls to a different graphics package if desired.  A sample data file test.dat 
Xis included, along with its corresponding output files test.env and test.tan.  
XThe results were obtained using the default smoothing tolerances, which work 
Xreasonably well for this example.
X
XExample of linking for X-windows:
Xf77 -o envelope envelope.f smooth.f efc.f initpt.f env.f pchic.f \
Xpchfe.f savenv.f r1mach.f vg.a vgx11.a -Bstatic -native -libmil -lX11 -lm
X
X
XMarjorie McClain
XApplied and Computational Mathematics Division
XNational Institute of Standards and Technology
XGaithersburg, MD  20899
X(301) 975-3837
Xemail: marje@cam.nist.gov
END_OF_FILE
if test 1655 -ne `wc -c <'read.me'`; then
    echo shar: \"'read.me'\" unpacked with wrong size!
fi
# end of 'read.me'
fi
if test -f 'envelope.man' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'envelope.man'\"
else
echo shar: Extracting \"'envelope.man'\" \(14270 characters\)
sed "s/^X//" >'envelope.man' <<'END_OF_FILE'
X
X
X                        Envelope Program User's Manual
X                                (Version 2.01)
X
X                               Marjorie McClain
X                                 March 8, 1989
X                      (Latest Revision: October 7, 1993)
X
X
X     The envelope program calculates the top and bottom envelope curves of a 
Xgiven set of oscillatory data.  The results are plotted on the screen, and the 
Xuser may then save the plot for later printing on a higher-quality output 
Xdevice and/or save the calculated envelope points and tangent points in a 
Xfile. 
X
X
XI. Calculation of the Envelope Curves
X
X     To enter the envelope program, type "envelope".  The program will then 
Xprompt for the name of a data file.  The data file should contain two columns 
Xof (x,y) coordinates, with the x values in increasing order.  After reading in 
Xthe data, the program will print out the number of points that it found. 
X
X     The program then performs a preprocessing of the data which replaces each 
Xpoint with the average of itself and its two nearest neighbors.  This 
Xaveraging helps to smooth out any places where the data points seem to be out 
Xof line and gives a head start to the more precise smoothing process that 
Xfollows. 
X
X     The program next begins an initial smoothing process in which it fits a 
Xpiecewise cubic polynomial to the averaged data.  The user is first prompted 
Xto enter a tolerance factor for the fit.  This factor will be multiplied by 
Xthe difference between the maximum and minimum y coordinates to specify the 
Xallowable distance between the original (averaged) data point and the new 
Xsmoothed point.  The user should type in a positive real number for the 
Xtolerance factor or just press <Enter> or <Return> to use the default value.  
XSmaller numbers correspond to tighter fits to the data, while larger numbers 
Xcorrespond to less precise fits.  When running the envelope program for the 
Xfirst time with a new set of data, the default tolerance factor should be 
Xused.  Reasons for changing the tolerance factor will be given below. 
X
X     Using the new smoothed data, the program then attempts to find estimates 
Xfor the tangent points where the envelope curves will touch the data curve.  
XThis is done by locating intervals where the smoothed data curve is either 
Xconcave (opens downward) or convex (opens upward).  The tangent points for the 
Xtop envelope are initialized to be the midpoints of each concave interval, 
Xwhile those for the bottom envelope are set at the midpoints of each convex 
Xinterval.  An exception to this method is made for intervals which contain the 
Xfirst or last data point.  Such intervals are used only if they contain a 
Xlocal maximum or minimum, and in this case the tangent point estimate is taken 
Xto be the local maximum or minimum point rather than the midpoint of the 
Xinterval.  The reason for this exception is that the true tangent point for an 
Xendpoint interval may lie outside the range of the original data points, and 
Xthe envelope algorithm will not be able to converge correctly.  However, if 
Xthe endpoint interval contains a local maximum or minimum, the true tangent 
Xpoint is guaranteed to lie nearby and the envelope algorithm will converge 
Xproperly. 
X
X     After calculating the tangent estimates, the program prints out the 
Xnumber of tangent points it found for each envelope.  The user should note 
Xcarefully whether the calculated number of tangent points appears to be 
Xcorrect.  (If the correct number is not known to begin with, it will become 
Xobvious when the program plots the data later on.)  The initialization of the 
Xtangent points is strongly dependent on the accuracy of the initial smoothing 
Xof the data.  If the fitted curve does not match the data closely enough, 
Xthere will be too few tangent points; the envelope program should be run again 
Xwith a smaller initial tolerance factor.  However, the opposite problem can 
Xalso occur; that is, if the fitted curve matches the data too closely, the 
Xnumber of tangent points calculated by the program will probably be too high.  
XThis is due to the fact that the tangent point initialization is based on 
Xfinding inflection points in the smoothed data curve (where the curvature 
Xchanges direction).  If the smoothed curve matches the data too closely, there 
Xare likely to be many small changes in the direction of curvature, and each 
Xchange will lead to the setting of a tangent point through which the final 
Xenvelope curve will be forced to pass. If this happens, the envelope program 
Xshould be run again with a larger initial tolerance factor.  To summarize, the 
Xinitial smoothing needs to be just close enough to the data to produce the 
Xcorrect number of peaks and troughs, and no closer. 
X
X     Following the initialization of the tangent points, the program proceeds 
Xwith the final smoothing of the data.  The user is prompted to enter a final 
Xtolerance factor, which may be any positive number less than or equal to the 
Xinitial tolerance factor.  The goal of the final smoothing is to produce a 
Xvery close fit to the original (averaged) data.  The envelope curves will be 
Xcomputed so as to lie tangent to this final smoothed curve, so it is 
Xparticularly important that the final smoothing closely match the data at the 
Xpeaks and troughs. 
X
X     In some cases, the initial smoothing may be accurate enough to serve also 
Xas the final smoothing, that is, with the final tolerance factor set equal to 
Xthe initial tolerance factor.  However, in most cases the initial smoothed 
Xcurve is likely to fall significantly below the peaks and above the troughs of 
Xthe original data, so that the final tolerance should be set smaller than the 
Xinitial tolerance. 
X
X     As with the initial smoothing process, problems can occur in the final 
Xsmoothing if the tolerance factor is too small.  One problem is that the 
Xprogram may run out of space to store the fitted curve, in which case it will 
Xprint the message "Maximum number of breakpoints has been exceeded". If this 
Xhappens, the user should either try a larger value for the final tolerance or 
Xincrease the parameter MAXBK in the source code for the main program (in the 
Xfile envelope.f).  Another potential problem is that if the fitted curve too 
Xclosely matches the data, it may produce several small peaks where there 
Xshould be only one large smooth peak, and the final envelope curve will 
Xattempt to converge to a tangent point near one of the small peaks while 
Xpossibly passing far below the other one.  A similar problem can occur for 
Xtroughs.  To resolve this type of problem, choose a larger value for the final 
Xtolerance. 
X
X     After the final smoothing has been completed, the program proceeds with 
Xthe last step in the computation, the actual calculation of the envelope 
Xcurves.  This process will be described here for the top envelope only, with 
Xthe understanding that the calculation for the bottom envelope is similar. The 
Xprocess begins by interpolating a piecewise cubic polynomial through the 
Xestimated tangent points for the top envelope, which were obtained from the 
Xinitial smoothing of the data.  The method used for this interpolation 
Xpreserves monotonicity, so that if the tangent points increase (or decrease) 
Xwith x, the resulting envelope curve does also.  If the tangent points are not 
Xmonotone, the interpolation method will force an extreme point in the envelope 
Xcurve at any point where the direction of monotonicity changes. 
X
X     The curve resulting from interpolation through the initial tangent point 
Xestimates is a first approximation to the envelope curve.  This curve will not 
Xbe truly tangent to the data curve unless the initial tangent estimates 
Xhappened to be exactly correct.  In most cases, the interpolated curve will 
Xcut below the peaks of the data curve.  Around each of the estimated tangent 
Xpoints, there will be an interval where the interpolated curve lies beneath 
Xthe data curve.  (The estimated tangent point will actually be one of the 
Xendpoints of the interval.)  The true tangent point of the final envelope 
Xcurve with the data curve must lie somewhere on this interval.  The envelope 
Xprogram proceeds by taking the midpoints of each of these intervals as new 
Xestimates for the tangent points.  A new curve is interpolated through the new 
Xtangent points which should be closer to the true envelope curve.  This 
Xprocess of finding new estimates for the tangent points and interpolating a 
Xcurve through them is repeated until either no points on the interpolated 
Xcurve lie beneath the data curve or until twenty iterations have been 
Xperformed, whichever comes first.  The resulting interpolated curve should be 
Xvery close to the true top envelope curve. 
X
X
XII. Viewing the Results on the Screen
X
X     Following the completion of the envelope computation, the program prompts 
Xthe user to press the <Enter> or <Return> key in order to proceed with 
Xplotting the results on the screen.  The plot will show the original data 
Xpoints, the final smoothed data curve, and the top and bottom envelope curves.  
XThe initial and final smoothing tolerance factors are recorded at the bottom 
Xof the screen.  At this point, the user should examine the plot carefully to 
Xdetermine whether the envelope curves are of acceptable quality.  If the 
Xenvelopes appear to have the wrong number of tangent points, rerun the program 
Xwith a different initial tolerance factor.  If the smoothed data curve does 
Xnot match the original data points well, rerun the program with a different 
Xfinal tolerance factor. 
X
X     The plotting portion of the envelope program employs the VolksGrapher 
X(VG) graphics package, which has many interactive features.  Only the zoom 
Xfeature will be described in detail here, since it seems most relevant for the 
Xpurposes of the envelope program. 
X
X     To enter zoom mode, type 'z'.  Four "zoom corners" will appear on the 
Xscreen.  Use the cursor (arrow) keys or the ijkm keys to move the box around 
Xon the screen. Type 'f' to move the box in finer increments; type 'c' to go 
Xback to coarse movement. 
X
X     Upon first entering zoom mode, the cursor keys control movement of the 
Xwhole zoom box.  To move just a single side of the box, type 's'.  Then typing 
Xa cursor key causes one side of the box to move outward.  To move a side 
Xinward, type a shifted cursor key.  To return to moving the whole box, type 
X'w'. 
X
X     When the zoom box is in the desired position, type 'z' to zoom in on the 
Xportion of the plot contained in the box.  Typing 'r' will restore the plot to 
Xits state before the zoom.  To escape from zoom mode without performing a 
Xzoom, press the <Esc> key, which will remove the zoom corners from the screen. 
X
X     Typing 'e' at any time will print a copy of the current screen on an 
XEpson-type printer.  Higher quality output will be discussed below. 
X
X     Once the plot has been examined to the user's satisfaction, pressing the 
X<Enter> or <Return> key clears the screen and returns to the envelope program. 
X
X
XIII. Saving the Results
X
X     The final section of the program allows the user to save the plot and the 
Xenvelope data, if desired.  If the envelope curves as observed on the screen 
Xwere not satisfactory, the user may skip over this last phase by answering 
X"no" to the two questions that follow about saving the results. The user 
Xshould then run the program again, using different values for the smoothing 
Xtolerance factors. 
X
X     The final section of the program proceeds by asking whether a high- 
Xquality plot file should be created.  If the answer is "yes", the user is 
Xgiven the choice of four possible output devices: (1) Tektronix, (2) HPGL 
XPlotter, (3) PostScript, and (4) QMS Lasergrafix.  A plot file will be created 
Xin the syntax of the chosen device.  The name of the plot file will appear on 
Xthe screen, and the user may submit this file later to the appropriate device.  
XThe resulting plot should look essentially like the one that appeared earlier 
Xon the screen, but with better resolution. 
X
X     Finally, the program asks whether the user wishes to save the calculated 
Xenvelope data.  If so, two files will be created.  One file, with extension 
X'.env' (the exact file name will appear on the screen) contains points on the 
Xtop and bottom envelope curves at specified x values.  This information is 
Xrecorded in three columns of numbers.  The first column lists x values as read 
Xfrom the input data file, the user being given the option of specifying an 
Xincrement for stepping through the values or of using every value.  The second 
Xcolumn contains the corresponding y values for the top envelope curve, and the 
Xthird column contains those for the bottom envelope. The last five lines of 
Xthe file are comments, recording the name of the original data file and the 
Xvalues of the tolerance factors used to produce the envelope data. 
X
X     In most cases, the envelope file will contain many blank entries 
X(indicated by two quotation marks) at the beginning and at the end of the 
Xsecond and third columns.  A blank entry indicates that no envelope value was 
Xcalculated for the corresponding x value.  This is due to the fact that each 
Xenvelope curve was computed by interpolation through its tangent points and so 
Xis valid only between the first and last tangent point.  While curve values 
Xcould be extrapolated beyond these endpoints, they would likely be physically 
Xmeaningless. 
X
X     The second data file created by the envelope program contains information 
Xon the tangent points where the envelope curves touch the smoothed data curve.  
XThis file will have a '.tan' extension (again, the exact file name will appear 
Xon the screen).  The file contains four columns of numbers.  The first column 
Xgives the x coordinates of tangent points on the top and bottom envelope 
Xcurves.  The second column contains the corresponding y values for the top 
Xenvelope curve, and the third column contains those for the bottom envelope.  
X(As in the '.env' file, the second and third columns may contain some blank 
Xentries.)  The last four lines of the tangent point file contain comments. 
X
X     This completes the execution of the envelope program.
END_OF_FILE
if test 14270 -ne `wc -c <'envelope.man'`; then
    echo shar: \"'envelope.man'\" unpacked with wrong size!
fi
# end of 'envelope.man'
fi
if test -f 'envelope.f' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'envelope.f'\"
else
echo shar: Extracting \"'envelope.f'\" \(9953 characters\)
sed "s/^X//" >'envelope.f' <<'END_OF_FILE'
X      PROGRAM ENVELOPE
XC
XC --- This program calculates the top and bottom envelope curves for a
XC     given set of oscillatory data.  The results are plotted on the
XC     screen (using the VG graphics package), and the user may then save
XC     the plot in a file for later printing on a higher-quality output
XC     device and/or save the calculated envelope points and tangent
XC     points in a file.
XC
XC --- M. McClain, Scientific Computing Division, February 1989.
XC     Latest Revision, September 1993 (Version 2.01).
XC     Changes since Version 2.0 (October 1992):
XC     (1) For hardcopy VG output, changed color code from 10 to 5,
XC         because 10 is too dark on Sparc printer.
XC     (2) Changed text for filename extensions from upper case to
XC         lower case.
XC     Changes since previous version:
XC     (1) Removed specific references to transmittance data.
XC     (2) Improved handling of error tolerances for subroutine SMOOTH.
XC     (3) Updated subroutine SMOOTH to October 1992 version.
XC     (4) In subroutine ENV, replaced call to PCHIM with call to PCHIC.
XC
XC --- Declaration of Variables
X      CHARACTER FILNAM*20,ANSWER*1,LETTER*1,TEXT1*7,TEXT2*7,DEV*3,
X     +          NAME*20
X      LOGICAL FILEOK,ERROR,TOP
X      INTEGER I,N,MAXN,MAXBK,NBKPTS,LW,NORD,INBV,IDER,MAXTAN,NTTAN,
X     +        NBTAN,NTENV,NBENV,NAMLEN,FULLEN,IERR,TRACE,LOOPIN,LOOPBT
X      REAL XPT,YPT,TOL1,TOL2,BVALU,TEMP,SMIN,TOL,YMIN,YMAX,RANGE
X      PARAMETER(MAXN=1200,MAXBK=200,MAXTAN=50,LW=4*MAXN)
X      INTEGER TINDEX(MAXTAN),BINDEX(MAXTAN)
X      REAL X(MAXN),Y(MAXN),YAVE(MAXN),S(MAXN),Z(MAXN),DERIV2(MAXN),
X     +     WORK1(MAXN),XTENV(MAXN),YTENV(MAXN),XBENV(MAXN),YBENV(MAXN),
X     +     BKPT(MAXBK),COEFF(MAXBK),WORK2(MAXBK),
X     +     XTTAN(MAXTAN),YTTAN(MAXTAN),XBTAN(MAXTAN),YBTAN(MAXTAN),
X     +     WORK3(2*MAXTAN),
X     +     W(LW),W2(20)
XC
XC --- Set underflows to zero (for Lahey compiler)
XC      CALL UNDER0(.TRUE.)
XC
XC --- Print program header and version number.
X      PRINT *,'Envelope Program Version 2.01'
X      PRINT *,'-----------------------------'
X      PRINT *
XC
XC --- Open data file and save filename information.
X   50 CONTINUE
X      PRINT *,'What is the name of your data file? '
X      READ(*,100)FILNAM
X  100 FORMAT(A)
X      INQUIRE(FILE=FILNAM,EXIST=FILEOK)
X      IF(FILEOK)THEN
X         OPEN(1,FILE=FILNAM,STATUS='OLD')
X      ELSE
X         PRINT *,'File does not exist -- try again.'
X         GOTO 50
X      ENDIF
X      I=0
X  150 CONTINUE
X      I=I+1
X      LETTER=FILNAM(I:I)
X      IF(I.LE.LEN(FILNAM).AND.LETTER.NE.' '.AND.LETTER.NE.'.')GOTO 150
X      NAMLEN=I-1
X      NAME=FILNAM(1:NAMLEN)
X      IF(LETTER.EQ.'.')THEN
X  180    CONTINUE
X         I=I+1
X         LETTER=FILNAM(I:I)
X         IF(I.LE.LEN(FILNAM).AND.LETTER.NE.' ')GOTO 180
X         FULLEN=I-1
X      ELSE
X         FULLEN=NAMLEN
X      ENDIF
XC
XC --- Read in data.
X      PRINT *,'Reading data ... '
X      N=0
X  200 CONTINUE
X      READ(1,*,END=300)XPT,YPT
X      N=N+1
X      IF(N.GT.MAXN)THEN
X         PRINT *,'ERROR: Too many data points -- increase MAXN.'
X         STOP
X      ENDIF
X      IF(XPT.LT.X(N-1))THEN
X         PRINT *,'ERROR: X value out of order at point ',N,'.'
X         STOP
X      ENDIF
X      X(N)=XPT
X      Y(N)=YPT
X      GOTO 200
X  300 CONTINUE
X      CLOSE(1)
X      WRITE(*,350)N
X  350 FORMAT(' Found ',I5,' data points.')
XC
XC --- Perform rough smoothing by averaging every three data points.
X      PRINT *
X      PRINT *,'Averaging data ... '
X      YAVE(1)=Y(1)
X      DO 400 I=2,N-1
X         YAVE(I)=(Y(I-1)+Y(I)+Y(I+1))/3.
X  400 CONTINUE
X      YAVE(N)=Y(N)
XC
XC --- Find minimum and maximum data values.
X      YMIN=YAVE(1)
X      YMAX=YAVE(1)
X      DO 420 I=2,N
X         YMIN=MIN(YMIN,YAVE(I))
X         YMAX=MAX(YMAX,YAVE(I))
X  420 CONTINUE
X      RANGE=YMAX-YMIN
XC
XC --- Make initial pass through smoothing algorithm.
X      TOL1=.08
X      PRINT *
X      WRITE(*,450)TOL1
X  450 FORMAT(' Enter tolerance factor for initial smoothing ',
X     +        '(default =',F7.4,'): ')
X      READ(*,500)TEMP
X  500 FORMAT(F8.0)
X      IF(TEMP.GT.0.)TOL1=TEMP
X      TOL=TOL1*RANGE
X      DO 600 I=1,N
X         S(I)=TOL
X  600 CONTINUE
X      SMIN=TOL
X      PRINT *,'Smoothing data ... '
X  610 CONTINUE
X      TRACE=0
X      NORD=4
X      NBKPTS=0
X      CALL SMOOTH(IERR,TRACE,NORD,N,X,YAVE,S,SMIN,Z,WORK1,MAXBK,NBKPTS,
X     +            BKPT,COEFF,WORK2,LW,W)
X      IF(IERR.NE.0)THEN
X         SMIN=2*SMIN
X         WRITE(*,620)IERR
X  620    FORMAT('    Unable to fit data with current parameters ',
X     +          '(IERR =',I2,') --')
X         PRINT *,'   Doubling tolerance and trying again ... '
X         GOTO 610
X      ENDIF
XC     WRITE(*,650)NBKPTS
XC 650 FORMAT(' Initial smoothing required ',I3,' breakpoints.')
XC
XC --- Initialize interpolation points for envelope algorithm.
X      PRINT *
X      PRINT *,'Initializing tangent points for envelope ... '
X      NORD=4
X      INBV=1
X      IDER=2
X      DO 700 I=1,N
X         DERIV2(I)=BVALU(BKPT,COEFF,NBKPTS-NORD,NORD,IDER,X(I),INBV,W2)
X  700 CONTINUE
X      TOP=.TRUE.
X      CALL INITPT(ERROR,TOP,N,Z,DERIV2,MAXTAN,NTTAN,TINDEX)
X      IF(ERROR)STOP
X      WRITE(*,750)NTTAN
X  750 FORMAT(' Found ',I2,' tangent points for top envelope.')
X      IF(NTTAN.LE.1)THEN
X         PRINT *,'ERROR: Not enough tangent points -- cannot proceed.'
X         PRINT *,'       (Try a smaller tolerance factor.)'
X         STOP
X      ENDIF
X      TOP=.FALSE.
X      CALL INITPT(ERROR,TOP,N,Z,DERIV2,MAXTAN,NBTAN,BINDEX)
X      IF(ERROR)STOP
X      WRITE(*,800)NBTAN
X  800 FORMAT(' Found ',I2,' tangent points for bottom envelope.')
X      IF(NBTAN.LE.1)THEN
X         PRINT *,'ERROR: Not enough tangent points -- cannot proceed.'
X         PRINT *,'       (Try a smaller tolerance factor.)'
X         STOP
X      ENDIF
XC
XC --- Make final pass through smoothing algorithm.
X      TOL2=.01
X      PRINT *
X      WRITE(*,850)TOL2
X  850 FORMAT(' Enter tolerance factor for final smoothing ',
X     +        '(default =',F7.4,'): ')
X      READ(*,900)TEMP
X  900 FORMAT(F8.0)
X      IF(TEMP.GT.0.)TOL2=TEMP
X      IF(TOL2.LT.TOL1)THEN
X         TOL=TOL2*RANGE
X         DO 1000 I=1,N
X            S(I)=TOL
X 1000    CONTINUE
X         SMIN=TOL
X         PRINT *,'Smoothing data ... '
X 1010    CONTINUE
X         CALL SMOOTH(IERR,TRACE,NORD,N,X,YAVE,S,SMIN,Z,WORK1,MAXBK,
X     +               NBKPTS,BKPT,COEFF,WORK2,LW,W)
X         IF(IERR.NE.0)THEN
X            SMIN=2*SMIN
X            WRITE(*,620)IERR
X            PRINT *,'   Doubling tolerance and trying again ... '
X            NBKPTS=0
X            GOTO 1010
X         ENDIF
XC        WRITE(*,1020)NBKPTS
XC1020    FORMAT(' Final smoothing required ',I3,' breakpoints.')
X      ENDIF
XC
XC --- Calculate envelope curves.
X      PRINT *
X      PRINT *,'Calculating top envelope ... '
X      NORD=4
X      INBV=1
X      IDER=2
X      DO 1050 I=1,N
X         DERIV2(I)=BVALU(BKPT,COEFF,NBKPTS-NORD,NORD,IDER,X(I),INBV,W2)
X 1050 CONTINUE
X      DO 1100 I=1,NTTAN
X         XTTAN(I)=X(TINDEX(I))
X         YTTAN(I)=Z(TINDEX(I))
X 1100 CONTINUE
X      TOP=.TRUE.
X      CALL ENV(ERROR,TOP,N,X,Z,DERIV2,NTENV,XTENV,YTENV,NTTAN,XTTAN,
X     +         YTTAN,WORK1,work3)
X      IF(ERROR)STOP
X      PRINT *
X      PRINT *,'Calculating bottom envelope ... '
X      DO 1400 I=1,NBTAN
X         XBTAN(I)=X(BINDEX(I))
X         YBTAN(I)=Z(BINDEX(I))
X 1400 CONTINUE
X      TOP=.FALSE.
X      CALL ENV(ERROR,TOP,N,X,Z,DERIV2,NBENV,XBENV,YBENV,NBTAN,XBTAN,
X     +         YBTAN,WORK1,work3)
X      IF(ERROR)STOP
XC
XC --- Plot results on screen.
X      PRINT *
X      PRINT *,'Press <Enter> to proceed with plotting.'
X      READ(*,*)
X      CALL NEWPAG
X 1800 CONTINUE
X      CALL PLAC(1.,.1,0.,1.)
X      CALL SIDTEX(FILNAM,11,'X',11,'Y',11,' ',0)
X      CALL HOWPLT(23,0,1)
X      CALL CURV(N,X,Y)
X      CALL HOWPLT(0,1,15)
X      CALL CURV(N,X,Z)
X      CALL HOWPLT(0,1,2)
X      CALL CURV(NTENV,XTENV,YTENV)
X      CALL HOWPLT(0,1,2)
X      CALL CURV(NBENV,XBENV,YBENV)
X      CALL VG
X      WRITE(TEXT1,1850)TOL1
X 1850 FORMAT(F7.4)
X      CALL HTEX('Initial Tolerance ='//TEXT1,.12,.03,0.,1.,13)
X      WRITE(TEXT2,1850)TOL2
X      CALL HTEX('Final Tolerance ='//TEXT2,.55,.03,0.,1.,13)
X      IF(LOOPIN().EQ.1)GOTO 1800
XC
XC --- Create plot file for high-quality output.
X 1855 CONTINUE
X      PRINT *
X      PRINT *,'Do you want to create a high-quality plot file (Y/N)? '
X      READ(*,1860)ANSWER
X 1860 FORMAT(A)
X      IF(ANSWER.EQ.'Y'.OR.ANSWER.EQ.'y')THEN
X         PRINT *,'Select an output device from the following --'
X         PRINT *,'   1. Tektronix'
X         PRINT *,'   2. HPGL Plotter'
X         PRINT *,'   3. PostScript'
X         PRINT *,'   4. QMS Lasergrafix'
X         PRINT *,'Enter the number of your choice: '
X         READ(*,*)TEMP
X         IF(TEMP.EQ.1)THEN
X            DEV='tek'
X         ELSEIF(TEMP.EQ.2)THEN
X            DEV='hpg'
X         ELSEIF(TEMP.EQ.3)THEN
X            DEV='pos'
X         ELSEIF(TEMP.EQ.4)THEN
X            DEV='qms'
X         ELSE
X            PRINT *,'Invalid selection -- Try again.'
X            GOTO 1855
X         ENDIF
X         CALL NEWPAG
X         CALL SETDV(DEV)
X         CALL SETFIL(NAME)
X 1880    CONTINUE
X         CALL PLAC(1.,.1,0.,1.)
X         CALL AXCODE(0,0,5)
X         CALL SIDTEX(FILNAM,5,'X',5,'Y',5,' ',0)
X         CALL HOWPLT(23,0,5)
X         CALL CURV(N,X,Y)
X         CALL HOWPLT(0,1,5)
X         CALL CURV(N,X,Z)
X         CALL HOWPLT(0,1,5)
X         CALL CURV(NTENV,XTENV,YTENV)
X         CALL HOWPLT(0,1,5)
X         CALL CURV(NBENV,XBENV,YBENV)
X         CALL VG
X         CALL HTEX('Initial Tolerance ='//TEXT1,.12,.03,0.,1.,5)
X         CALL HTEX('Final Tolerance ='//TEXT2,.55,.03,0.,1.,5)
X         IF(LOOPBT().EQ.1)GOTO 1880
X      ENDIF
XC
XC --- Save results.
X      PRINT *
X      PRINT *,'Do you want to save the envelope data (Y/N)? '
X      READ(*,1900)ANSWER
X 1900 FORMAT(A)
X      IF(ANSWER.EQ.'Y'.OR.ANSWER.EQ.'y')THEN
X         CALL SAVENV(FILNAM,FULLEN,NAMLEN,TOL1,TOL2,N,X,
X     +               NTENV,XTENV,YTENV,NBENV,XBENV,YBENV,
X     +               NTTAN,XTTAN,YTTAN,NBTAN,XBTAN,YBTAN)
X      ENDIF
XC
X      STOP
X      END
END_OF_FILE
if test 9953 -ne `wc -c <'envelope.f'`; then
    echo shar: \"'envelope.f'\" unpacked with wrong size!
fi
# end of 'envelope.f'
fi
if test -f 'smooth.f' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'smooth.f'\"
else
echo shar: Extracting \"'smooth.f'\" \(18302 characters\)
sed "s/^X//" >'smooth.f' <<'END_OF_FILE'
X      SUBROUTINE SMOOTH(IERR,TRACE,NORD,N,X,Y,S,SMIN,Z,BADPT,MAXBK,
X     +                  NBKPTS,BKPT,COEFF,XHALF,LW,W)
XC
XC --- This subroutine is a driver for the data-smoothing routine DOFIT.
XC     If the data set to be smoothed is very large, the driver first
XC     smooths a subset of the data and then uses the breakpoints from 
XC     this initial fit as a starting place for smoothing the entire
XC     data set.
XC
XC --- Input Variables
XC     TRACE:         Flag indicating whether to print a trace of the 
XC                    routine's progress --
XC                    TRACE=0 for no trace
XC                    TRACE=1 for trace of number of data points and
XC                            number of breakpoints in use
XC     NORD:          Order of piecewise polynomials for spline fit
XC                    (NORD=4 for cubic spline)
XC     N:             Number of data points
XC     X(N):          Array containing x coordinates of data
XC     Y(N):          Array containing y coordinates of data
XC     S(N):          Array containing y-coordinate error estimates
XC     SMIN:          Minimum allowed error tolerance
XC     MAXBK:         Maximum allowed number of breakpoints in smoothed
XC                    curve
XC     NBKPTS:        Number of initial breakpoints (should be zero if
XC                    data are being smoothed for the first time)
XC     BKPT(NBKPTS):  Array of initial breakpoints (used only if 
XC                    NBKPTS>0)
XC     LW:            Size of work array W
XC
XC --- Output Variables
XC     IERR:          Error indicator --
XC                    IERR=0 if no errors were encountered
XC                    IERR=1 if X array is not sorted
XC                    IERR=2 if an error occurred in subroutine EFC
XC                    IERR=3 if an error occurred in subroutine INTERV
XC                    IERR=4 if the maximum number of breakpoints was 
XC                           exceeded
XC                    IERR=5 if an error occurred in subroutine INSERT
XC                    IERR=6 if subroutine DOFIT was unable to add new
XC                           breakpoints
XC     SMIN:          Minimum allowed error tolerance (changed if input
XC                    was less than or equal to zero)
XC     Z(N):          Array containing smoothed y coordinates
XC     BADPT(N):      Work array
XC     NBKPTS:        Number of breakpoints in smoothed curve
XC     BKPT(NBKPTS):  Array of breakpoints
XC     COEFF(NBKPTS): Array of b-spline coefficients
XC     XHALF(NBKPTS): Work array
XC     W(LW):         Work array
XC
XC --- Declaration of Calling Sequence Variables
X      INTEGER IERR,TRACE,NORD,N,MAXBK,NBKPTS,LW
X      REAL X(*),Y(*),S(*),SMIN,Z(*),BADPT(*),BKPT(*),COEFF(*),W(*),
X     +     XHALF(*)
XC
XC --- Declaration of Internal Variables
X      INTEGER I,NINIT,NTEMP,STEP,INDEX
X      PARAMETER(NINIT=200)
X      REAL XTEMP(NINIT),YTEMP(NINIT),STEMP(NINIT)
XC
XC --- If data set is large, smooth a subset first.
X      IF(N.GT.NINIT)THEN
X         STEP=(N-1)/(NINIT-1)
X         IF(MOD(N-1,NINIT-1).NE.0)STEP=STEP+1
X         NTEMP=(N-1)/STEP+2
X         IF(MOD(N-1,STEP).EQ.0)NTEMP=NTEMP-1
X         IF(TRACE.EQ.1)WRITE(*,50)NTEMP
X   50    FORMAT('    Using ',I5,' data points ... ')
X         DO 100 I=1,NTEMP-1
X            INDEX=(I-1)*STEP+1
X            XTEMP(I)=X(INDEX)
X            YTEMP(I)=Y(INDEX)
X            STEMP(I)=S(INDEX)
X  100    CONTINUE
X         XTEMP(NTEMP)=X(N)
X         YTEMP(NTEMP)=Y(N)
X         STEMP(NTEMP)=S(N)
X         CALL DOFIT(IERR,TRACE,NTEMP,XTEMP,YTEMP,STEMP,SMIN,Z,BADPT,
X     +              NORD,MAXBK,NBKPTS,BKPT,COEFF,XHALF,LW,W)
X         IF((IERR.EQ.1).OR.(IERR.EQ.4))RETURN
X      ENDIF
XC
XC --- Smooth entire data set.
X      IF(TRACE.EQ.1)WRITE(*,200)N
X  200 FORMAT('    Using ',I5,' data points ... ')
X      CALL DOFIT(IERR,TRACE,N,X,Y,S,SMIN,Z,BADPT,NORD,MAXBK,NBKPTS,BKPT,
X     +           COEFF,XHALF,LW,W)
XC
X      RETURN
X      END
XC
XC     ******************************************************************
XC
X      SUBROUTINE DOFIT(IERR,TRACE,N,X,Y,S,SMIN,Z,BADPT,NORD,MAXBK,
X     +                 NBKPTS,BKPT,COEFF,XHALF,LW,W)
XC
XC --- This subroutine smooths a given data set, using the CMLIB b-spline
XC     routines EFC and BVALU.  The breakpoints for the b-splines are
XC     determined iteratively, with more breakpoints set in regions where
XC     the data vary the most.
XC
XC --- Input Variables
XC     TRACE:         Flag indicating whether to print a trace of the 
XC                    routine's progress --
XC                    TRACE=0 for no trace
XC                    TRACE=1 for trace of number of data points and
XC                            number of breakpoints in use
XC     N:             Number of data points
XC     X(N):          Array containing x coordinates of data
XC     Y(N):          Array containing y coordinates of data
XC     S(N):          Array containing y-coordinate error estimates
XC     SMIN:          Minimum allowed error tolerance
XC     NORD:          Order of piecewise polynomials for spline fit
XC                    (NORD=4 for cubic spline)
XC     MAXBK:         Maximum allowed number of breakpoints in smoothed
XC                    curve
XC     NBKPTS:        Number of initial breakpoints (should be zero if
XC                    data is being smoothed for the first time)
XC     BKPT(NBKPTS):  Array of initial breakpoints (used only if 
XC                    NBKPTS>0)
XC     LW:            Size of work array W
XC
XC --- Output Variables
XC     IERR:          Error indicator --
XC                    IERR=0 if no error was encountered
XC                    IERR=1 if X array is not sorted
XC                    IERR=2 if an error occurred in subroutine EFC
XC                    IERR=3 if an error occurred in subroutine INTERV
XC                    IERR=4 if the maximum number of breakpoints was
XC                           exceeded
XC                    IERR=5 if an error occurred in subroutine INSERT
XC                    IERR=6 if DOFIT was unable to add new breakpoints
XC     SMIN:          Minimum allowed error tolerance (changed if input
XC                    was less than or equal to zero)
XC     Z(N):          Array containing smoothed y coordinates
XC     BADPT(N):      Work array
XC     NBKPTS:        Number of breakpoints in smoothed curve
XC     BKPT(NBKPTS):  Array of breakpoints
XC     COEFF(NBKPTS): Array of b-spline coefficients
XC     XHALF(NBKPTS): Work array
XC     W(LW):         Work array
XC
XC --- Declaration of Calling Sequence Variables
X      INTEGER IERR,TRACE,N,NORD,MAXBK,NBKPTS,LW
X      REAL X(*),Y(*),S(*),SMIN,Z(*),BADPT(*),BKPT(*),COEFF(*),W(*),
X     +     XHALF(*)
XC
XC --- Declaration of Internal Variables
X      LOGICAL ERROR
X      INTEGER I,ITER,MDEOUT,INBV,IDER,BEGIN,END,NPTS,NBAD,OLDBEG,OLDEND,
X     +        NEWBKS,OLDBKS
X      REAL BVALU,W2(20)
XC
XC --- Initialize parameters.
X      IERR=0
X      ITER=0
XC
XC --- Check if x coordinates are in order.
X      DO 50 I=2,N
X         IF(X(I).LT.X(I-1))THEN
X            IERR=1
X            RETURN
X         ENDIF
X   50 CONTINUE
XC
XC --- Check if initial breakpoints are supplied.
X      IF(NBKPTS.GT.0)GOTO 300
XC
XC --- If not, set initial breakpoints at first and last data points.
X      NBKPTS=2*NORD
X      DO 100 I=1,NORD
X         BKPT(I)=X(1)
X  100 CONTINUE
X      DO 200 I=NORD+1,NBKPTS
X         BKPT(I)=X(N)
X  200 CONTINUE
XC
XC --- Fit curve through data points.
X  300 CONTINUE
X      ITER=ITER+1
X      IF(TRACE.EQ.1)WRITE(*,350)NBKPTS
X  350 FORMAT('       Trying ',I3,' knots ... ')
X      CALL EFC(N,X,Y,S,NORD,NBKPTS,BKPT,1,MDEOUT,COEFF,LW,W)
X      IF(MDEOUT.NE.1)THEN
X         IERR=2
XC        PRINT *,'ERROR in subroutine DOFIT: Error returned from ',
XC    +           'call to EFC.'
XC         WRITE(*,380)MDEOUT
XC 380    FORMAT('       WARNING: MDEOUT = ',I3,' on return from EFC.')
X         RETURN
X      ENDIF
XC
XC --- Calculate smoothed data points.
X      INBV=1
X      IDER=0
X      DO 400 I=1,N
X         Z(I)=BVALU(BKPT,COEFF,NBKPTS-NORD,NORD,IDER,X(I),INBV,W2)
X  400 CONTINUE
XC
XC --- Check if smoothed points are within requested accuracy.
X      CALL CHKFIT(N,X,Y,Z,S,SMIN,NBAD,BADPT)
X      IF(NBAD.EQ.0)RETURN
XC
XC --- If smoothed points are not accurate enough, add breakpoints.
X      OLDBEG=0
X      OLDEND=0
X      OLDBKS=NBKPTS
X      NEWBKS=0
X      DO 500 I=1,NBAD
X         IF(OLDEND.NE.0)THEN
X            IF(BADPT(I).LT.X(OLDEND))GOTO 500
X         ENDIF
X         CALL INTERV(BADPT(I),N,X,NORD,NBKPTS,BKPT,BEGIN,END)
X         IF(BEGIN.EQ.OLDBEG.AND.END.EQ.OLDEND)GOTO 500
X         NPTS=END-BEGIN+1
X         IF(NPTS.LE.0)THEN
X            IERR=3
XC           PRINT *,'ERROR in subroutine DOFIT: Number of points is ',
XC    +              'zero or negative.'
X            RETURN
X         ENDIF
X         NEWBKS=NEWBKS+1
X         IF(NEWBKS.GT.MAXBK)THEN
X            IERR=4
XC           PRINT *,'ERROR in subroutine DOFIT: Maximum number of ',
XC    +              'breakpoints has been exceeded --'
XC           PRINT *,'Increase MAXBK or use a bigger error tolerance.'
X            RETURN
X         ENDIF
X         CALL HALFPT(NPTS,X(BEGIN),Y(BEGIN),XHALF(NEWBKS))
X         OLDBEG=BEGIN
X         OLDEND=END
X  500 CONTINUE
X      DO 600 I=1,NEWBKS
X         CALL INSERT(ERROR,XHALF(I),MAXBK,NBKPTS,BKPT)
X         IF(ERROR)THEN
X            IERR=5
X            RETURN
X         ENDIF
X  600 CONTINUE
X      CALL DELETE(NORD,NBKPTS,BKPT)
X      IF(NBKPTS.LE.OLDBKS)THEN
X         IERR=6
XC        PRINT *,'ERROR in subroutine DOFIT: After deleting ',
XC    +           'extraneous multiple breakpoints, the total number ',
XC    +           'of breakpoints decreased or stayed the same.' 
X         RETURN
X      ENDIF
X      GOTO 300
XC
X      END
XC
XC     ******************************************************************
XC
X      SUBROUTINE CHKFIT(N,X,Y,Z,S,SMIN,NBAD,BADPT)
XC
XC --- This subroutine compares each smoothed data point with the
XC     corresponding original data point to check whether the smoothed
XC     curve is within the requested tolerance.
XC
XC --- Input Variables
XC     N:           Number of data points
XC     X(N):        Array containing x coordinates of data points
XC     Y(N):        Array containing y coordinates of data points
XC     Z(N):        Array containing y coordinates of smoothed data
XC     S(N):        Array containing y-coordinate error tolerances
XC     SMIN:        Minimum allowed error tolerance
XC
XC --- Output Variables
XC     SMIN:        Minimum allowed error tolerance (changed if input was
XC                  less than or equal to zero)
XC     NBAD:        Number of smoothed points that do not satisfy error
XC                  test
XC     BADPT(NBAD): Array containing x coordinates of smoothed points 
XC                  that do not satisfy error test
XC
XC --- Declaration of Calling Sequence Variables
X      INTEGER N,NBAD
X      REAL X(*),Y(*),Z(*),S(*),SMIN,BADPT(*)
XC
XC --- Declaration of Internal Variables
X      INTEGER I
X      REAL TOL,YMIN,YMAX
XC
XC --- Reset minimum error tolerance, if not greater than zero.
X      IF(SMIN.LE.0.)THEN
X         YMIN=Y(1)
X         YMAX=Y(1)
X         DO 50 I=2,N
X            IF(Y(I).LT.YMIN)YMIN=Y(I)
X            IF(Y(I).GT.YMAX)YMAX=Y(I)
X   50    CONTINUE
X         SMIN=.001*(YMAX-YMIN)
X      ENDIF
XC
XC --- Compare smoothed points with original data points.
X      NBAD=0
X      DO 100 I=1,N
X         TOL=MAX(ABS(S(I)),SMIN)
X         IF(ABS(Z(I)-Y(I)).GT.TOL)THEN
X            NBAD=NBAD+1
X            BADPT(NBAD)=X(I)
X         ENDIF
X  100 CONTINUE
XC
X      RETURN
X      END
XC
XC     ******************************************************************
XC
X      SUBROUTINE DELETE(NORD,NBKPTS,BKPT)
XC
XC --- This subroutine checks for coincident breakpoints and deletes any
XC     over a multiplicity of NORD.  This is done because subroutine EFC
XC     fails with an error "MDEOUT=2" whenever it receives a breakpoint
XC     whose multiplicity is more than NORD.
XC
XC --- Input Variables
XC     NORD:         Order of piecewise polynomials for spline fit
XC                   (NORD=4 for cubic spline)
XC     NBKPTS:       Number of breakpoints (before deletion)
XC     BKPT(NBKPTS): Array containing breakpoints (before deletion)
XC
XC --- Output Variables
XC     NBKPTS:       Number of breakpoints (after deletion)
XC     BKPT(NBKPTS): Array containing breakpoints (after deletion)
XC
XC --- Declaration of Calling Sequence Variables
X      INTEGER NORD,NBKPTS
X      REAL BKPT(*)
XC
XC --- Declaration of Internal Variables
X      INTEGER I,J,INIT
XC
XC --- Initialize parameters.
X      INIT=1
XC
XC --- Check that number of breakpoints is not degenerate.
X  100 CONTINUE
X      IF(NBKPTS.GT.NORD)THEN
XC
XC ---    Loop to compare pairs of breakpoints.
X         DO 300 I=INIT,NBKPTS-NORD
XC
XC ---       Check if there are more than NORD coincident breakpoints.
X            IF(BKPT(I).EQ.BKPT(I+NORD))THEN
XC
XC ---          Remove (I+NORD)th breakpoint.
X               DO 200 J=I+NORD,NBKPTS-1
X                  BKPT(J)=BKPT(J+1)
X  200          CONTINUE
X               NBKPTS=NBKPTS-1
X               INIT=I
X               GOTO 100
XC
X            ENDIF
XC
X  300    CONTINUE
XC
X      ENDIF
XC
X      RETURN
X      END
XC
XC     ******************************************************************
XC
X      SUBROUTINE HALFPT(N,X,Y,XHALF)
XC
XC --- This subroutine calculates the (scaled) length of the piecewise
XC     linear interpolant to the given data and returns the x coordinate 
XC     of a point approximately half way along the curve.
XC
XC --- Input Variables
XC     N:     Number of data points
XC     X(N):  Array containing x coordinates of data
XC     Y(N):  Array containing y coordinates of data
XC
XC --- Output Variable
XC     XHALF: X coordinate of half-way point
XC
XC --- Declaration of Calling Sequence Variables
X      INTEGER N
X      REAL X(*),Y(*),XHALF
XC
XC --- Declaration of Internal Variables
X      INTEGER I
X      REAL XMIN,XMAX,YMIN,YMAX,XSCALE,YSCALE,LENGTH,XTEMP,YTEMP,DIST
XC
XC --- Find range of data and set scale factors.
X      XMIN=X(1)
X      XMAX=X(1)
X      YMIN=Y(1)
X      YMAX=Y(1)
X      DO 100 I=1,N
X         IF(X(I).LT.XMIN)XMIN=X(I)
X         IF(X(I).GT.XMAX)XMAX=X(I)
X         IF(Y(I).LT.YMIN)YMIN=Y(I)
X         IF(Y(I).GT.YMAX)YMAX=Y(I)
X  100 CONTINUE
X      XSCALE=XMAX-XMIN
X      IF(XSCALE.EQ.0.)XSCALE=1.
X      YSCALE=YMAX-YMIN
X      IF(YSCALE.EQ.0.)YSCALE=1.
XC
XC --- Calculate total length of data curve.
X      LENGTH=0.
X      DO 200 I=2,N
X         XTEMP=(X(I)-X(I-1))/XSCALE
X         YTEMP=(Y(I)-Y(I-1))/YSCALE
X         LENGTH=LENGTH+SQRT(XTEMP*XTEMP+YTEMP*YTEMP)
X  200 CONTINUE
XC
XC --- Find x value of half-way point.
X      DIST=0.
X      XHALF=X(N)
X      DO 300 I=2,N
X         XTEMP=(X(I)-X(I-1))/XSCALE
X         YTEMP=(Y(I)-Y(I-1))/YSCALE
X         DIST=DIST+SQRT(XTEMP*XTEMP+YTEMP*YTEMP)
X         IF(2*DIST.GE.LENGTH)THEN
X            XHALF=(X(I)+X(I-1))/2.
X            GOTO 400
X         ENDIF
X  300 CONTINUE
XC
X  400 CONTINUE
X      RETURN
X      END
XC
XC     ******************************************************************
XC
X      SUBROUTINE INSERT(ERROR,NEWBK,MAXBK,NBKPTS,BKPT)
XC
XC --- This subroutine inserts a new knot in the breakpoint array at a
XC     specified location.
XC
XC --- Input Variables
XC     NEWBK:        X position of new knot to be inserted
XC     MAXBK:        Maximum allowed number of breakpoints
XC     NBKPTS:       Number of breakpoints (before insertion)
XC     BKPT(NBKPTS): Array containing breakpoints (before insertion)
XC
XC --- Output Variables
XC     ERROR:        Error flag --
XC                   ERROR=.TRUE. if an error was encountered
XC                   ERROR=.FALSE. otherwise
XC     NBKPTS:       Number of breakpoints (after insertion)
XC     BKPT(NBKPTS): Array containing breakpoints (after insertion)
XC
XC --- Declaration of Calling Sequence Variables
X      LOGICAL ERROR
X      INTEGER MAXBK,NBKPTS
X      REAL NEWBK,BKPT(*)
XC
XC --- Declaration of Internal Variables
X      INTEGER I,NEWPOS
XC
XC --- Initialize error flag.
X      ERROR=.FALSE.
XC
XC --- Find position in breakpoint array for new breakpoint.
X      DO 100 I=1,NBKPTS
X         IF(NEWBK.LT.BKPT(I))THEN
X            NEWPOS=I
X            GOTO 200
X         ENDIF
X  100 CONTINUE
X      NEWPOS=NBKPTS+1
XC
XC --- Insert new breakpoint in breakpoint array.
X  200 CONTINUE
X      NBKPTS=NBKPTS+1
X      IF(NBKPTS.GT.MAXBK)THEN
X         ERROR=.TRUE.
XC        PRINT *,'ERROR in subroutine INSERT: Maximum number of ',
XC    +           'breakpoints has been exceeded --'
XC        PRINT *,'Increase MAXBK or use a bigger error tolerance.'
X         RETURN
X      ENDIF
X      IF(NEWPOS.LT.NBKPTS)THEN
X         DO 300 I=NBKPTS,NEWPOS+1,-1
X            BKPT(I)=BKPT(I-1)
X  300    CONTINUE
X      ENDIF
X      BKPT(NEWPOS)=NEWBK
XC
X      RETURN
X      END
XC
XC     ******************************************************************
XC
X      SUBROUTINE INTERV(XPT,N,X,NORD,NBKPTS,BKPT,BEGIN,END)
XC
XC --- This subroutine finds the smallest breakpoint interval containing
XC     the given x value and returns the indices of the data points 
XC     nearest the endpoints of this interval.
XC
XC --- INPUT VARIABLES
XC     XPT:          X value to be located
XC     N:            Number of data points
XC     X(N):         Array containing x coordinates of data
XC     NORD:         Order of piecewise polynomials for spline fit
XC                   (NORD=4 for cubic spline)
XC     NBKPTS:       Number of breakpoints
XC     BKPT(NBKPTS): Array containing breakpoints
XC
XC --- Output Variables
XC     BEGIN:        Index of data point near left breakpoint
XC                   ( X(BEGIN) <= Left Breakpoint <= XPT )
XC     END:          Index of data point near right breakpoint
XC                   ( XPT <= Right Breakpoint <= X(END) )
XC
XC --- Declaration of Calling Sequence Variables
X      INTEGER N,NORD,NBKPTS,BEGIN,END
X      REAL XPT,X(*),BKPT(*)
XC
XC --- Declaration of Internal Variables
X      INTEGER I
X      REAL BKPT1,BKPT2
XC
XC --- Find breakpoint interval containing the given point.
X      DO 100 I=NORD+1,NBKPTS
X         IF(XPT.LE.BKPT(I))THEN
X            BKPT1=BKPT(I-1)
X            BKPT2=BKPT(I)
X            GOTO 200
X         ENDIF
X  100 CONTINUE
XC
XC --- Find data points nearest the ends of the breakpoint interval.
X  200 CONTINUE
X      DO 300 I=2,N
X         IF(X(I).GT.BKPT1)THEN
X            BEGIN=I-1
X            GOTO 400
X         ENDIF
X  300 CONTINUE
X  400 CONTINUE
X      DO 500 I=BEGIN,N
X         IF(X(I).GT.BKPT2)THEN
X            END=I
X            GOTO 600
X         ENDIF
X  500 CONTINUE
X      END=N
XC
X  600 CONTINUE
X      RETURN
X      END
END_OF_FILE
if test 18302 -ne `wc -c <'smooth.f'`; then
    echo shar: \"'smooth.f'\" unpacked with wrong size!
fi
# end of 'smooth.f'
fi
if test -f 'efc.f' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'efc.f'\"
else
echo shar: Extracting \"'efc.f'\" \(77688 characters\)
sed "s/^X//" >'efc.f' <<'END_OF_FILE'
X      SUBROUTINE EFC(NDATA,XDATA,YDATA,SDDATA,NORD,NBKPT,BKPT,MDEIN,
X     1   MDEOUT,COEFF,LW,W)
XC***BEGIN PROLOGUE  EFC
XC***DATE WRITTEN   800801   (YYMMDD)
XC***REVISION DATE  820801   (YYMMDD)
XC***CATEGORY NO.  K1A1A1,K1A2A,L8A3
XC***KEYWORDS  B-SPLINES,CONSTRAINED LEAST SQUARES,CURVE FITTING,
XC             LEAST SQUARES
XC***AUTHOR  HANSON, R. J., (SNLA)
XC***PURPOSE  FITS A PIECE-WISE POLYNOMIAL CURVE TO DISCRETE
XC            DATA.  THE PIECE-WISE POLYNOMIALS ARE REPRESENTED
XC            AS B-SPLINES.  THE FITTING IS DONE IN A WEIGHTED
XC            LEAST SQUARES SENSE.
XC***DESCRIPTION
XC
XC     REVISED 800905-1300
XC     REVISED YYMMDD-HHMM
XC     DIMENSION XDATA(NDATA),YDATA(NDATA),SDDATA(NDATA),  BKPT(NBKPT),
XC    1  COEFF(NBKPT-NORD),W(*)
XC
XC      THIS SUBPROGRAM FITS A PIECE-WISE POLYNOMIAL CURVE
XC      TO DISCRETE DATA.  THE PIECE-WISE POLYNOMIALS ARE
XC      REPRESENTED AS B-SPLINES.
XC      THE FITTING IS DONE IN A WEIGHTED LEAST SQUARES SENSE.
XC
XC      THE DATA CAN BE PROCESSED IN GROUPS OF MODEST SIZE.
XC      THE SIZE OF THE GROUP IS CHOSEN BY THE USER.  THIS FEATURE
XC      MAY BE NECESSARY FOR PURPOSES OF USING CONSTRAINED CURVE FITTING
XC      WITH SUBPROGRAM FC( ) ON A VERY LARGE DATA SET.
XC      FOR A DESCRIPTION OF THE B-SPLINES AND USAGE INSTRUCTIONS TO
XC      EVALUATE THEM, SEE
XC
XC      C. W. DE BOOR, PACKAGE FOR CALCULATING WITH B-SPLINES.
XC                     SIAM J. NUMER. ANAL., P. 441, (JUNE, 1977).
XC
XC      FOR FURTHER DISCUSSION OF (CONSTRAINED) CURVE FITTING USING
XC      B-SPLINES, SEE
XC
XC      R. J. HANSON, CONSTRAINED LEAST SQUARES CURVE FITTING
XC                   TO DISCRETE DATA USING B-SPLINES, A USER'S
XC                   GUIDE. SANDIA LABS. TECH. REPT. SAND-78-1291,
XC                   DECEMBER, (1978).
XC
XC  INPUT..
XC      NDATA,XDATA(*),
XC      YDATA(*),
XC      SDDATA(*)
XC                         THE NDATA DISCRETE (X,Y) PAIRS AND
XC                         THE Y VALUE STANDARD DEVIATION OR
XC                         UNCERTAINTY, SD, ARE IN THE RESPECTIVE
XC                         ARRAYS XDATA(*), YDATA(*), AND SDDATA(*).
XC                         NO SORTING OF XDATA(*) IS REQUIRED.  ANY
XC                         NON-NEGATIVE VALUE OF NDATA IS ALLOWED.  A
XC                         NEGATIVE VALUE OF NDATA IS AN ERROR.
XC                         A ZERO VALUE FOR ANY ENTRY OF SDDATA(*)
XC                         WILL WEIGHT THAT DATA POINT AS 1.
XC                         OTHERWISE THE WEIGHT OF THAT DATA POINT IS
XC                         THE RECIPROCAL OF THIS ENTRY.
XC
XC      NORD,NBKPT,
XC      BKPT(*)
XC                         THE NBKPT KNOTS OF THE B-SPLINE OF ORDER
XC                         NORD ARE IN THE ARRAY BKPT(*).  NORMALLY
XC                         THE PROBLEM DATA INTERVAL WILL BE INCLUDED
XC                         BETWEEN THE LIMITS BKPT(NORD) AND
XC                         BKPT(NBKPT-NORD+1).  THE ADDITIONAL END KNOTS
XC                         BKPT(I),I=1,...,NORD-1 AND I=NBKPT-NORD+2,...,
XC                         NBKPT, ARE REQUIRED TO COMPUTE THE FUNCTIONS
XC                         USED TO FIT THE DATA.
XC                         NO SORTING OF BKPT(*) IS REQUIRED.  INTERNAL
XC                         TO EFC( ) THE EXTREME END KNOTS MAY BE SLIGHT-
XC                         LY REDUCED AND INCREASED RESPECTIVELY TO
XC                         ACCOMODATE ANY DATA VALUES THAT ARE EXTERIOR
XC                         TO THE GIVEN KNOT VALUES.  THE CONTENTS OF
XC                         BKPT(*) ARE NOT CHANGED.
XC
XC                         THE VALUE OF NORD MUST LIE BETWEEN 1 AND 20.
XC                         THE VALUE OF NBKPT MUST SATISFY NBKPT .GE.
XC                         2*NORD.  OTHER VALUES ARE CONSIDERED ERRORS.
XC
XC                         (THE ORDER OF THE SPLINE IS ONE MORE
XC                         THAN THE DEGREE OF THE PIECE-WISE POLYNOMIAL
XC                         DEFINED ON EACH INTERVAL.  THIS IS CONSISTENT
XC                         WITH THE B-SPLINE PACKAGE CONVENTION.  FOR
XC                         EXAMPLE, NORD=4 WHEN WE ARE USING PIECE-WISE
XC                         CUBICS.)
XC
XC        MDEIN
XC                         AN INTEGER FLAG, WITH ONE OF TWO POSSIBLE
XC                         VALUES (1 OR 2), THAT DIRECTS THE SUBPROGRAM
XC                         ACTION WITH REGARD TO NEW DATA POINTS PROVIDED
XC                         BY THE USER.
XC
XC                         =1  THE FIRST TIME THAT EFC( ) HAS BEEN
XC                         ENTERED.  THERE ARE NDATA POINTS TO PROCESS.
XC
XC                         =2  THIS IS ANOTHER ENTRY TO EFC( ).  THE SUB-
XC                         PROGRAM EFC( ) HAS BEEN ENTERED WITH MDEIN=1
XC                         EXACTLY ONCE BEFORE FOR THIS PROBLEM.  THERE
XC                         ARE NDATA NEW ADDITIONAL POINTS TO MERGE AND
XC                         PROCESS WITH ANY PREVIOUS POINTS.
XC                         (WHEN USING EFC( ) WITH MDEIN=2 IT IS IMPORT-
XC                         ANT THAT THE SET OF KNOTS REMAIN FIXED AT THE
XC                         SAME VALUES FOR ALL ENTRIES TO EFC( ).)
XC       LW
XC                         THE AMOUNT OF WORKING STORAGE ACTUALLY
XC                         ALLOCATED FOR THE WORKING ARRAY W(*).
XC                         THIS QUANTITY IS COMPARED WITH THE
XC                         ACTUAL AMOUNT OF STORAGE NEEDED IN EFC( ).
XC                         INSUFFICIENT STORAGE ALLOCATED FOR W(*) IS
XC                         AN ERROR.  THIS FEATURE WAS INCLUDED IN EFC( )
XC                         BECAUSE MISREADING THE STORAGE FORMULA
XC                         FOR W(*) MIGHT VERY WELL LEAD TO SUBTLE
XC                         AND HARD-TO-FIND PROGRAMMING BUGS.
XC
XC                         THE LENGTH OF THE ARRAY W(*) MUST SATISFY
XC
XC                         LW .GE. (NBKPT-NORD+3)*(NORD+1)+
XC                                 (NBKPT+1)*(NORD+1)+
XC                               2*MAX0(NDATA,NBKPT)+NBKPT+NORD**2
XC  OUTPUT..
XC      MDEOUT
XC                         AN OUTPUT FLAG THAT INDICATES THE STATUS
XC                         OF THE CONSTRAINED CURVE FIT.
XC
XC                         =-1  A USAGE ERROR OF EFC( ) OCCURRED.  THE
XC                         OFFENDING CONDITION IS NOTED WITH THE SLATEC
XC                         LIBRARY ERROR PROCESSOR, XERROR( ).
XC                         IN CASE THE WORKING ARRAY W(*) IS
XC                         NOT LONG ENOUGH, THE MINIMAL ACCEPTABLE LENGTH
XC                         IS PRINTED USING THE ERROR PROCESSING SUBPRO-
XC                         GRAM XERRWV( ).
XC
XC                         =1  THE B-SPLINE COEFFICIENTS FOR THE FITTED
XC                         CURVE HAVE BEEN RETURNED IN ARRAY COEFF(*).
XC
XC                         =2  NOT ENOUGH DATA HAS BEEN PROCESSED TO
XC                         DETERMINE THE B-SPLINE COEFFICIENTS.
XC                         THE USER HAS ONE OF TWO OPTIONS.  CONTINUE
XC                         TO PROCESS MORE DATA UNTIL A UNIQUE SET
XC                         OF COEFFICIENTS IS OBTAINED, OR USE THE
XC                         SUBPROGRAM FC( ) TO OBTAIN A SPECIFIC
XC                         SET OF COEFFICIENTS.  THE USER SHOULD READ
XC                         THE USAGE INSTRUCTIONS FOR FC( ) FOR FURTHER
XC                         DETAILS IF THIS SECOND OPTION IS CHOSEN.
XC      COEFF(*)
XC                         IF THE OUTPUT VALUE OF MDEOUT=1, THIS ARRAY
XC                         CONTAINS THE UNKNOWNS OBTAINED FROM THE LEAST
XC                         SQUARES FITTING PROCESS.  THESE N=NBKPT-NORD
XC                         PARAMETERS ARE THE B-SPLINE COEFFICIENTS.
XC                         FOR MDEOUT=2, NOT ENOUGH DATA WAS PROCESSED TO
XC                         UNIQUELY DETERMINE THE B-SPLINE COEFFICIENTS.
XC                         IN THIS CASE, AND ALSO WHEN MDEOUT=-1, ALL
XC                         VALUES OF COEFF(*) ARE SET TO ZERO.
XC
XC                         IF THE USER IS NOT SATISFIED WITH THE FITTED
XC                         CURVE RETURNED BY EFC( ), THE CONSTRAINED
XC                         LEAST SQUARES CURVE FITTING SUBPROGRAM FC( )
XC                         MAY BE REQUIRED.  THE WORK DONE WITHIN EFC( )
XC                         TO ACCUMULATE THE DATA CAN BE UTILIZED BY
XC                         THE USER, IF SO DESIRED.  THIS INVOLVES
XC                         SAVING THE FIRST (NBKPT-NORD+3)*(NORD+1)
XC                         ENTRIES OF W(*) AND PROVIDING THIS DATA
XC                         TO FC( ) WITH THE "OLD PROBLEM" DESIGNATION.
XC                         THE USER SHOULD READ THE USAGE INSTRUCTIONS
XC                         FOR SUBPROGRAM FC( ) FOR FURTHER DETAILS.
XC
XC  WORKING ARRAY..
XC      W(*)
XC                         THIS ARRAY IS TYPED REAL.  ITS
XC                         LENGTH IS SPECIFIED AS AN INPUT
XC                         PARAMETER IN LW AS NOTED ABOVE.
XC                         THE CONTENTS OF W(*) MUST NOT BE MODIFIED
XC                         BY THE USER BETWEEN CALLS TO EFC( ) WITH
XC                         VALUES OF MDEIN=1,2,2,... .  THE FIRST
XC                         (NBKPT-NORD+3)*(NORD+1) ENTRIES OF W(*) ARE
XC                         ACCEPTABLE AS DIRECT INPUT TO FC( ) FOR AN
XC                         "OLD PROBLEM" ONLY WHEN MDEOUT=1 OR 2.
XC
XC  EVALUATING THE
XC  FITTED CURVE..
XC                         TO EVALUATE DERIVATIVE NUMBER IDER AT XVAL
XC                         USE THE FUNCTION SUBPROGRAM BVALU( ).
XC
XC                           F = BVALU(BKPT,COEFF,NBKPT-NORD,NORD,IDER,
XC                                      XVAL,INBV,WORKB)
XC
XC                         THE OUTPUT OF THIS SUBPROGRAM WILL NOT BE
XC                         DEFINED UNLESS AN OUTPUT VALUE OF MDEOUT=1
XC                         WAS OBTAINED FROM EFC( ), XVAL IS IN THE DATA
XC                         INTERVAL, AND IDER IS NONNEGATIVE AND .LT.
XC                         NORD.
XC                         THE FIRST TIME BVALU( ) IS CALLED, INBV=1
XC                         MUST BE SPECIFIED.  THIS VALUE OF INBV IS THE
XC                         OVERWRITTEN BY BVALU( ).  THE ARRAY WORKB(*)
XC                         MUST BE OF LENGTH AT LEAST 3*NORD, AND MUST
XC                         NOT BE THE SAME AS THE W(*) ARRAY USED
XC                         IN THE CALL TO EFC( ).
XC
XC                         BVALU( ) EXPECTS THE BREAKPOINT ARRAY BKPT(*
XC                         TO BE SORTED.
XC***REFERENCES  HANSON R.J., *CONSTRAINED LEAST SQUARES CURVE FITTING
XC                 TO DISCRETE DATA USING B-SPLINES, A USERS GUIDE*,
XC                 SAND78-1291, DECEMBER,1978.
XC***ROUTINES CALLED  EFCMN
XC***END PROLOGUE  EFC
XC
XC+-+-+-+-
XC     THE USER-PROVIDED USAGE INSTRUCTIONS CAN END HERE.
XC      SUBROUTINE           FUNCTION/REMARKS
XC
XC      BSPLVN( )          COMPUTE FUNCTION VALUES OF B-SPLINES.  FROM
XC                         THE B-SPLINE PACKAGE OF DE BOOR NOTED ABOVE.
XC
XC      BNDACC( ),         BANDED LEAST SQUARES MATRIX PROCESSORS.
XC      BNDSOL( )          FROM LAWSON-HANSON, SOLVING LEAST
XC                         SQUARES PROBLEMS.
XC
XC      SSORT( )           DATA SORTING SUBROUTINE, FROM THE
XC                         SANDIA MATH. LIBRARY, SAND77-1441.
XC      XERROR( ),         ERROR HANDLING ROUTINES
XC      XERRWV( )          FOR THE SLATEC MATH. LIBRARY.
XC                         SEE SAND78-1189, BY R. E. JONES.
XC
XC      SCOPY( ),SSCAL( )  SUBROUTINES FROM THE BLAS PACKAGE.
XC                         LOCATED ON SANDIA. MATH. LIBRARY. SEE
XC                         SAND77-0898 FOR DESCRIPTION.
XC
XC                         WRITTEN BY R. HANSON, SANDIA NATL. LABS.,
XC                         ALB., N. M., AUGUST-SEPTEMBER, 1980.
X      DIMENSION XDATA(1),YDATA(1),SDDATA(1),BKPT(1)
X      DIMENSION COEFF(1),W(1)
XC***FIRST EXECUTABLE STATEMENT  EFC
X      MDG=NBKPT+1
X      MDW=NBKPT-NORD+3
XC     LWW=1               USAGE IN EFCMN( ) OF W(*)..
XC     LWW,...,LG-1        W(*,*)
XC
XC     LG,...,LXTEMP-1     G(*,*)
XC
XC     LXTEMP,...,LPTEMP-1 XTEMP(*)
XC
XC     LPTEMP,...,LBKPT-1  PTEMP(*)
XC
XC     LBKPT,...,LBF       BKPT(*) (LOCAL TO EFCMN( ))
XC
XC     LBF,...,LBF+NORD**2 BF(*,*)
XC
X      LWW=1
X      LG=LWW+MDW*(NORD+1)
X      LXTEMP=LG+MDG*(NORD+1)
X      LPTEMP=LXTEMP+MAX0(NDATA,NBKPT)
X      LBKPT=LPTEMP+MAX0(NDATA,NBKPT)
X      LBF=LBKPT+NBKPT
X      CALL EFCMN(NDATA,XDATA,YDATA,SDDATA,
X     1         NORD,NBKPT,BKPT,
X     2         MDEIN,MDEOUT,
X     3         COEFF,
X     4         W(LBF),W(LXTEMP),W(LPTEMP),W(LBKPT),
X     5         W(LG),MDG,W(LWW),MDW,LW)
X      RETURN
X      END
X      SUBROUTINE SAXPY(N,SA,SX,INCX,SY,INCY)
XC***BEGIN PROLOGUE  SAXPY
XC***DATE WRITTEN   791001   (YYMMDD)
XC***REVISION DATE  820801   (YYMMDD)
XC***CATEGORY NO.  D1A7
XC***KEYWORDS  BLAS,LINEAR ALGEBRA,TRIAD,VECTOR
XC***AUTHOR  LAWSON, C. L., (JPL)
XC           HANSON, R. J., (SNLA)
XC           KINCAID, D. R., (U. OF TEXAS)
XC           KROGH, F. T., (JPL)
XC***PURPOSE  S.P. COMPUTATION Y = A*X + Y
XC***DESCRIPTION
XC
XC                B L A S  SUBPROGRAM
XC    DESCRIPTION OF PARAMETERS
XC
XC     --INPUT--
XC        N  NUMBER OF ELEMENTS IN INPUT VECTOR(S)
XC       SA  SINGLE PRECISION SCALAR MULTIPLIER
XC       SX  SINGLE PRECISION VECTOR WITH N ELEMENTS
XC     INCX  STORAGE SPACING BETWEEN ELEMENTS OF SX
XC       SY  SINGLE PRECISION VECTOR WITH N ELEMENTS
XC     INCY  STORAGE SPACING BETWEEN ELEMENTS OF SY
XC
XC     --OUTPUT--
XC       SY  SINGLE PRECISION RESULT (UNCHANGED IF N .LE. 0)
XC
XC     OVERWRITE SINGLE PRECISION SY WITH SINGLE PRECISION SA*SX +SY.
XC     FOR I = 0 TO N-1, REPLACE  SY(LY+I*INCY) WITH SA*SX(LX+I*INCX) +
XC       SY(LY+I*INCY), WHERE LX = 1 IF INCX .GE. 0, ELSE LX = (-INCX)*N
XC       AND LY IS DEFINED IN A SIMILAR WAY USING INCY.
XC***REFERENCES  LAWSON C.L., HANSON R.J., KINCAID D.R., KROGH F.T.,
XC                 *BASIC LINEAR ALGEBRA SUBPROGRAMS FOR FORTRAN USAGE*,
XC                 ALGORITHM NO. 539, TRANSACTIONS ON MATHEMATICAL
XC                 SOFTWARE, VOLUME 5, NUMBER 3, SEPTEMBER 1979, 308-323
XC***ROUTINES CALLED  (NONE)
XC***END PROLOGUE  SAXPY
XC
X      REAL SX(1),SY(1),SA
XC***FIRST EXECUTABLE STATEMENT  SAXPY
X      IF(N.LE.0.OR.SA.EQ.0.E0) RETURN
X      IF(INCX.EQ.INCY) IF(INCX-1) 5,20,60
X    5 CONTINUE
XC
XC        CODE FOR NONEQUAL OR NONPOSITIVE INCREMENTS.
XC
X      IX = 1
X      IY = 1
X      IF(INCX.LT.0)IX = (-N+1)*INCX + 1
X      IF(INCY.LT.0)IY = (-N+1)*INCY + 1
X      DO 10 I = 1,N
X        SY(IY) = SY(IY) + SA*SX(IX)
X        IX = IX + INCX
X        IY = IY + INCY
X   10 CONTINUE
X      RETURN
XC
XC        CODE FOR BOTH INCREMENTS EQUAL TO 1
XC
XC
XC        CLEAN-UP LOOP SO REMAINING VECTOR LENGTH IS A MULTIPLE OF 4.
XC
X   20 M = MOD(N,4)
X      IF( M .EQ. 0 ) GO TO 40
X      DO 30 I = 1,M
X        SY(I) = SY(I) + SA*SX(I)
X   30 CONTINUE
X      IF( N .LT. 4 ) RETURN
X   40 MP1 = M + 1
X      DO 50 I = MP1,N,4
X        SY(I) = SY(I) + SA*SX(I)
X        SY(I + 1) = SY(I + 1) + SA*SX(I + 1)
X        SY(I + 2) = SY(I + 2) + SA*SX(I + 2)
X        SY(I + 3) = SY(I + 3) + SA*SX(I + 3)
X   50 CONTINUE
X      RETURN
XC
XC        CODE FOR EQUAL, POSITIVE, NONUNIT INCREMENTS.
XC
X   60 CONTINUE
X      NS = N*INCX
X          DO 70 I=1,NS,INCX
X          SY(I) = SA*SX(I) + SY(I)
X   70     CONTINUE
X      RETURN
X      END
X      SUBROUTINE SCOPY(N,SX,INCX,SY,INCY)
XC***BEGIN PROLOGUE  SCOPY
XC***DATE WRITTEN   791001   (YYMMDD)
XC***REVISION DATE  820801   (YYMMDD)
XC***CATEGORY NO.  D1A5
XC***KEYWORDS  BLAS,COPY,LINEAR ALGEBRA,VECTOR
XC***AUTHOR  LAWSON, C. L., (JPL)
XC           HANSON, R. J., (SNLA)
XC           KINCAID, D. R., (U. OF TEXAS)
XC           KROGH, F. T., (JPL)
XC***PURPOSE  COPY S.P. VECTOR Y = X
XC***DESCRIPTION
XC
XC                B L A S  SUBPROGRAM
XC    DESCRIPTION OF PARAMETERS
XC
XC     --INPUT--
XC        N  NUMBER OF ELEMENTS IN INPUT VECTOR(S)
XC       SX  SINGLE PRECISION VECTOR WITH N ELEMENTS
XC     INCX  STORAGE SPACING BETWEEN ELEMENTS OF SX
XC       SY  SINGLE PRECISION VECTOR WITH N ELEMENTS
XC     INCY  STORAGE SPACING BETWEEN ELEMENTS OF SY
XC
XC     --OUTPUT--
XC       SY  COPY OF VECTOR SX (UNCHANGED IF N .LE. 0)
XC
XC     COPY SINGLE PRECISION SX TO SINGLE PRECISION SY.
XC     FOR I = 0 TO N-1, COPY  SX(LX+I*INCX) TO SY(LY+I*INCY),
XC     WHERE LX = 1 IF INCX .GE. 0, ELSE LX = (-INCX)*N, AND LY IS
XC     DEFINED IN A SIMILAR WAY USING INCY.
XC***REFERENCES  LAWSON C.L., HANSON R.J., KINCAID D.R., KROGH F.T.,
XC                 *BASIC LINEAR ALGEBRA SUBPROGRAMS FOR FORTRAN USAGE*,
XC                 ALGORITHM NO. 539, TRANSACTIONS ON MATHEMATICAL
XC                 SOFTWARE, VOLUME 5, NUMBER 3, SEPTEMBER 1979, 308-323
XC***ROUTINES CALLED  (NONE)
XC***END PROLOGUE  SCOPY
XC
X      REAL SX(1),SY(1)
XC***FIRST EXECUTABLE STATEMENT  SCOPY
X      IF(N.LE.0)RETURN
X      IF(INCX.EQ.INCY) IF(INCX-1) 5,20,60
X    5 CONTINUE
XC
XC        CODE FOR UNEQUAL OR NONPOSITIVE INCREMENTS.
XC
X      IX = 1
X      IY = 1
X      IF(INCX.LT.0)IX = (-N+1)*INCX + 1
X      IF(INCY.LT.0)IY = (-N+1)*INCY + 1
X      DO 10 I = 1,N
X        SY(IY) = SX(IX)
X        IX = IX + INCX
X        IY = IY + INCY
X   10 CONTINUE
X      RETURN
XC
XC        CODE FOR BOTH INCREMENTS EQUAL TO 1
XC
XC
XC        CLEAN-UP LOOP SO REMAINING VECTOR LENGTH IS A MULTIPLE OF 7.
XC
X   20 M = MOD(N,7)
X      IF( M .EQ. 0 ) GO TO 40
X      DO 30 I = 1,M
X        SY(I) = SX(I)
X   30 CONTINUE
X      IF( N .LT. 7 ) RETURN
X   40 MP1 = M + 1
X      DO 50 I = MP1,N,7
X        SY(I) = SX(I)
X        SY(I + 1) = SX(I + 1)
X        SY(I + 2) = SX(I + 2)
X        SY(I + 3) = SX(I + 3)
X        SY(I + 4) = SX(I + 4)
X        SY(I + 5) = SX(I + 5)
X        SY(I + 6) = SX(I + 6)
X   50 CONTINUE
X      RETURN
XC
XC        CODE FOR EQUAL, POSITIVE, NONUNIT INCREMENTS.
XC
X   60 CONTINUE
X      NS = N*INCX
X          DO 70 I=1,NS,INCX
X          SY(I) = SX(I)
X   70     CONTINUE
X      RETURN
X      END
X      REAL FUNCTION SDOT(N,SX,INCX,SY,INCY)
XC***BEGIN PROLOGUE  SDOT
XC***DATE WRITTEN   791001   (YYMMDD)
XC***REVISION DATE  820801   (YYMMDD)
XC***CATEGORY NO.  D1A4
XC***KEYWORDS  BLAS,INNER PRODUCT,LINEAR ALGEBRA,VECTOR
XC***AUTHOR  LAWSON, C. L., (JPL)
XC           HANSON, R. J., (SNLA)
XC           KINCAID, D. R., (U. OF TEXAS)
XC           KROGH, F. T., (JPL)
XC***PURPOSE  S.P. INNER PRODUCT OF S.P. VECTORS
XC***DESCRIPTION
XC
XC                B L A S  SUBPROGRAM
XC    DESCRIPTION OF PARAMETERS
XC
XC     --INPUT--
XC        N  NUMBER OF ELEMENTS IN INPUT VECTOR(S)
XC       SX  SINGLE PRECISION VECTOR WITH N ELEMENTS
XC     INCX  STORAGE SPACING BETWEEN ELEMENTS OF SX
XC       SY  SINGLE PRECISION VECTOR WITH N ELEMENTS
XC     INCY  STORAGE SPACING BETWEEN ELEMENTS OF SY
XC
XC     --OUTPUT--
XC     SDOT  SINGLE PRECISION DOT PRODUCT (ZERO IF N .LE. 0)
XC
XC     RETURNS THE DOT PRODUCT OF SINGLE PRECISION SX AND SY.
XC     SDOT = SUM FOR I = 0 TO N-1 OF  SX(LX+I*INCX) * SY(LY+I*INCY),
XC     WHERE LX = 1 IF INCX .GE. 0, ELSE LX = (-INCX)*N, AND LY IS
XC     DEFINED IN A SIMILAR WAY USING INCY.
XC***REFERENCES  LAWSON C.L., HANSON R.J., KINCAID D.R., KROGH F.T.,
XC                 *BASIC LINEAR ALGEBRA SUBPROGRAMS FOR FORTRAN USAGE*,
XC                 ALGORITHM NO. 539, TRANSACTIONS ON MATHEMATICAL
XC                 SOFTWARE, VOLUME 5, NUMBER 3, SEPTEMBER 1979, 308-323
XC***ROUTINES CALLED  (NONE)
XC***END PROLOGUE  SDOT
XC
X      REAL SX(1),SY(1)
XC***FIRST EXECUTABLE STATEMENT  SDOT
X      SDOT = 0.0E0
X      IF(N.LE.0)RETURN
X      IF(INCX.EQ.INCY) IF(INCX-1)5,20,60
X    5 CONTINUE
XC
XC        CODE FOR UNEQUAL INCREMENTS OR NONPOSITIVE INCREMENTS.
XC
X      IX = 1
X      IY = 1
X      IF(INCX.LT.0)IX = (-N+1)*INCX + 1
X      IF(INCY.LT.0)IY = (-N+1)*INCY + 1
X      DO 10 I = 1,N
X        SDOT = SDOT + SX(IX)*SY(IY)
X        IX = IX + INCX
X        IY = IY + INCY
X   10 CONTINUE
X      RETURN
XC
XC        CODE FOR BOTH INCREMENTS EQUAL TO 1
XC
XC
XC        CLEAN-UP LOOP SO REMAINING VECTOR LENGTH IS A MULTIPLE OF 5.
XC
X   20 M = MOD(N,5)
X      IF( M .EQ. 0 ) GO TO 40
X      DO 30 I = 1,M
X        SDOT = SDOT + SX(I)*SY(I)
X   30 CONTINUE
X      IF( N .LT. 5 ) RETURN
X   40 MP1 = M + 1
X      DO 50 I = MP1,N,5
X        SDOT = SDOT + SX(I)*SY(I) + SX(I + 1)*SY(I + 1) +
X     1   SX(I + 2)*SY(I + 2) + SX(I + 3)*SY(I + 3) + SX(I + 4)*SY(I + 4)
X   50 CONTINUE
X      RETURN
XC
XC        CODE FOR POSITIVE EQUAL INCREMENTS .NE.1.
XC
X   60 CONTINUE
X      NS=N*INCX
X      DO 70 I=1,NS,INCX
X        SDOT = SDOT + SX(I)*SY(I)
X   70   CONTINUE
X      RETURN
X      END
X      SUBROUTINE SSCAL(N,SA,SX,INCX)
XC***BEGIN PROLOGUE  SSCAL
XC***DATE WRITTEN   791001   (YYMMDD)
XC***REVISION DATE  820801   (YYMMDD)
XC***CATEGORY NO.  D1A6
XC***KEYWORDS  BLAS,LINEAR ALGEBRA,SCALE,VECTOR
XC***AUTHOR  LAWSON, C. L., (JPL)
XC           HANSON, R. J., (SNLA)
XC           KINCAID, D. R., (U. OF TEXAS)
XC           KROGH, F. T., (JPL)
XC***PURPOSE  S.P. VECTOR SCALE X = A*X
XC***DESCRIPTION
XC
XC                B L A S  SUBPROGRAM
XC    DESCRIPTION OF PARAMETERS
XC
XC     --INPUT--
XC        N  NUMBER OF ELEMENTS IN INPUT VECTOR(S)
XC       SA  SINGLE PRECISION SCALE FACTOR
XC       SX  SINGLE PRECISION VECTOR WITH N ELEMENTS
XC     INCX  STORAGE SPACING BETWEEN ELEMENTS OF SX
XC
XC     --OUTPUT--
XC       SX  SINGLE PRECISION RESULT (UNCHANGED IF N .LE. 0)
XC
XC     REPLACE SINGLE PRECISION SX BY SINGLE PRECISION SA*SX.
XC     FOR I = 0 TO N-1, REPLACE SX(1+I*INCX) WITH  SA * SX(1+I*INCX)
XC***REFERENCES  LAWSON C.L., HANSON R.J., KINCAID D.R., KROGH F.T.,
XC                 *BASIC LINEAR ALGEBRA SUBPROGRAMS FOR FORTRAN USAGE*,
XC                 ALGORITHM NO. 539, TRANSACTIONS ON MATHEMATICAL
XC                 SOFTWARE, VOLUME 5, NUMBER 3, SEPTEMBER 1979, 308-323
XC***ROUTINES CALLED  (NONE)
XC***END PROLOGUE  SSCAL
XC
X      REAL SA,SX(1)
XC***FIRST EXECUTABLE STATEMENT  SSCAL
X      IF(N.LE.0)RETURN
X      IF(INCX.EQ.1)GOTO 20
XC
XC        CODE FOR INCREMENTS NOT EQUAL TO 1.
XC
X      NS = N*INCX
X          DO 10 I = 1,NS,INCX
X          SX(I) = SA*SX(I)
X   10     CONTINUE
X      RETURN
XC
XC        CODE FOR INCREMENTS EQUAL TO 1.
XC
XC
XC        CLEAN-UP LOOP SO REMAINING VECTOR LENGTH IS A MULTIPLE OF 5.
XC
X   20 M = MOD(N,5)
X      IF( M .EQ. 0 ) GO TO 40
X      DO 30 I = 1,M
X        SX(I) = SA*SX(I)
X   30 CONTINUE
X      IF( N .LT. 5 ) RETURN
X   40 MP1 = M + 1
X      DO 50 I = MP1,N,5
X        SX(I) = SA*SX(I)
X        SX(I + 1) = SA*SX(I + 1)
X        SX(I + 2) = SA*SX(I + 2)
X        SX(I + 3) = SA*SX(I + 3)
X        SX(I + 4) = SA*SX(I + 4)
X   50 CONTINUE
X      RETURN
X      END
X      SUBROUTINE SSWAP(N,SX,INCX,SY,INCY)
XC***BEGIN PROLOGUE  SSWAP
XC***DATE WRITTEN   791001   (YYMMDD)
XC***REVISION DATE  820801   (YYMMDD)
XC***CATEGORY NO.  D1A5
XC***KEYWORDS  BLAS,INTERCHANGE,LINEAR ALGEBRA,VECTOR
XC***AUTHOR  LAWSON, C. L., (JPL)
XC           HANSON, R. J., (SNLA)
XC           KINCAID, D. R., (U. OF TEXAS)
XC           KROGH, F. T., (JPL)
XC***PURPOSE  INTERCHANGE S.P VECTORS
XC***DESCRIPTION
XC
XC                B L A S  SUBPROGRAM
XC    DESCRIPTION OF PARAMETERS
XC
XC     --INPUT--
XC        N  NUMBER OF ELEMENTS IN INPUT VECTOR(S)
XC       SX  SINGLE PRECISION VECTOR WITH N ELEMENTS
XC     INCX  STORAGE SPACING BETWEEN ELEMENTS OF SX
XC       SY  SINGLE PRECISION VECTOR WITH N ELEMENTS
XC     INCY  STORAGE SPACING BETWEEN ELEMENTS OF SY
XC
XC     --OUTPUT--
XC       SX  INPUT VECTOR SY (UNCHANGED IF N .LE. 0)
XC       SY  INPUT VECTOR SX (UNCHANGED IF N .LE. 0)
XC
XC     INTERCHANGE SINGLE PRECISION SX AND SINGLE PRECISION SY.
XC     FOR I = 0 TO N-1, INTERCHANGE  SX(LX+I*INCX) AND SY(LY+I*INCY),
XC     WHERE LX = 1 IF INCX .GE. 0, ELSE LX = (-INCX)*N, AND LY IS
XC     DEFINED IN A SIMILAR WAY USING INCY.
XC***REFERENCES  LAWSON C.L., HANSON R.J., KINCAID D.R., KROGH F.T.,
XC                 *BASIC LINEAR ALGEBRA SUBPROGRAMS FOR FORTRAN USAGE*,
XC                 ALGORITHM NO. 539, TRANSACTIONS ON MATHEMATICAL
XC                 SOFTWARE, VOLUME 5, NUMBER 3, SEPTEMBER 1979, 308-323
XC***ROUTINES CALLED  (NONE)
XC***END PROLOGUE  SSWAP
XC
X      REAL SX(1),SY(1),STEMP1,STEMP2,STEMP3
XC***FIRST EXECUTABLE STATEMENT  SSWAP
X      IF(N.LE.0)RETURN
X      IF(INCX.EQ.INCY) IF(INCX-1) 5,20,60
X    5 CONTINUE
XC
XC       CODE FOR UNEQUAL OR NONPOSITIVE INCREMENTS.
XC
X      IX = 1
X      IY = 1
X      IF(INCX.LT.0)IX = (-N+1)*INCX + 1
X      IF(INCY.LT.0)IY = (-N+1)*INCY + 1
X      DO 10 I = 1,N
X        STEMP1 = SX(IX)
X        SX(IX) = SY(IY)
X        SY(IY) = STEMP1
X        IX = IX + INCX
X        IY = IY + INCY
X   10 CONTINUE
X      RETURN
XC
XC       CODE FOR BOTH INCREMENTS EQUAL TO 1
XC
XC
XC       CLEAN-UP LOOP SO REMAINING VECTOR LENGTH IS A MULTIPLE OF 3.
XC
X   20 M = MOD(N,3)
X      IF( M .EQ. 0 ) GO TO 40
X      DO 30 I = 1,M
X        STEMP1 = SX(I)
X        SX(I) = SY(I)
X        SY(I) = STEMP1
X   30 CONTINUE
X      IF( N .LT. 3 ) RETURN
X   40 MP1 = M + 1
X      DO 50 I = MP1,N,3
X        STEMP1 = SX(I)
X        STEMP2 = SX(I+1)
X        STEMP3 = SX(I+2)
X        SX(I) = SY(I)
X        SX(I+1) = SY(I+1)
X        SX(I+2) = SY(I+2)
X        SY(I) = STEMP1
X        SY(I+1) = STEMP2
X        SY(I+2) = STEMP3
X   50 CONTINUE
X      RETURN
X   60 CONTINUE
XC
XC     CODE FOR EQUAL, POSITIVE, NONUNIT INCREMENTS.
XC
X      NS = N*INCX
X        DO 70 I=1,NS,INCX
X        STEMP1 = SX(I)
X        SX(I) = SY(I)
X        SY(I) = STEMP1
X   70   CONTINUE
X      RETURN
X      END
X      SUBROUTINE BNDACC(G,MDG,NB,IP,IR,MT,JT)
XC***BEGIN PROLOGUE  BNDACC
XC***DATE WRITTEN   790101   (YYMMDD)
XC***REVISION DATE  830513   (YYMMDD)
XC***CATEGORY NO.  D9
XC***KEYWORDS  CURVE FITTING,LEAST SQUARE
XC***AUTHOR  LAWSON, C. L., (JPL)
XC           HANSON, R. J., (SNLA)
XC***PURPOSE  SOLVE THE LEAST SQUARES PROBLEM AX = B FOR BANDED
XC            MATRICES A USING SEQUENTIAL ACCUMULATION OF ROWS OF
XC            THE DATA MATRIX.  EXACTLY ONE RIGHT-HANDED SIDE VECTOR
XC            IS PERMITTED.
XC***DESCRIPTION
XC
XC     THESE SUBROUTINES SOLVE THE LEAST SQUARES PROBLEM AX = B FOR
XC     BANDED MATRICES A USING SEQUENTIAL ACCUMULATION OF ROWS OF THE
XC     DATA MATRIX.  EXACTLY ONE RIGHT-HAND SIDE VECTOR IS PERMITTED.
XC
XC     THESE SUBROUTINES ARE INTENDED FOR THE TYPE OF LEAST SQUARES
XC     SYSTEMS THAT ARISE IN APPLICATIONS SUCH AS CURVE OR SURFACE
XC     FITTING OF DATA.  THE LEAST SQUARES EQUATIONS ARE ACCUMULATED AND
XC     PROCESSED USING ONLY PART OF THE DATA.  THIS REQUIRES A CERTAIN
XC     USER INTERACTION DURING THE SOLUTION OF AX = B.
XC
XC     SPECIFICALLY, SUPPOSE THE DATA MATRIX (A B) IS ROW PARTITIONED
XC     INTO Q SUBMATRICES.  LET (E F) BE THE T-TH ONE OF THESE
XC     SUBMATRICES WHERE E = (0 C 0).  HERE THE DIMENSION OF E IS MT BY N
XC     AND THE DIMENSION OF C IS MT BY NB.  THE VALUE OF NB IS THE
XC     BANDWIDTH OF A.  THE DIMENSIONS OF THE LEADING BLOCK OF ZEROS IN E
XC     ARE MT BY JT-1.
XC
XC     THE USER OF THE SUBROUTINE BNDACC PROVIDES MT,JT,C AND F FOR
XC     T=1,...,Q.  NOT ALL OF THIS DATA MUST BE SUPPLIED AT ONCE.
XC
XC     FOLLOWING THE PROCESSING OF THE VARIOUS BLOCKS (E F), THE MATRIX
XC     (A B) HAS BEEN TRANSFORMED TO THE FORM (R D) WHERE R IS UPPER
XC     TRIANGULAR AND BANDED WITH BANDWIDTH NB.  THE LEAST SQUARES
XC     SYSTEM RX = D IS THEN EASILY SOLVED USING BACK SUBSTITUTION BY
XC     EXECUTING THE STATEMENT CALL BNDSOL(1,...). THE SEQUENCE OF
XC     VALUES FOR JT MUST BE NONDECREASING.  THIS MAY REQUIRE SOME
XC     PRELIMINARY INTERCHANGES OF ROWS AND COLUMNS OF THE MATRIX A.
XC
XC     THE PRIMARY REASON FOR THESE SUBROUTINES IS THAT THE TOTAL
XC     PROCESSING CAN TAKE PLACE IN A WORKING ARRAY OF DIMENSION MU BY
XC     NB+1.  AN ACCEPTABLE VALUE FOR MU IS
XC
XC                       MU = MAX(MT + N + 1),
XC
XC     WHERE N IS THE NUMBER OF UNKNOWNS.
XC
XC     HERE THE MAXIMUM IS TAKEN OVER ALL VALUES OF MT FOR T=1,...,Q.
XC     NOTICE THAT MT CAN BE TAKEN TO BE A SMALL AS ONE, SHOWING THAT
XC     MU CAN BE AS SMALL AS N+2.  THE SUBPROGRAM BNDACC PROCESSES THE
XC     ROWS MORE EFFICIENTLY IF MU IS LARGE ENOUGH SO THAT EACH NEW
XC     BLOCK (C F) HAS A DISTINCT VALUE OF JT.
XC
XC     THE FOUR PRINCIPLE PARTS OF THESE ALGORITHMS ARE OBTAINED BY THE
XC     FOLLOWING CALL STATEMENTS
XC
XC     CALL BNDACC(...)  INTRODUCE NEW BLOCKS OF DATA.
XC
XC     CALL BNDSOL(1,...)COMPUTE SOLUTION VECTOR AND LENGTH OF
XC                       RESIDUAL VECTOR.
XC
XC     CALL BNDSOL(2,...)GIVEN ANY ROW VECTOR H SOLVE YR = H FOR THE
XC                       ROW VECTOR Y.
XC
XC     CALL BNDSOL(3,...)GIVEN ANY COLUMN VECTOR W SOLVE RZ = W FOR
XC                       THE COLUMN VECTOR Z.
XC
XC     THE DOTS IN THE ABOVE CALL STATEMENTS INDICATE ADDITIONAL
XC     ARGUMENTS THAT WILL BE SPECIFIED IN THE FOLLOWING PARAGRAPHS.
XC
XC     THE USER MUST DIMENSION THE ARRAY APPEARING IN THE CALL LIST..
XC     G(MDG,NB+1)
XC
XC     DESCRIPTION OF CALLING SEQUENCE FOR BNDACC..
XC
XC     THE ENTIRE SET OF PARAMETERS FOR BNDACC ARE
XC
XC     INPUT..
XC
XC     G(*,*)            THE WORKING ARRAY INTO WHICH THE USER WILL
XC                       PLACE THE MT BY NB+1 BLOCK (C F) IN ROWS IR
XC                       THROUGH IR+MT-1, COLUMNS 1 THROUGH NB+1.
XC                       SEE DESCRIPTIONS OF IR AND MT BELOW.
XC
XC     MDG               THE NUMBER OF ROWS IN THE WORKING ARRAY
XC                       G(*,*).  THE VALUE OF MDG SHOULD BE .GE. MU.
XC                       THE VALUE OF MU IS DEFINED IN THE ABSTRACT
XC                       OF THESE SUBPROGRAMS.
XC
XC     NB                THE BANDWIDTH OF THE DATA MATRIX A.
XC
XC     IP                SET BY THE USER TO THE VALUE 1 BEFORE THE
XC                       FIRST CALL TO BNDACC.  ITS SUBSEQUENT VALUE
XC                       IS CONTROLLED BY BNDACC TO SET UP FOR THE
XC                       NEXT CALL TO BNDACC.
XC
XC     IR                INDEX OF THE ROW OF G(*,*) WHERE THE USER IS
XC                       TO PLACE THE NEW BLOCK OF DATA (C F).  SET BY
XC                       THE USER TO THE VALUE 1 BEFORE THE FIRST CALL
XC                       TO BNDACC.  ITS SUBSEQUENT VALUE IS CONTROLLED
XC                       BY BNDACC. A VALUE OF IR .GT. MDG IS CONSIDERED
XC                       AN ERROR.
XC
XC     MT,JT             SET BY THE USER TO INDICATE RESPECTIVELY THE
XC                       NUMBER OF NEW ROWS OF DATA IN THE BLOCK AND
XC                       THE INDEX OF THE FIRST NONZERO COLUMN IN THAT
XC                       SET OF ROWS (E F) = (0 C 0 F) BEING PROCESSED.
XC
XC     OUTPUT..
XC
XC     G(*,*)            THE WORKING ARRAY WHICH WILL CONTAIN THE
XC                       PROCESSED ROWS OF THAT PART OF THE DATA
XC                       MATRIX WHICH HAS BEEN PASSED TO BNDACC.
XC
XC     IP,IR             THE VALUES OF THESE ARGUMENTS ARE ADVANCED BY
XC                       BNDACC TO BE READY FOR STORING AND PROCESSING
XC                       A NEW BLOCK OF DATA IN G(*,*).
XC
XC     DESCRIPTION OF CALLING SEQUENCE FOR BNDSOL..
XC
XC     THE USER MUST DIMENSION THE ARRAYS APPEARING IN THE CALL LIST..
XC
XC     G(MDG,NB+1), X(N)
XC
XC     THE ENTIRE SET OF PARAMETERS FOR BNDSOL ARE
XC
XC     INPUT..
XC
XC     MODE              SET BY THE USER TO ONE OF THE VALUES 1, 2, OR
XC                       3.  THESE VALUES RESPECTIVELY INDICATE THAT
XC                       THE SOLUTION OF AX = B, YR = H OR RZ = W IS
XC                       REQUIRED.
XC
XC     G(*,*),MDG,       THESE ARGUMENTS ALL HAVE THE SAME MEANING AND
XC      NB,IP,IR         CONTENTS AS FOLLOWING THE LAST CALL TO BNDACC.
XC
XC     X(*)              WITH MODE=2 OR 3 THIS ARRAY CONTAINS,
XC                       RESPECTIVELY, THE RIGHT-SIDE VECTORS H OR W OF
XC                       THE SYSTEMS YR = H OR RZ = W.
XC
XC     N                 THE NUMBER OF VARIABLES IN THE SOLUTION
XC                       VECTOR.  IF ANY OF THE N DIAGONAL TERMS ARE
XC                       ZERO THE SUBROUTINE BNDSOL PRINTS AN
XC                       APPROPRIATE MESSAGE.  THIS CONDITION IS
XC                       CONSIDERED AN ERROR.
XC
XC     OUTPUT..
XC
XC     X(*)              THIS ARRAY CONTAINS THE SOLUTION VECTORS X,
XC                       Y OR Z OF THE SYSTEMS AX = B, YR = H OR
XC                       RZ = W DEPENDING ON THE VALUE OF MODE=1,
XC                       2 OR 3.
XC
XC     RNORM             IF MODE=1 RNORM IS THE EUCLIDEAN LENGTH OF THE
XC                       RESIDUAL VECTOR AX-B.  WHEN MODE=2 OR 3 RNORM
XC                       IS SET TO ZERO.
XC
XC     REMARKS..
XC
XC     TO OBTAIN THE UPPER TRIANGULAR MATRIX AND TRANSFORMED RIGHT-HAND
XC     SIDE VECTOR D SO THAT THE SUPER DIAGONALS OF R FORM THE COLUMNS
XC     OF G(*,*), EXECUTE THE FOLLOWING FORTRAN STATEMENTS.
XC
XC     NBP1=NB+1
XC
XC     DO 10 J=1, NBP1
XC
XC  10 G(IR,J) = 0.E0
XC
XC     MT=1
XC
XC     JT=N+1
XC
XC     CALL BNDACC(G,MDG,NB,IP,IR,MT,JT)
XC***REFERENCES  C. L. LAWSON AND R. J. HANSON,
XC                 SOLVING LEAST SQUARE PROBLEMS,PRENCTICE-HALL, INC
XC                 (1974), CHAPTER 27
XC***ROUTINES CALLED  H12,XERROR
XC***END PROLOGUE  BNDACC
X      DIMENSION G(MDG,1)
XC***FIRST EXECUTABLE STATEMENT  BNDACC
X      ZERO=0.
XC
XC              ALG. STEPS 1-4 ARE PERFORMED EXTERNAL TO THIS SUBROUTINE.
XC
X      NBP1=NB+1
X      IF (MT.LE.0.OR.NB.LE.0) RETURN
XC
X      IF(.NOT.MDG.LT.IR) GO TO 5
X      NERR=1
X      IOPT=2
X      CALL XERROR( 'BNDACC MDG.LT.IR.. PROBABLE ERROR.',34,NERR,IOPT)
X      RETURN
X    5 CONTINUE
XC
XC                                             ALG. STEP 5
X      IF (JT.EQ.IP) GO TO 70
XC                                             ALG. STEPS 6-7
X      IF (JT.LE.IR) GO TO 30
XC                                             ALG. STEPS 8-9
X      DO 10 I=1,MT
X        IG1=JT+MT-I
X        IG2=IR+MT-I
X        DO 10 J=1,NBP1
X        G(IG1,J)=G(IG2,J)
X   10 CONTINUE
XC                                             ALG. STEP 10
X      IE=JT-IR
X      DO 20 I=1,IE
X        IG=IR+I-1
X        DO 20 J=1,NBP1
X        G(IG,J)=ZERO
X   20 CONTINUE
XC                                             ALG. STEP 11
X      IR=JT
XC                                             ALG. STEP 12
X   30 MU=MIN0(NB-1,IR-IP-1)
X      IF (MU.EQ.0) GO TO 60
XC                                             ALG. STEP 13
X      DO 50 L=1,MU
XC                                             ALG. STEP 14
X        K=MIN0(L,JT-IP)
XC                                             ALG. STEP 15
X        LP1=L+1
X        IG=IP+L
X        DO 40 I=LP1,NB
X          JG=I-K
X          G(IG,JG)=G(IG,I)
X   40 CONTINUE
XC                                             ALG. STEP 16
X        DO 50 I=1,K
X        JG=NBP1-I
X        G(IG,JG)=ZERO
X   50 CONTINUE
XC                                             ALG. STEP 17
X   60 IP=JT
XC                                             ALG. STEPS 18-19
X   70 MH=IR+MT-IP
X      KH=MIN0(NBP1,MH)
XC                                             ALG. STEP 20
X      DO 80 I=1,KH
X        CALL H12 (1,I,MAX0(I+1,IR-IP+1),MH,G(IP,I),1,RHO,
X     1            G(IP,I+1),1,MDG,NBP1-I)
X   80 CONTINUE
XC                                             ALG. STEP 21
X      IR=IP+KH
XC                                             ALG. STEP 22
X      IF (KH.LT.NBP1) GO TO 100
XC                                             ALG. STEP 23
X      DO 90 I=1,NB
X        G(IR-1,I)=ZERO
X   90 CONTINUE
XC                                             ALG. STEP 24
X  100 CONTINUE
XC                                             ALG. STEP 25
X      RETURN
X      END
X      SUBROUTINE BNDSOL(MODE,G,MDG,NB,IP,IR,X,N,RNORM)
XC***BEGIN PROLOGUE  BNDSOL
XC***DATE WRITTEN   790101   (YYMMDD)
XC***REVISION DATE  830513   (YYMMDD)
XC***CATEGORY NO.  D9
XC***KEYWORDS  CURVE FITTING,LEAST SQUARE
XC***AUTHOR  LAWSON, C. L., (JPL)
XC           HANSON, R. J., (SNLA)
XC***PURPOSE  SOLVE THE LEAST SQUARES PROBLEM AX = B FOR BANDED
XC            MATRICES A USING SEQUENTIAL ACCUMULATION OF ROWS OF
XC            THE DATA MATRIX.  EXACTLY ONE RIGHT-HANDED SIDE VECTOR
XC            IS PERMITTED.
XC***DESCRIPTION
XC
XC     THESE SUBROUTINES SOLVE THE LEAST SQUARES PROBLEM AX = B FOR
XC     BANDED MATRICES A USING SEQUENTIAL ACCUMULATION OF ROWS OF THE
XC     DATA MATRIX.  EXACTLY ONE RIGHT-HAND SIDE VECTOR IS PERMITTED.
XC
XC     THESE SUBROUTINES ARE INTENDED FOR THE TYPE OF LEAST SQUARES
XC     SYSTEMS THAT ARISE IN APPLICATIONS SUCH AS CURVE OR SURFACE
XC     FITTING OF DATA.  THE LEAST SQUARES EQUATIONS ARE ACCUMULATED AND
XC     PROCESSED USING ONLY PART OF THE DATA.  THIS REQUIRES A CERTAIN
XC     USER INTERACTION DURING THE SOLUTION OF AX = B.
XC
XC     SPECIFICALLY, SUPPOSE THE DATA MATRIX (A B) IS ROW PARTITIONED
XC     INTO Q SUBMATRICES.  LET (E F) BE THE T-TH ONE OF THESE
XC     SUBMATRICES WHERE E = (0 C 0).  HERE THE DIMENSION OF E IS MT BY N
XC     AND THE DIMENSION OF C IS MT BY NB.  THE VALUE OF NB IS THE
XC     BANDWIDTH OF A.  THE DIMENSIONS OF THE LEADING BLOCK OF ZEROS IN E
XC     ARE MT BY JT-1.
XC
XC     THE USER OF THE SUBROUTINE BNDACC PROVIDES MT,JT,C AND F FOR
XC     T=1,...,Q.  NOT ALL OF THIS DATA MUST BE SUPPLIED AT ONCE.
XC
XC     FOLLOWING THE PROCESSING OF THE VARIOUS BLOCKS (E F), THE MATRIX
XC     (A B) HAS BEEN TRANSFORMED TO THE FORM (R D) WHERE R IS UPPER
XC     TRIANGULAR AND BANDED WITH BANDWIDTH NB.  THE LEAST SQUARES
XC     SYSTEM RX = D IS THEN EASILY SOLVED USING BACK SUBSTITUTION BY
XC     EXECUTING THE STATEMENT CALL BNDSOL(1,...). THE SEQUENCE OF
XC     VALUES FOR JT MUST BE NONDECREASING.  THIS MAY REQUIRE SOME
XC     PRELIMINARY INTERCHANGES OF ROWS AND COLUMNS OF THE MATRIX A.
XC
XC     THE PRIMARY REASON FOR THESE SUBROUTINES IS THAT THE TOTAL
XC     PROCESSING CAN TAKE PLACE IN A WORKING ARRAY OF DIMENSION MU BY
XC     NB+1.  AN ACCEPTABLE VALUE FOR MU IS
XC
XC                       MU = MAX(MT + N + 1),
XC
XC     WHERE N IS THE NUMBER OF UNKNOWNS.
XC
XC     HERE THE MAXIMUM IS TAKEN OVER ALL VALUES OF MT FOR T=1,...,Q.
XC     NOTICE THAT MT CAN BE TAKEN TO BE A SMALL AS ONE, SHOWING THAT
XC     MU CAN BE AS SMALL AS N+2.  THE SUBPROGRAM BNDACC PROCESSES THE
XC     ROWS MORE EFFICIENTLY IF MU IS LARGE ENOUGH SO THAT EACH NEW
XC     BLOCK (C F) HAS A DISTINCT VALUE OF JT.
XC
XC     THE FOUR PRINCIPLE PARTS OF THESE ALGORITHMS ARE OBTAINED BY THE
XC     FOLLOWING CALL STATEMENTS
XC
XC     CALL BNDACC(...)  INTRODUCE NEW BLOCKS OF DATA.
XC
XC     CALL BNDSOL(1,...)COMPUTE SOLUTION VECTOR AND LENGTH OF
XC                       RESIDUAL VECTOR.
XC
XC     CALL BNDSOL(2,...)GIVEN ANY ROW VECTOR H SOLVE YR = H FOR THE
XC                       ROW VECTOR Y.
XC
XC     CALL BNDSOL(3,...)GIVEN ANY COLUMN VECTOR W SOLVE RZ = W FOR
XC                       THE COLUMN VECTOR Z.
XC
XC     THE DOTS IN THE ABOVE CALL STATEMENTS INDICATE ADDITIONAL
XC     ARGUMENTS THAT WILL BE SPECIFIED IN THE FOLLOWING PARAGRAPHS.
XC
XC     THE USER MUST DIMENSION THE ARRAY APPEARING IN THE CALL LIST..
XC     G(MDG,NB+1)
XC
XC     DESCRIPTION OF CALLING SEQUENCE FOR BNDACC..
XC
XC     THE ENTIRE SET OF PARAMETERS FOR BNDACC ARE
XC
XC     INPUT..
XC
XC     G(*,*)            THE WORKING ARRAY INTO WHICH THE USER WILL
XC                       PLACE THE MT BY NB+1 BLOCK (C F) IN ROWS IR
XC                       THROUGH IR+MT-1, COLUMNS 1 THROUGH NB+1.
XC                       SEE DESCRIPTIONS OF IR AND MT BELOW.
XC
XC     MDG               THE NUMBER OF ROWS IN THE WORKING ARRAY
XC                       G(*,*).  THE VALUE OF MDG SHOULD BE .GE. MU.
XC                       THE VALUE OF MU IS DEFINED IN THE ABSTRACT
XC                       OF THESE SUBPROGRAMS.
XC
XC     NB                THE BANDWIDTH OF THE DATA MATRIX A.
XC
XC     IP                SET BY THE USER TO THE VALUE 1 BEFORE THE
XC                       FIRST CALL TO BNDACC.  ITS SUBSEQUENT VALUE
XC                       IS CONTROLLED BY BNDACC TO SET UP FOR THE
XC                       NEXT CALL TO BNDACC.
XC
XC     IR                INDEX OF THE ROW OF G(*,*) WHERE THE USER IS
XC                       THE USER TO THE VALUE 1 BEFORE THE FIRST CALL
XC                       TO BNDACC.  ITS SUBSEQUENT VALUE IS CONTROLLED
XC                       BY BNDACC. A VALUE OF IR .GT. MDG IS CONSIDERED
XC                       AN ERROR.
XC
XC     MT,JT             SET BY THE USER TO INDICATE RESPECTIVELY THE
XC                       NUMBER OF NEW ROWS OF DATA IN THE BLOCK AND
XC                       THE INDEX OF THE FIRST NONZERO COLUMN IN THAT
XC                       SET OF ROWS (E F) = (0 C 0 F) BEING PROCESSED.
XC     OUTPUT..
XC
XC     G(*,*)            THE WORKING ARRAY WHICH WILL CONTAIN THE
XC                       PROCESSED ROWS OF THAT PART OF THE DATA
XC                       MATRIX WHICH HAS BEEN PASSED TO BNDACC.
XC
XC     IP,IR             THE VALUES OF THESE ARGUMENTS ARE ADVANCED BY
XC                       BNDACC TO BE READY FOR STORING AND PROCESSING
XC                       A NEW BLOCK OF DATA IN G(*,*).
XC
XC     DESCRIPTION OF CALLING SEQUENCE FOR BNDSOL..
XC
XC     THE USER MUST DIMENSION THE ARRAYS APPEARING IN THE CALL LIST..
XC
XC     G(MDG,NB+1), X(N)
XC
XC     THE ENTIRE SET OF PARAMETERS FOR BNDSOL ARE
XC
XC     INPUT..
XC
XC     MODE              SET BY THE USER TO ONE OF THE VALUES 1, 2, OR
XC                       3.  THESE VALUES RESPECTIVELY INDICATE THAT
XC                       THE SOLUTION OF AX = B, YR = H OR RZ = W IS
XC                       REQUIRED.
XC
XC     G(*,*),MDG,       THESE ARGUMENTS ALL HAVE THE SAME MEANING AND
XC      NB,IP,IR         CONTENTS AS FOLLOWING THE LAST CALL TO BNDACC.
XC
XC     X(*)              WITH MODE=2 OR 3 THIS ARRAY CONTAINS,
XC                       RESPECTIVELY, THE RIGHT-SIDE VECTORS H OR W OF
XC                       THE SYSTEMS YR = H OR RZ = W.
XC
XC     N                 THE NUMBER OF VARIABLES IN THE SOLUTION
XC                       VECTOR.  IF ANY OF THE N DIAGONAL TERMS ARE
XC                       ZERO THE SUBROUTINE BNDSOL PRINTS AN
XC                       APPROPRIATE MESSAGE.  THIS CONDITION IS
XC                       CONSIDERED AN ERROR.
XC
XC     OUTPUT..
XC
XC     X(*)              THIS ARRAY CONTAINS THE SOLUTION VECTORS X,
XC                       Y OR Z OF THE SYSTEMS AX = B, YR = H OR
XC                       RZ = W DEPENDING ON THE VALUE OF MODE=1,
XC                       2 OR 3.
XC
XC     RNORM             IF MODE=1 RNORM IS THE EUCLIDEAN LENGTH OF THE
XC                       RESIDUAL VECTOR AX-B.  WHEN MODE=2 OR 3 RNORM
XC                       IS SET TO ZERO.
XC
XC     REMARKS..
XC
XC     TO OBTAIN THE UPPER TRIANGULAR MATRIX AND TRANSFORMED RIGHT-HAND
XC     SIDE VECTOR D SO THAT THE SUPER DIAGONALS OF R FORM THE COLUMNS
XC     OF G(*,*), EXECUTE THE FOLLOWING FORTRAN STATEMENTS.
XC
XC     NBP1=NB+1
XC
XC     DO 10 J=1, NBP1
XC
XC  10 G(IR,J) = 0.E0
XC
XC     MT=1
XC
XC     JT=N+1
XC
XC     CALL BNDACC(G,MDG,NB,IP,IR,MT,JT)
XC***REFERENCES  C. L. LAWSON AND R. J. HANSON,
XC                 SOLVING LEAST SQUARE PROBLEMS,PRENCTICE-HALL, INC
XC                 (1974), CHAPTER 27
XC***ROUTINES CALLED  XERROR
XC***END PROLOGUE  BNDSOL
X      DIMENSION G(MDG,1),X(N)
XC***FIRST EXECUTABLE STATEMENT  BNDSOL
X      ZERO=0.
XC
X      RNORM=ZERO
X      GO TO (10,90,50), MODE
XC                                   ********************* MODE = 1
XC                                   ALG. STEP 26
X   10      DO 20 J=1,N
X           X(J)=G(J,NB+1)
X   20 CONTINUE
X      RSQ=ZERO
X      NP1=N+1
X      IRM1=IR-1
X      IF (NP1.GT.IRM1) GO TO 40
X           DO 30 J=NP1,IRM1
X           RSQ=RSQ+G(J,NB+1)**2
X   30 CONTINUE
X      RNORM=SQRT(RSQ)
X   40 CONTINUE
XC                                   ********************* MODE = 3
XC                                   ALG. STEP 27
X   50      DO 80 II=1,N
X           I=N+1-II
XC                                   ALG. STEP 28
X           S=ZERO
X           L=MAX0(0,I-IP)
XC                                   ALG. STEP 29
X           IF (I.EQ.N) GO TO 70
XC                                   ALG. STEP 30
X           IE=MIN0(N+1-I,NB)
X                DO 60 J=2,IE
X                JG=J+L
X                IX=I-1+J
X                S=S+G(I,JG)*X(IX)
X   60 CONTINUE
XC                                   ALG. STEP 31
X   70      IF (G(I,L+1)) 80,130,80
X   80      X(I)=(X(I)-S)/G(I,L+1)
XC                                   ALG. STEP 32
X      RETURN
XC                                   ********************* MODE = 2
X   90      DO 120 J=1,N
X           S=ZERO
X           IF (J.EQ.1) GO TO 110
X           I1=MAX0(1,J-NB+1)
X           I2=J-1
X                DO 100 I=I1,I2
X                L=J-I+1+MAX0(0,I-IP)
X                S=S+X(I)*G(I,L)
X  100 CONTINUE
X  110      L=MAX0(0,J-IP)
X           IF (G(J,L+1)) 120,130,120
X  120      X(J)=(X(J)-S)/G(J,L+1)
X      RETURN
XC
X  130 CONTINUE
X      NERR=1
X      IOPT=2
X      CALL XERROR (  'BNDSOL A ZERO DIAGONAL TERM IS IN THE N BY N UPPER
X     1 TRIANGULAR MATRIX.',69,NERR,IOPT)
X      RETURN
X      END
X      SUBROUTINE BSPLVN(T,JHIGH,INDEX,X,ILEFT,VNIKX)
XC***BEGIN PROLOGUE  BSPLVN
XC***REFER TO  FC
XC
XC CALCULATES THE VALUE OF ALL POSSIBLY NONZERO B-SPLINES AT *X* OF
XC  ORDER MAX(JHIGH,(J+1)(INDEX-1)) ON *T*.
XC***ROUTINES CALLED  (NONE)
XC***END PROLOGUE  BSPLVN
X      DIMENSION T(1),VNIKX(1)
X      DIMENSION DELTAM(20),DELTAP(20)
X      DATA J/1/,(DELTAM(I),I=1,20),(DELTAP(I),I=1,20)/40*0./
XC***FIRST EXECUTABLE STATEMENT  BSPLVN
X                                       GO TO (10,20),INDEX
X   10 J = 1
X      VNIKX(1) = 1.
X      IF (J .GE. JHIGH)                GO TO 99
XC
X   20    IPJ = ILEFT+J
X         DELTAP(J) = T(IPJ) - X
X         IMJP1 = ILEFT-J+1
X         DELTAM(J) = X - T(IMJP1)
X         VMPREV = 0.
X         JP1 = J+1
X         DO 26 L=1,J
X            JP1ML = JP1-L
X            VM = VNIKX(L)/(DELTAP(L) + DELTAM(JP1ML))
X            VNIKX(L) = VM*DELTAP(L) + VMPREV
X   26       VMPREV = VM*DELTAM(JP1ML)
X         VNIKX(JP1) = VMPREV
X         J = JP1
X         IF (J .LT. JHIGH)             GO TO 20
XC
X   99                                  RETURN
X      END
X      SUBROUTINE EFCMN(NDATA,XDATA,YDATA,SDDATA,NORD,NBKPT,BKPTIN,
X     1   MDEIN,MDEOUT,COEFF,BF,XTEMP,PTEMP,BKPT,G,MDG,W,MDW,LW)
XC***BEGIN PROLOGUE  EFCMN
XC***REFER TO  EFC
XC
XC     THIS IS A COMPANION SUBPROGRAM TO EFC( ).
XC     THIS SUBPROGRAM DOES WEIGHTED LEAST SQUARES FITTING
XC     OF DATA BY B-SPLINE CURVES.
XC     THE DOCUMENTATION FOR EFC( ) HAS MORE COMPLETE
XC     USAGE INSTRUCTIONS.
XC
XC     REVISED 800905-1300
XC     REVISED YYMMDD-HHMM
XC     R. HANSON, SNLA 87185 SEPTEMBER, 1980.
XC***ROUTINES CALLED  BNDACC,BNDSOL,BSPLVN,SCOPY,SSCAL,SSORT,XERROR,
XC                    XERRWV
XC***END PROLOGUE  EFCMN
X      DIMENSION XDATA(NDATA), YDATA(NDATA), SDDATA(NDATA), BKPTIN(NBKPT)
X      DIMENSION COEFF(1), BF(NORD,NORD)
X      DIMENSION XTEMP(1), PTEMP(1), BKPT(NBKPT)
X      DIMENSION G(MDG,1), W(MDW,1)
XC***FIRST EXECUTABLE STATEMENT  EFCMN
X      ASSIGN 10 TO NPR001
X      GO TO 40
X   10 ASSIGN 20 TO NPR002
X      GO TO 100
X   20 ASSIGN 30 TO NPR003
X      GO TO 360
X   30 RETURN
XC     PROCEDURE (INITIALIZE-VARIABLES-AND-ANALYZE-INPUT)
XC
XC     PROCEDURE (INITIALIZE-VARIABLES-AND-ANALYZE-INPUT)
X   40 ZERO = 0.E0
X      ONE = 1.E0
X      L = NBKPT - NORD + 1
XC
XC     COMPUTE THE NUMBER OF VARIABLES.
X      N = NBKPT - NORD
XC
XC     INITIALLY SET ALL OUTPUT COEFFICIENTS TO ZERO.
X      CALL SCOPY(N, ZERO, 0, COEFF, 1)
X      NP1 = L
X      IF (.NOT.(.NOT.(1.LE.NORD .AND. NORD.LE.20))) GO TO 50
X      CALL XERROR( 'EFC( ), THE ORDER OF THE B-SPLINE MUST BE 1 THRU 20.
X     1', 52, 3,   1)
X      MDEOUT = -1
X      RETURN
XC
X   50 IF (.NOT.(NBKPT.LT.2*NORD)) GO TO 60
X      CALL XERROR( 'EFC( ), NUMBER OF KNOTS MUST BE AT LEAST TWICE THE B
X     1-SPLINE ORDER.', 66, 4, 1)
X      MDEOUT = -1
X      RETURN
X   60 IF (.NOT.(NDATA.LT.0)) GO TO 70
X      CALL XERROR( 'EFC( ), THE NUMBER OF DATA POINTS MUST BE NONNEGATIV
X     1E.', 54,    5, 1)
X      MDEOUT = -1
X      RETURN
X   70 NB = (NBKPT-NORD+3)*(NORD+1) + (NBKPT+1)*(NORD+1) +
X     1 2*MAX0(NBKPT,NDATA) + NBKPT + NORD**2
X      IF (.NOT.(LW.LT.NB)) GO TO 80
X      CALL XERRWV( 'EFC( ). INSUFF. STORAGE FOR W(*). CHECK FORMULA THAT
X     1 READS LW.GE. ... . (I1)=NEEDED, (I2)=GIVEN.', 96, 6, 1, 2, NB,
X     2 LW, 0, DUMMY, DUMMY)
X      MDEOUT = -1
X      RETURN
X   80 IF (.NOT.(.NOT.(MDEIN.EQ.1 .OR. MDEIN.EQ.2))) GO TO 90
X      CALL XERROR( 'EFC( ), INPUT VALUE OF MDEIN MUST BE 1-2.', 41, 7,
X     1 1)
X      MDEOUT = -1
X      RETURN
XC
XC     SORT THE BREAKPOINTS.
X   90 CALL SCOPY(NBKPT, BKPTIN, 1, BKPT, 1)
X      CALL SSORT(BKPT, DUMMY, NBKPT, 1)
X      XMIN = BKPT(NORD)
XC
XC     DEFINE THE INDEX OF RIGHT-MOST INTERVAL-DEFINING KNOT.
X      LAST = L
X      XMAX = BKPT(LAST)
X      NORDM1 = NORD - 1
X      NORDP1 = NORD + 1
X      GO TO NPR001, (10)
XC     PROCEDURE (PROCESS-LEAST-SQUARES-EQUATIONS)
XC
XC     SORT DATA AND AN ARRAY OF POINTERS.
X  100 CALL SCOPY(NDATA, XDATA, 1, XTEMP, 1)
X      I = 1
X      N20019 = NDATA
X      GO TO 120
X  110 I = I + 1
X  120 IF ((N20019-I).LT.0) GO TO 130
X      PTEMP(I) = I
X      GO TO 110
X  130 IF (.NOT.(NDATA.GT.0)) GO TO 140
X      CALL SSORT(XTEMP, PTEMP, NDATA, 2)
X      XMIN = AMIN1(XMIN,XTEMP(1))
X      XMAX = AMAX1(XMAX,XTEMP(NDATA))
XC
XC     FIX BREAKPOINT ARRAY IF NEEDED. THIS SHOULD ONLY INVOLVE VERY
XC     MINOR DIFFERENCES WITH THE INPUT ARRAY OF BREAKPOINTS.
X  140 I = 1
X      N20026 = NORD
X      GO TO 160
X  150 I = I + 1
X  160 IF ((N20026-I).LT.0) GO TO 170
X      BKPT(I) = AMIN1(BKPT(I),XMIN)
X      GO TO 150
X  170 I = LAST
X      N20030 = NBKPT
X      GO TO 190
X  180 I = I + 1
X  190 IF ((N20030-I).LT.0) GO TO 200
X      BKPT(I) = AMAX1(BKPT(I),XMAX)
X      GO TO 180
XC
XC     INITIALIZE PARAMETERS OF BANDED MATRIX PROCESSOR, BNDACC( ).
X  200 MT = 0
X      IP = 1
X      IR = 1
X      IDATA = 1
X      ILEFT = NORD
X      INTSEQ = 1
X  210 IF (.NOT.(IDATA.LE.NDATA)) GO TO 280
XC
XC     SORTED INDICES ARE IN PTEMP(*).
X      L = PTEMP(IDATA)
X      XVAL = XDATA(L)
XC
XC     WHEN INTERVAL CHANGES, PROCESS EQUATIONS IN THE LAST BLOCK.
X      IF (.NOT.(XVAL.GE.BKPT(ILEFT+1))) GO TO 250
X      INTRVL = ILEFT - NORDM1
X      CALL BNDACC(G, MDG, NORD, IP, IR, MT, INTRVL)
X      MT = 0
XC
XC     MOVE POINTER UP TO HAVE BKPT(ILEFT).LE.XVAL, ILEFT.LT.LAST.
X  220 IF (.NOT.(XVAL.GE.BKPT(ILEFT+1) .AND. ILEFT.LT.LAST-1)) GO TO 240
X      IF (.NOT.(MDEIN.EQ.2)) GO TO 230
XC
XC     DATA IS BEING SEQUENTIALLY ACCUMULATED. TRANSFER
XC     PREVIOUSLY ACCUMULATED ROWS FROM W(*,*) TO G(*,*)
XC     AND PROCESS THEM.
X      CALL SCOPY(NORDP1, W(INTSEQ,1), MDW, G(IR,1), MDG)
X      CALL BNDACC(G, MDG, NORD, IP, IR, 1, INTSEQ)
X      INTSEQ = INTSEQ + 1
X  230 ILEFT = ILEFT + 1
X      GO TO 220
X  240 CONTINUE
XC
XC     OBTAIN B-SPLINE FUNCTION VALUE.
X  250 CALL BSPLVN(BKPT, NORD, 1, XVAL, ILEFT, BF)
XC
XC     MOVE ROW INTO PLACE.
X      IROW = IR + MT
X      MT = MT + 1
X      CALL SCOPY(NORD, BF, 1, G(IROW,1), MDG)
X      G(IROW,NORDP1) = YDATA(L)
XC
XC     SCALE DATA IF UNCERTAINTY IS NONZERO.
X      IF (.NOT.(SDDATA(L).NE.ZERO)) GO TO 260
X      CALL SSCAL(NORDP1, ONE/SDDATA(L), G(IROW,1), MDG)
XC
XC     WHEN STAGING WORK AREA IS EXHAUSTED, PROCESS ROWS.
X  260 IF (.NOT.(IROW.EQ.MDG-1)) GO TO 270
X      INTRVL = ILEFT - NORDM1
X      CALL BNDACC(G, MDG, NORD, IP, IR, MT, INTRVL)
X      MT = 0
X  270 IDATA = IDATA + 1
X      GO TO 210
XC
XC     PROCESS LAST BLOCK OF EQUATIONS.
X  280 INTRVL = ILEFT - NORDM1
X      CALL BNDACC(G, MDG, NORD, IP, IR, MT, INTRVL)
XC
XC     FINISH PROCESSING ANY PREVIOUSLY ACCUMULATED
XC     ROWS FROM W(*,*) TO G(*,*).
X      IF (.NOT.(MDEIN.EQ.2)) GO TO 320
X  290 CALL SCOPY(NORDP1, W(INTSEQ,1), MDW, G(IR,1), MDG)
X      CALL BNDACC(G, MDG, NORD, IP, IR, 1, MIN0(N,INTSEQ))
X      IF (.NOT.(INTSEQ.EQ.NP1)) GO TO 300
X      GO TO 310
X  300 INTSEQ = INTSEQ + 1
X      GO TO 290
X  310 CONTINUE
XC
XC     LAST CALL TO ADJUST BLOCK POSITIONING.
X  320 G(IR,1) = ZERO
X      CALL SCOPY(NORDP1, G(IR,1), 0, G(IR,1), MDG)
X      CALL BNDACC(G, MDG, NORD, IP, IR, 1, NP1)
XC
XC     TRANSFER ACCUMULATED ROWS FROM G(*,*) TO W(*,*) FOR
XC     POSSIBLE LATER SEQUENTIAL ACCUMULATION.
X      I = 1
X      N20058 = NP1
X      GO TO 340
X  330 I = I + 1
X  340 IF ((N20058-I).LT.0) GO TO 350
X      CALL SCOPY(NORDP1, G(I,1), MDG, W(I,1), MDW)
X      GO TO 330
X  350 GO TO NPR002, (20)
XC     PROCEDURE (SOLVE-FOR-COEFFICIENTS-WHEN-POSSIBLE)
X  360 I = 1
X      N20062 = N
X      GO TO 380
X  370 I = I + 1
X  380 IF ((N20062-I).LT.0) GO TO 400
X      IF (.NOT.(G(I,1).EQ.ZERO)) GO TO 390
X      MDEOUT = 2
X      GO TO 410
X  390 CONTINUE
X      GO TO 370
XC
XC     ALL THE DIAGONAL TERMS IN THE ACCUMULATED TRIANGULAR
XC     MATRIX ARE NONZERO.  THE SOLN. CAN BE COMPUTED BUT
XC     IT MAY BE UNSUITABLE FOR FURTHER USE DUE TO POOR
XC     CONDITIONING OR THE LACK OF CONSTRAINTS.  NO CHECKING
XC     FOR EITHER OF THESE IS DONE HERE.
X  400 MODE = 1
X      CALL BNDSOL(MODE, G, MDG, NORD, IP, IR, COEFF, N, RNORM)
X      MDEOUT = 1
X  410 GO TO NPR003, (30)
X      END
X      SUBROUTINE H12(MODE,LPIVOT,L1,M,U,IUE,UP,C,ICE,ICV,NCV)
XC***BEGIN PROLOGUE  H12
XC***REFER TO  HFTI,LSEI,WNNLS
XC
XC     SUBROUTINE H12 (MODE,LPIVOT,L1,M,U,IUE,UP,C,ICE,ICV,NCV)
XC
XC     C.L.LAWSON AND R.J.HANSON, JET PROPULSION LABORATORY, 1973 JUN 12
XC     TO APPEAR IN 'SOLVING LEAST SQUARES PROBLEMS', PRENTICE-HALL, 1974
XC
XC     MODIFIED AT SANDIA LABS, MAY 1977, TO --
XC
XC     1)  REMOVE DOUBLE PRECISION ACCUMULATION, AND
XC     2)  INCLUDE USAGE OF THE BASIC LINEAR ALGEBRA PACKAGE FOR
XC         VECTORS LONGER THAN A PARTICULAR THRESHOLD.
XC
XC     CONSTRUCTION AND/OR APPLICATION OF A SINGLE
XC     HOUSEHOLDER TRANSFORMATION..     Q = I + U*(U**T)/B
XC
XC     MODE    = 1 OR 2   TO SELECT ALGORITHM  H1  OR  H2 .
XC     LPIVOT IS THE INDEX OF THE PIVOT ELEMENT.
XC     L1,M   IF L1 .LE. M   THE TRANSFORMATION WILL BE CONSTRUCTED TO
XC            ZERO ELEMENTS INDEXED FROM L1 THROUGH M.   IF L1 GT. M
XC            THE SUBROUTINE DOES AN IDENTITY TRANSFORMATION.
XC     U(),IUE,UP    ON ENTRY TO H1 U() CONTAINS THE PIVOT VECTOR.
XC                   IUE IS THE STORAGE INCREMENT BETWEEN ELEMENTS.
XC                                       ON EXIT FROM H1 U() AND UP
XC                   CONTAIN QUANTITIES DEFINING THE VECTOR U OF THE
XC                   HOUSEHOLDER TRANSFORMATION.   ON ENTRY TO H2 U()
XC                   AND UP SHOULD CONTAIN QUANTITIES PREVIOUSLY COMPUTED
XC                   BY H1.  THESE WILL NOT BE MODIFIED BY H2.
XC     C()    ON ENTRY TO H1 OR H2 C() CONTAINS A MATRIX WHICH WILL BE
XC            REGARDED AS A SET OF VECTORS TO WHICH THE HOUSEHOLDER
XC            TRANSFORMATION IS TO BE APPLIED.  ON EXIT C() CONTAINS THE
XC            SET OF TRANSFORMED VECTORS.
XC     ICE    STORAGE INCREMENT BETWEEN ELEMENTS OF VECTORS IN C().
XC     ICV    STORAGE INCREMENT BETWEEN VECTORS IN C().
XC     NCV    NUMBER OF VECTORS IN C() TO BE TRANSFORMED. IF NCV .LE. 0
XC            NO OPERATIONS WILL BE DONE ON C().
XC***ROUTINES CALLED  SAXPY,SDOT,SSWAP
XC***END PROLOGUE  H12
X      DIMENSION U(IUE,M), C(1)
XC***FIRST EXECUTABLE STATEMENT  H12
X      ONE=1.
XC
X      IF (0.GE.LPIVOT.OR.LPIVOT.GE.L1.OR.L1.GT.M) RETURN
X      CL=ABS(U(1,LPIVOT))
X      IF (MODE.EQ.2) GO TO 60
XC                            ****** CONSTRUCT THE TRANSFORMATION. ******
X          DO 10 J=L1,M
X   10     CL=AMAX1(ABS(U(1,J)),CL)
X      IF (CL) 130,130,20
X   20 CLINV=ONE/CL
X      SM=(U(1,LPIVOT)*CLINV)**2
X          DO 30 J=L1,M
X   30     SM=SM+(U(1,J)*CLINV)**2
X      CL=CL*SQRT(SM)
X      IF (U(1,LPIVOT)) 50,50,40
X   40 CL=-CL
X   50 UP=U(1,LPIVOT)-CL
X      U(1,LPIVOT)=CL
X      GO TO 70
XC            ****** APPLY THE TRANSFORMATION  I+U*(U**T)/B  TO C. ******
XC
X   60 IF (CL) 130,130,70
X   70 IF (NCV.LE.0) RETURN
X      B=UP*U(1,LPIVOT)
XC                       B  MUST BE NONPOSITIVE HERE.  IF B = 0., RETURN.
XC
X      IF (B) 80,130,130
X   80 B=ONE/B
X      MML1P2=M-L1+2
X      IF (MML1P2.GT.20) GO TO 140
X      I2=1-ICV+ICE*(LPIVOT-1)
X      INCR=ICE*(L1-LPIVOT)
X          DO 120 J=1,NCV
X          I2=I2+ICV
X          I3=I2+INCR
X          I4=I3
X          SM=C(I2)*UP
X              DO 90 I=L1,M
X              SM=SM+C(I3)*U(1,I)
X   90         I3=I3+ICE
X          IF (SM) 100,120,100
X  100     SM=SM*B
X          C(I2)=C(I2)+SM*UP
X              DO 110 I=L1,M
X              C(I4)=C(I4)+SM*U(1,I)
X  110         I4=I4+ICE
X  120     CONTINUE
X  130 RETURN
X  140 CONTINUE
X      L1M1=L1-1
X      KL1=1+(L1M1-1)*ICE
X      KL2=KL1
X      KLP=1+(LPIVOT-1)*ICE
X      UL1M1=U(1,L1M1)
X      U(1,L1M1)=UP
X      IF (LPIVOT.EQ.L1M1) GO TO 150
X      CALL SSWAP(NCV,C(KL1),ICV,C(KLP),ICV)
X  150 CONTINUE
X          DO 160 J=1,NCV
X          SM=SDOT(MML1P2,U(1,L1M1),IUE,C(KL1),ICE)
X          SM=SM*B
X          CALL SAXPY (MML1P2,SM,U(1,L1M1),IUE,C(KL1),ICE)
X          KL1=KL1+ICV
X  160 CONTINUE
X      U(1,L1M1)=UL1M1
X      IF (LPIVOT.EQ.L1M1) RETURN
X      KL1=KL2
X      CALL SSWAP(NCV,C(KL1),ICV,C(KLP),ICV)
X      RETURN
X      END
X      SUBROUTINE SSORT(X,Y,N,KFLAG)
XC***BEGIN PROLOGUE  SSORT
XC***DATE WRITTEN   761101   (YYMMDD)
XC***REVISION DATE  820801   (YYMMDD)
XC***CATEGORY NO.  N6A2B1
XC***KEYWORDS  QUICKSORT,SINGLETON QUICKSORT,SORT,SORTING
XC***AUTHOR  JONES, R. E., (SNLA)
XC           WISNIEWSKI, J. A., (SNLA)
XC***PURPOSE  SSORT SORTS ARRAY X AND OPTIONALLY MAKES THE SAME
XC            INTERCHANGES IN ARRAY Y.  THE ARRAY X MAY BE SORTED IN
XC            INCREASING ORDER OR DECREASING ORDER.  A SLIGHTLY MODIFIED
XC            QUICKSORT ALGORITHM IS USED.
XC***DESCRIPTION
XC
XC     WRITTEN BY RONDALL E. JONES
XC     MODIFIED BY JOHN A. WISNIEWSKI TO USE THE SINGLETON QUICKSORT
XC     ALGORITHM.  DATE 18 NOVEMBER 1976.
XC
XC     ABSTRACT
XC         SSORT SORTS ARRAY X AND OPTIONALLY MAKES THE SAME
XC         INTERCHANGES IN ARRAY Y.  THE ARRAY X MAY BE SORTED IN
XC         INCREASING ORDER OR DECREASING ORDER.  A SLIGHTLY MODIFIED
XC         QUICKSORT ALGORITHM IS USED.
XC
XC     REFERENCE
XC         SINGLETON, R. C., ALGORITHM 347, AN EFFICIENT ALGORITHM FOR
XC         SORTING WITH MINIMAL STORAGE, CACM,12(3),1969,185-7.
XC
XC     DESCRIPTION OF PARAMETERS
XC         X - ARRAY OF VALUES TO BE SORTED   (USUALLY ABSCISSAS)
XC         Y - ARRAY TO BE (OPTIONALLY) CARRIED ALONG
XC         N - NUMBER OF VALUES IN ARRAY X TO BE SORTED
XC         KFLAG - CONTROL PARAMETER
XC             =2  MEANS SORT X IN INCREASING ORDER AND CARRY Y ALONG.
XC             =1  MEANS SORT X IN INCREASING ORDER (IGNORING Y)
XC             =-1 MEANS SORT X IN DECREASING ORDER (IGNORING Y)
XC             =-2 MEANS SORT X IN DECREASING ORDER AND CARRY Y ALONG.
XC***REFERENCES  SINGLETON,R.C., ALGORITHM 347, AN EFFICIENT ALGORITHM
XC                 FOR SORTING WITH MINIMAL STORAGE, CACM,12(3),1969,
XC                 185-7.
XC***ROUTINES CALLED  XERROR
XC***END PROLOGUE  SSORT
X      DIMENSION X(N),Y(N),IL(21),IU(21)
XC***FIRST EXECUTABLE STATEMENT  SSORT
X      NN = N
X      IF (NN.GE.1) GO TO 10
X      CALL XERROR ( 'SSORT- THE NUMBER OF VALUES TO BE SORTED WAS NOT PO
X     1SITIVE.',58,1,1)
X      RETURN
X   10 KK = IABS(KFLAG)
X      IF ((KK.EQ.1).OR.(KK.EQ.2)) GO TO 15
X      CALL XERROR ( 'SSORT- THE SORT CONTROL PARAMETER, K, WAS NOT 2, 1,
X     1 -1, OR -2.',62,2,1)
X      RETURN
XC
XC ALTER ARRAY X TO GET DECREASING ORDER IF NEEDED
XC
X   15 IF (KFLAG.GE.1) GO TO 30
X      DO 20 I=1,NN
X   20 X(I) = -X(I)
X   30 GO TO (100,200),KK
XC
XC SORT X ONLY
XC
X  100 CONTINUE
X      M=1
X      I=1
X      J=NN
X      R=.375
X  110 IF (I .EQ. J) GO TO 155
X  115 IF (R .GT. .5898437) GO TO 120
X      R=R+3.90625E-2
X      GO TO 125
X  120 R=R-.21875
X  125 K=I
XC                                  SELECT A CENTRAL ELEMENT OF THE
XC                                  ARRAY AND SAVE IT IN LOCATION T
X      IJ = I + IFIX (FLOAT (J-I) * R)
X      T=X(IJ)
XC                                  IF FIRST ELEMENT OF ARRAY IS GREATER
XC                                  THAN T, INTERCHANGE WITH T
X      IF (X(I) .LE. T) GO TO 130
X      X(IJ)=X(I)
X      X(I)=T
X      T=X(IJ)
X  130 L=J
XC                                  IF LAST ELEMENT OF ARRAY IS LESS THAN
XC                                  T, INTERCHANGE WITH T
X      IF (X(J) .GE. T) GO TO 140
X      X(IJ)=X(J)
X      X(J)=T
X      T=X(IJ)
XC                                  IF FIRST ELEMENT OF ARRAY IS GREATER
XC                                  THAN T, INTERCHANGE WITH T
X      IF (X(I) .LE. T) GO TO 140
X      X(IJ)=X(I)
X      X(I)=T
X      T=X(IJ)
X      GO TO 140
X  135 TT=X(L)
X      X(L)=X(K)
X      X(K)=TT
XC                                  FIND AN ELEMENT IN THE SECOND HALF OF
XC                                  THE ARRAY WHICH IS SMALLER THAN T
X  140 L=L-1
X      IF (X(L) .GT. T) GO TO 140
XC                                  FIND AN ELEMENT IN THE FIRST HALF OF
XC                                  THE ARRAY WHICH IS GREATER THAN T
X  145 K=K+1
X      IF (X(K) .LT. T) GO TO 145
XC                                  INTERCHANGE THESE ELEMENTS
X      IF (K .LE. L) GO TO 135
XC                                  SAVE UPPER AND LOWER SUBSCRIPTS OF
XC                                  THE ARRAY YET TO BE SORTED
X      IF (L-I .LE. J-K) GO TO 150
X      IL(M)=I
X      IU(M)=L
X      I=K
X      M=M+1
X      GO TO 160
X  150 IL(M)=K
X      IU(M)=J
X      J=L
X      M=M+1
X      GO TO 160
XC                                  BEGIN AGAIN ON ANOTHER PORTION OF
XC                                  THE UNSORTED ARRAY
X  155 M=M-1
X      IF (M .EQ. 0) GO TO 300
X      I=IL(M)
X      J=IU(M)
X  160 IF (J-I .GE. 1) GO TO 125
X      IF (I .EQ. 1) GO TO 110
X      I=I-1
X  165 I=I+1
X      IF (I .EQ. J) GO TO 155
X      T=X(I+1)
X      IF (X(I) .LE. T) GO TO 165
X      K=I
X  170 X(K+1)=X(K)
X      K=K-1
X      IF (T .LT. X(K)) GO TO 170
X      X(K+1)=T
X      GO TO 165
XC
XC SORT X AND CARRY Y ALONG
XC
X  200 CONTINUE
X      M=1
X      I=1
X      J=NN
X      R=.375
X  210 IF (I .EQ. J) GO TO 255
X  215 IF (R .GT. .5898437) GO TO 220
X      R=R+3.90625E-2
X      GO TO 225
X  220 R=R-.21875
X  225 K=I
XC                                  SELECT A CENTRAL ELEMENT OF THE
XC                                  ARRAY AND SAVE IT IN LOCATION T
X      IJ = I + IFIX (FLOAT (J-I) *R)
X      T=X(IJ)
X      TY= Y(IJ)
XC                                  IF FIRST ELEMENT OF ARRAY IS GREATER
XC                                  THAN T, INTERCHANGE WITH T
X      IF (X(I) .LE. T) GO TO 230
X      X(IJ)=X(I)
X      X(I)=T
X      T=X(IJ)
X       Y(IJ)= Y(I)
X       Y(I)=TY
X      TY= Y(IJ)
X  230 L=J
XC                                  IF LAST ELEMENT OF ARRAY IS LESS THAN
XC                                  T, INTERCHANGE WITH T
X      IF (X(J) .GE. T) GO TO 240
X      X(IJ)=X(J)
X      X(J)=T
X      T=X(IJ)
X       Y(IJ)= Y(J)
X       Y(J)=TY
X      TY= Y(IJ)
XC                                  IF FIRST ELEMENT OF ARRAY IS GREATER
XC                                  THAN T, INTERCHANGE WITH T
X      IF (X(I) .LE. T) GO TO 240
X      X(IJ)=X(I)
X      X(I)=T
X      T=X(IJ)
X       Y(IJ)= Y(I)
X       Y(I)=TY
X      TY= Y(IJ)
X      GO TO 240
X  235 TT=X(L)
X      X(L)=X(K)
X      X(K)=TT
X      TTY= Y(L)
X       Y(L)= Y(K)
X       Y(K)=TTY
XC                                  FIND AN ELEMENT IN THE SECOND HALF OF
XC                                  THE ARRAY WHICH IS SMALLER THAN T
X  240 L=L-1
X      IF (X(L) .GT. T) GO TO 240
XC                                  FIND AN ELEMENT IN THE FIRST HALF OF
XC                                  THE ARRAY WHICH IS GREATER THAN T
X  245 K=K+1
X      IF (X(K) .LT. T) GO TO 245
XC                                  INTERCHANGE THESE ELEMENTS
X      IF (K .LE. L) GO TO 235
XC                                  SAVE UPPER AND LOWER SUBSCRIPTS OF
XC                                  THE ARRAY YET TO BE SORTED
X      IF (L-I .LE. J-K) GO TO 250
X      IL(M)=I
X      IU(M)=L
X      I=K
X      M=M+1
X      GO TO 260
X  250 IL(M)=K
X      IU(M)=J
X      J=L
X      M=M+1
X      GO TO 260
XC                                  BEGIN AGAIN ON ANOTHER PORTION OF
XC                                  THE UNSORTED ARRAY
X  255 M=M-1
X      IF (M .EQ. 0) GO TO 300
X      I=IL(M)
X      J=IU(M)
X  260 IF (J-I .GE. 1) GO TO 225
X      IF (I .EQ. 1) GO TO 210
X      I=I-1
X  265 I=I+1
X      IF (I .EQ. J) GO TO 255
X      T=X(I+1)
X      TY= Y(I+1)
X      IF (X(I) .LE. T) GO TO 265
X      K=I
X  270 X(K+1)=X(K)
X       Y(K+1)= Y(K)
X      K=K-1
X      IF (T .LT. X(K)) GO TO 270
X      X(K+1)=T
X       Y(K+1)=TY
X      GO TO 265
XC
XC CLEAN UP
XC
X  300 IF (KFLAG.GE.1) RETURN
X      DO 310 I=1,NN
X  310 X(I) = -X(I)
X      RETURN
X      END
X      FUNCTION BVALU(T,A,N,K,IDERIV,X,INBV,WORK)
XC***BEGIN PROLOGUE  BVALU
XC***DATE WRITTEN   800901   (YYMMDD)
XC***REVISION DATE  820801   (YYMMDD)
XC***CATEGORY NO.  E3,K6
XC***KEYWORDS  B-SPLINE,DATA FITTING,INTERPOLATION,SPLINE
XC***AUTHOR  AMOS, D. E., (SNLA)
XC***PURPOSE  EVALUATES THE B-REPRESENTATION OF A B-SPLINE AT X FOR THE
XC            FUNCTION VALUE OR ANY OF ITS DERIVATIVES.
XC***DESCRIPTION
XC
XC     WRITTEN BY CARL DE BOOR AND MODIFIED BY D. E. AMOS
XC
XC     REFERENCE
XC         SIAM J. NUMERICAL ANALYSIS, 14, NO. 3, JUNE, 1977, PP.441-472.
XC
XC     ABSTRACT
XC         BVALU IS THE BVALUE FUNCTION OF THE REFERENCE.
XC
XC         BVALU EVALUATES THE B-REPRESENTATION (T,A,N,K) OF A B-SPLINE
XC         AT X FOR THE FUNCTION VALUE ON IDERIV = 0 OR ANY OF ITS
XC         DERIVATIVES ON IDERIV = 1,2,...,K-1.  RIGHT LIMITING VALUES
XC         (RIGHT DERIVATIVES) ARE RETURNED EXCEPT AT THE RIGHT END
XC         POINT X=T(N+1) WHERE LEFT LIMITING VALUES ARE COMPUTED.  THE
XC         SPLINE IS DEFINED ON T(K) .LE. X .LE. T(N+1).  BVALU RETURNS
XC         A FATAL ERROR MESSAGE WHEN X IS OUTSIDE OF THIS INTERVAL.
XC
XC         TO COMPUTE LEFT DERIVATIVES OR LEFT LIMITING VALUES AT A
XC         KNOT T(I), REPLACE N BY I-1 AND SET X=T(I), I=K+1,N+1.
XC
XC         BVALU CALLS INTRV
XC
XC     DESCRIPTION OF ARGUMENTS
XC         INPUT
XC          T       - KNOT VECTOR OF LENGTH N+K
XC          A       - B-SPLINE COEFFICIENT VECTOR OF LENGTH N
XC          N       - NUMBER OF B-SPLINE COEFFICIENTS
XC                    N = SUM OF KNOT MULTIPLICITIES-K
XC          K       - ORDER OF THE B-SPLINE, K .GE. 1
XC          IDERIV  - ORDER OF THE DERIVATIVE, 0 .LE. IDERIV .LE. K-1
XC                    IDERIV=0 RETURNS THE B-SPLINE VALUE
XC          X       - ARGUMENT, T(K) .LE. X .LE. T(N+1)
XC          INBV    - AN INITIALIZATION PARAMETER WHICH MUST BE SET
XC                    TO 1 THE FIRST TIME BVALU IS CALLED.
XC
XC         OUTPUT
XC          INBV    - INBV CONTAINS INFORMATION FOR EFFICIENT PROCESS-
XC                    ING AFTER THE INITIAL CALL AND INBV MUST NOT
XC                    BE CHANGED BY THE USER.  DISTINCT SPLINES REQUIRE
XC                    DISTINCT INBV PARAMETERS.
XC          WORK    - WORK VECTOR OF LENGTH 3*K.
XC          BVALU   - VALUE OF THE IDERIV-TH DERIVATIVE AT X
XC
XC     ERROR CONDITIONS
XC         AN IMPROPER INPUT IS A FATAL ERROR
XC***REFERENCES  C. DE BOOR, *PACKAGE FOR CALCULATING WITH B-SPLINES*,
XC                 SIAM JOURNAL ON NUMERICAL ANALYSIS, VOLUME 14, NO. 3,
XC                 JUNE 1977, PP. 441-472.
XC***ROUTINES CALLED  INTRV,XERROR
XC***END PROLOGUE  BVALU
XC
XC
X      INTEGER I,IDERIV,IDERP1,IHI,IHMKMJ,ILO,IMK,IMKPJ, INBV, IPJ,
X     1 IP1, IP1MJ, J, JJ, J1, J2, K, KMIDER, KMJ, KM1, KPK, MFLAG, N
X      REAL A, FKMJ, T, WORK, X
XC     DIMENSION T(N+K), WORK(3*K)
X      DIMENSION T(1), A(N), WORK(1)
XC***FIRST EXECUTABLE STATEMENT  BVALU
X      BVALU = 0.0E0
X      IF(K.LT.1) GO TO 102
X      IF(N.LT.K) GO TO 101
X      IF(IDERIV.LT.0 .OR. IDERIV.GE.K) GO TO 110
X      KMIDER = K - IDERIV
XC
XC *** FIND *I* IN (K,N) SUCH THAT T(I) .LE. X .LT. T(I+1)
XC     (OR, .LE. T(I+1) IF T(I) .LT. T(I+1) = T(N+1)).
X      KM1 = K - 1
X      CALL INTRV(T, N+1, X, INBV, I, MFLAG)
X      IF (X.LT.T(K)) GO TO 120
X      IF (MFLAG.EQ.0) GO TO 20
X      IF (X.GT.T(I)) GO TO 130
X   10 IF (I.EQ.K) GO TO 140
X      I = I - 1
X      IF (X.EQ.T(I)) GO TO 10
XC
XC *** DIFFERENCE THE COEFFICIENTS *IDERIV* TIMES
XC     WORK(I) = AJ(I), WORK(K+I) = DP(I), WORK(K+K+I) = DM(I), I=1.K
XC
X   20 IMK = I - K
X      DO 30 J=1,K
X        IMKPJ = IMK + J
X        WORK(J) = A(IMKPJ)
X   30 CONTINUE
X      IF (IDERIV.EQ.0) GO TO 60
X      DO 50 J=1,IDERIV
X        KMJ = K - J
X        FKMJ = FLOAT(KMJ)
X        DO 40 JJ=1,KMJ
X          IHI = I + JJ
X          IHMKMJ = IHI - KMJ
X          WORK(JJ) = (WORK(JJ+1)-WORK(JJ))/(T(IHI)-T(IHMKMJ))*FKMJ
X   40   CONTINUE
X   50 CONTINUE
XC
XC *** COMPUTE VALUE AT *X* IN (T(I),(T(I+1)) OF IDERIV-TH DERIVATIVE,
XC     GIVEN ITS RELEVANT B-SPLINE COEFF. IN AJ(1),...,AJ(K-IDERIV).
X   60 IF (IDERIV.EQ.KM1) GO TO 100
X      IP1 = I + 1
X      KPK = K + K
X      J1 = K + 1
X      J2 = KPK + 1
X      DO 70 J=1,KMIDER
X        IPJ = I + J
X        WORK(J1) = T(IPJ) - X
X        IP1MJ = IP1 - J
X        WORK(J2) = X - T(IP1MJ)
X        J1 = J1 + 1
X        J2 = J2 + 1
X   70 CONTINUE
X      IDERP1 = IDERIV + 1
X      DO 90 J=IDERP1,KM1
X        KMJ = K - J
X        ILO = KMJ
X        DO 80 JJ=1,KMJ
X          WORK(JJ) = (WORK(JJ+1)*WORK(KPK+ILO)+WORK(JJ)
X     1              *WORK(K+JJ))/(WORK(KPK+ILO)+WORK(K+JJ))
X          ILO = ILO - 1
X   80   CONTINUE
X   90 CONTINUE
X  100 BVALU = WORK(1)
X      RETURN
XC
XC
X  101 CONTINUE
X      CALL XERROR( ' BVALU,  N DOES NOT SATISFY N.GE.K',34,2,1)
X      RETURN
X  102 CONTINUE
X      CALL XERROR( ' BVALU,  K DOES NOT SATISFY K.GE.1',34,2,1)
X      RETURN
X  110 CONTINUE
X      CALL XERROR( ' BVALU,  IDERIV DOES NOT SATISFY 0.LE.IDERIV.LT.K',
X     1 49, 2, 1)
X      RETURN
X  120 CONTINUE
X      CALL XERROR( ' BVALU,  X IS N0T GREATER THAN OR EQUAL TO T(K)',
X     1 47, 2, 1)
X      RETURN
X  130 CONTINUE
X      CALL XERROR( ' BVALU,  X IS NOT LESS THAN OR EQUAL TO T(N+1)',
X     1 46, 2, 1)
X      RETURN
X  140 CONTINUE
X      CALL XERROR( ' BVALU,  A LEFT LIMITING VALUE CANN0T BE OBTAINED AT
X     1 T(K)',     57, 2, 1)
X      RETURN
X      END
X      SUBROUTINE INTRV(XT,LXT,X,ILO,ILEFT,MFLAG)
XC***BEGIN PROLOGUE  INTRV
XC***DATE WRITTEN   800901   (YYMMDD)
XC***REVISION DATE  820801   (YYMMDD)
XC***CATEGORY NO.  E3,K6
XC***KEYWORDS  B-SPLINE,DATA FITTING,INTERPOLATION,SPLINE
XC***AUTHOR  AMOS, D. E., (SNLA)
XC***PURPOSE  COMPUTES THE LARGEST INTEGER ILEFT IN 1.LE.ILEFT.LE.LXT
XC            SUCH THAT XT(ILEFT).LE.X WHERE XT(*) IS A SUBDIVISION
XC            OF THE X INTERVAL.
XC***DESCRIPTION
XC
XC     WRITTEN BY CARL DE BOOR AND MODIFIED BY D. E. AMOS
XC
XC     REFERENCE
XC         SIAM J. NUMERICAL ANALYSIS, 14, NO. 3, JUNE 1977, PP. 441-472.
XC
XC     ABSTRACT
XC         INTRV IS THE INTERV ROUTINE OF THE REFERENCE.
XC
XC         INTRV COMPUTES THE LARGEST INTEGER ILEFT IN 1 .LE. ILEFT .LE.
XC         LXT SUCH THAT XT(ILEFT) .LE. X WHERE XT(*) IS A SUBDIVISION OF
XC         THE X INTERVAL.  PRECISELY,
XC
XC                      X .LT. XT(1)                1         -1
XC         IF  XT(I) .LE. X .LT. XT(I+1)  THEN  ILEFT=I  , MFLAG=0
XC           XT(LXT) .LE. X                         LXT        1,
XC
XC         THAT IS, WHEN MULTIPLICITIES ARE PRESENT IN THE BREAK POINT
XC         TO THE LEFT OF X, THE LARGEST INDEX IS TAKEN FOR ILEFT.
XC
XC     DESCRIPTION OF ARGUMENTS
XC         INPUT
XC          XT      - XT IS A KNOT OR BREAK POINT VECTOR OF LENGTH LXT
XC          LXT     - LENGTH OF THE XT VECTOR
XC          X       - ARGUMENT
XC          ILO     - AN INITIALIZATION PARAMETER WHICH MUST BE SET
XC                    TO 1 THE FIRST TIME THE SPLINE ARRAY XT IS
XC                    PROCESSED BY INTRV.
XC
XC         OUTPUT
XC          ILO     - ILO CONTAINS INFORMATION FOR EFFICIENT PROCESS-
XC                    ING AFTER THE INITIAL CALL, AND ILO MUST NOT BE
XC                    CHANGED BY THE USER.  DISTINCT SPLINES REQUIRE
XC                    DISTINCT ILO PARAMETERS.
XC          ILEFT   - LARGEST INTEGER SATISFYING XT(ILEFT) .LE. X
XC          MFLAG   - SIGNALS WHEN X LIES OUT OF BOUNDS
XC
XC     ERROR CONDITIONS
XC         NONE
XC***REFERENCES  C. DE BOOR, *PACKAGE FOR CALCULATING WITH B-SPLINES*,
XC                 SIAM JOURNAL ON NUMERICAL ANALYSIS, VOLUME 14, NO. 3,
XC                 JUNE 1977, PP. 441-472.
XC***ROUTINES CALLED  (NONE)
XC***END PROLOGUE  INTRV
XC
XC
X      INTEGER IHI, ILEFT, ILO, ISTEP, LXT, MFLAG, MIDDLE
X      REAL X, XT
X      DIMENSION XT(LXT)
XC***FIRST EXECUTABLE STATEMENT  INTRV
X      IHI = ILO + 1
X      IF (IHI.LT.LXT) GO TO 10
X      IF (X.GE.XT(LXT)) GO TO 110
X      IF (LXT.LE.1) GO TO 90
X      ILO = LXT - 1
X      IHI = LXT
XC
X   10 IF (X.GE.XT(IHI)) GO TO 40
X      IF (X.GE.XT(ILO)) GO TO 100
XC
XC *** NOW X .LT. XT(IHI) . FIND LOWER BOUND
X      ISTEP = 1
X   20 IHI = ILO
X      ILO = IHI - ISTEP
X      IF (ILO.LE.1) GO TO 30
X      IF (X.GE.XT(ILO)) GO TO 70
X      ISTEP = ISTEP*2
X      GO TO 20
X   30 ILO = 1
X      IF (X.LT.XT(1)) GO TO 90
X      GO TO 70
XC *** NOW X .GE. XT(ILO) . FIND UPPER BOUND
X   40 ISTEP = 1
X   50 ILO = IHI
X      IHI = ILO + ISTEP
X      IF (IHI.GE.LXT) GO TO 60
X      IF (X.LT.XT(IHI)) GO TO 70
X      ISTEP = ISTEP*2
X      GO TO 50
X   60 IF (X.GE.XT(LXT)) GO TO 110
X      IHI = LXT
XC
XC *** NOW XT(ILO) .LE. X .LT. XT(IHI) . NARROW THE INTERVAL
X   70 MIDDLE = (ILO+IHI)/2
X      IF (MIDDLE.EQ.ILO) GO TO 100
XC     NOTE. IT IS ASSUMED THAT MIDDLE = ILO IN CASE IHI = ILO+1
X      IF (X.LT.XT(MIDDLE)) GO TO 80
X      ILO = MIDDLE
X      GO TO 70
X   80 IHI = MIDDLE
X      GO TO 70
XC *** SET OUTPUT AND RETURN
X   90 MFLAG = -1
X      ILEFT = 1
X      RETURN
X  100 MFLAG = 0
X      ILEFT = ILO
X      RETURN
X  110 MFLAG = 1
X      ILEFT = LXT
X      RETURN
X      END
X      SUBROUTINE XERROR(MESSG,NMESSG,NERR,LEVEL)
XC***BEGIN PROLOGUE  XERROR
XC***DATE WRITTEN   790801   (YYMMDD)
XC***REVISION DATE  870930   (YYMMDD)
XC***CATEGORY NO.  R3C
XC***KEYWORDS  ERROR,XERROR PACKAGE
XC***AUTHOR  JONES, R. E., (SNLA)
XC***PURPOSE  Processes an error (diagnostic) message.
XC***DESCRIPTION
XC    From the book "Numerical Methods and Software"
XC       by  D. Kahaner, C. Moler, S. Nash
XC           Prentice Hall 1988
XC     Abstract
XC        XERROR processes a diagnostic message. It is a stub routine
XC        written for the book above. Actually, XERROR is a sophisticated
XC        error handling package with many options, and is described
XC        in the reference below. Our version has the same calling sequence
XC        but only prints an error message and either returns (if the
XC        input value of ABS(LEVEL) is less than 2) or stops (if the
XC        input value of ABS(LEVEL) equals 2).
XC
XC     Description of Parameters
XC      --Input--
XC        MESSG - the Hollerith message to be processed.
XC        NMESSG- the actual number of characters in MESSG.
XC                (this is ignored in this stub routine)
XC        NERR  - the error number associated with this message.
XC                NERR must not be zero.
XC                (this is ignored in this stub routine)
XC        LEVEL - error category.
XC                =2 means this is an unconditionally fatal error.
XC                =1 means this is a recoverable error.  (I.e., it is
XC                   non-fatal if XSETF has been appropriately called.)
XC                =0 means this is a warning message only.
XC                =-1 means this is a warning message which is to be
XC                   printed at most once, regardless of how many
XC                   times this call is executed.
XC                 (in this stub routine
XC                       LEVEL=2 causes a message to be printed and then a
XC                                         stop.
XC                       LEVEL<2 causes a message to be printed and then a
XC                                         return.
XC
XC     Examples
XC        CALL XERROR('SMOOTH -- NUM WAS ZERO.',23,1,2)
XC        CALL XERROR('INTEG  -- LESS THAN FULL ACCURACY ACHIEVED.',
XC                    43,2,1)
XC        CALL XERROR('ROOTER -- ACTUAL ZERO OF F FOUND BEFORE INTERVAL F
XC    1ULLY COLLAPSED.',65,3,0)
XC        CALL XERROR('EXP    -- UNDERFLOWS BEING SET TO ZERO.',39,1,-1)
XC
XC***REFERENCES  JONES R.E., KAHANER D.K., "XERROR, THE SLATEC ERROR-
XC                 HANDLING PACKAGE", SAND82-0800, SANDIA LABORATORIES,
XC                 1982.
XC***ROUTINES CALLED  XERRWV
XC***END PROLOGUE  XERROR
X      CHARACTER*(*) MESSG
XC***FIRST EXECUTABLE STATEMENT  XERROR
X      CALL XERRWV(MESSG,NMESSG,NERR,LEVEL,0,0,0,0,0.,0.)
X      RETURN
X      END
X      SUBROUTINE XERRWV(MESSG,NMESSG,NERR,LEVEL,NI,I1,I2,NR,R1,R2)
XC***BEGIN PROLOGUE  XERRWV
XC***DATE WRITTEN   800319   (YYMMDD)
XC***REVISION DATE  870930   (YYMMDD)
XC***CATEGORY NO.  R3C
XC***KEYWORDS  ERROR,XERROR PACKAGE
XC***AUTHOR  JONES, R. E., (SNLA)
XC***PURPOSE  Processes error message allowing 2 integer and two real
XC            values to be included in the message.
XC***DESCRIPTION
XC    From the book "Numerical Methods and Software"
XC       by  D. Kahaner, C. Moler, S. Nash
XC           Prentice Hall 1988
XC     Abstract
XC        XERRWV prints a diagnostic error message.
XC        In addition, up to two integer values and two real
XC        values may be printed along with the message.
XC        A stub routine for the book above. The actual XERRWV is described
XC        in the reference below and contains many other options.
XC
XC     Description of Parameters
XC      --Input--
XC        MESSG - the Hollerith message to be processed.
XC        NMESSG- the actual number of characters in MESSG.
XC                (ignored in this stub)
XC        NERR  - the error number associated with this message.
XC                NERR must not be zero.
XC                (ignored in this stub)
XC        LEVEL - error category.
XC                =2 means this is an unconditionally fatal error.
XC                =1 means this is a recoverable error.  (I.e., it is
XC                   non-fatal if XSETF has been appropriately called.)
XC                =0 means this is a warning message only.
XC                =-1 means this is a warning message which is to be
XC                   printed at most once, regardless of how many
XC                   times this call is executed.
XC                  (in this stub LEVEL=2 causes an error message to be
XC                                          printed followed by a stop,
XC                                LEVEL<2 causes an error message to be
XC                                          printed followed by a return.)
XC        NI    - number of integer values to be printed. (0 to 2)
XC        I1    - first integer value.
XC        I2    - second integer value.
XC        NR    - number of real values to be printed. (0 to 2)
XC        R1    - first real value.
XC        R2    - second real value.
XC
XC     Examples
XC        CALL XERRWV('SMOOTH -- NUM (=I1) WAS ZERO.',29,1,2,
XC    1   1,NUM,0,0,0.,0.)
XC        CALL XERRWV('QUADXY -- REQUESTED ERROR (R1) LESS THAN MINIMUM (
XC    1R2).,54,77,1,0,0,0,2,ERRREQ,ERRMIN)
XC
XC***REFERENCES  JONES R.E., KAHANER D.K., "XERROR, THE SLATEC ERROR-
XC                 HANDLING PACKAGE", SAND82-0800, SANDIA LABORATORIES,
XC                 1982.
XC***ROUTINES CALLED  (NONE)
XC***END PROLOGUE  XERRWV
X      CHARACTER*(*) MESSG
XC***FIRST EXECUTABLE STATEMENT  XERRWV
X      WRITE(*,*) MESSG
X      IF(NI.EQ.2)THEN
X        WRITE(*,*) I1,I2
X      ELSEIF(NI.EQ.1) THEN
X        WRITE(*,*) I1
X      ENDIF
X      IF(NR.EQ.2) THEN
X        WRITE(*,*) R1,R2
X      ELSEIF(NR.EQ.1) THEN
X        WRITE(*,*) R1
X      ENDIF
X      IF(ABS(LEVEL).LT.2)RETURN
X      STOP
X      END
END_OF_FILE
if test 77688 -ne `wc -c <'efc.f'`; then
    echo shar: \"'efc.f'\" unpacked with wrong size!
fi
# end of 'efc.f'
fi
if test -f 'initpt.f' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'initpt.f'\"
else
echo shar: Extracting \"'initpt.f'\" \(4249 characters\)
sed "s/^X//" >'initpt.f' <<'END_OF_FILE'
X      SUBROUTINE INITPT(ERROR,TOP,N,Y,DERIV2,MAXTAN,NTAN,INDEX)
XC
XC --- THIS SUBROUTINE CALCULATES INITIAL ESTIMATES FOR POINTS ON THE
XC     DATA CURVE WHICH SHOULD BE TANGENT TO THE TOP OR BOTTOM ENVELOPE 
XC     CURVE.  THE METHOD USED IS TO FIND INTERVALS WHERE THE DATA CURVE 
XC     IS CONCAVE (FOR THE TOP ENVELOPE) OR CONVEX (FOR THE BOTTOM 
XC     ENVELOPE).  THE TANGENT ESTIMATES ARE SET AT THE MIDPOINTS OF 
XC     THESE INTERVALS.  CONCAVE (CONVEX) INTERVALS CONTAINING THE FIRST 
XC     OR LAST DATA POINT ARE USED ONLY IF THEY ALSO CONTAIN A LOCAL 
XC     MAXIMUM (MINIMUM), SINCE OTHERWISE THE DATA FOR THESE INTERVALS 
XC     MAY BE INCOMPLETE.
XC
XC --- INPUT VARIABLES
XC     TOP:         FLAG INDICATING WHETHER TANGENTS FOR THE TOP OR THE
XC                  BOTTOM ENVELOPE ARE TO BE COMPUTED
XC     N:           NUMBER OF DATA POINTS
XC     Y(N):        ARRAY CONTAINING Y COORDINATES OF DATA POINTS
XC     DERIV2(N):   ARRAY CONTAINING SECOND DERIVATIVES OF DATA POINTS
XC     MAXTAN:      MAXIMUM NUMBER OF TANGENT POINTS ALLOWED
XC
XC --- OUTPUT VARIABLES
XC     ERROR:       ERROR FLAG
XC     NTAN:        NUMBER OF ESTIMATED TANGENT POINTS ON ENVELOPE
XC     INDEX(NTAN): ARRAY CONTAINING INDEXES OF ESTIMATED TANGENT POINTS
XC                  ((X(INDEX(I)),Y(INDEX(I))) IS THE ITH ESTIMATED
XC                  TANGENT POINT.)
XC
XC --- DECLARATION OF CALLING SEQUENCE VARIABLES
X      LOGICAL ERROR,TOP
X      INTEGER N,MAXTAN,NTAN,INDEX(*)
X      REAL Y(*),DERIV2(*)
XC
XC --- DECLARATION OF INTERNAL VARIABLES
X      INTEGER I,J,K,LAST
XC
XC --- IF BOTTOM ENVELOPE IS TO BE COMPUTED, NEGATE Y VALUES AND SECOND
XC --- DERIVATIVES
X      IF(.NOT.TOP)THEN
X         DO 20 I=1,N
X            Y(I)=-Y(I)
X            DERIV2(I)=-DERIV2(I)
X   20    CONTINUE
X      ENDIF
XC
XC --- LOOP TO FIND INITIAL ESTIMATES OF TANGENT POINTS
X      ERROR=.FALSE.
X      NTAN=0
X      LAST=0
X      DO 200 I=1,N
X         IF(I.LE.LAST)GOTO 200
X         IF(DERIV2(I).LE.0.)THEN
X            DO 100 J=I+1,N
X               IF(DERIV2(J).GT.0..OR.J.EQ.N)THEN
X                  LAST=J
X                  IF(I.EQ.1)THEN
X                     DO 50 K=2,J-1
X                        IF(Y(K).GT.Y(K-1).AND.Y(K).GT.Y(K+1))THEN
X                           NTAN=NTAN+1
X                           IF(NTAN.GT.MAXTAN)THEN
X                              ERROR=.TRUE.
X                              PRINT *,'ERROR in subroutine INITPT: ',
X     +                                'Too many tangent points --'
X                              PRINT *,'Increase MAXTAN.'
X                              RETURN
X                           ENDIF
X                           INDEX(NTAN)=K
X                        ENDIF
X   50                CONTINUE
X                  ELSEIF(I.GT.1)THEN
X                     IF(J.LT.N)THEN
X                        NTAN=NTAN+1
X                        IF(NTAN.GT.MAXTAN)THEN
X                           ERROR=.TRUE.
X                           PRINT *,'ERROR in subroutine INITPT: ',
X     +                             'Too many tangent points --'
X                           PRINT *,'Increase MAXTAN.'
X                           RETURN
X                        ENDIF
X                        INDEX(NTAN)=(I+J-1)/2
X                     ELSE
X                        DO 80 K=I,J-1
X                           IF(Y(K).GT.Y(K-1).AND.Y(K).GT.Y(K+1))THEN
X                              NTAN=NTAN+1
X                              IF(NTAN.GT.MAXTAN)THEN
X                                 ERROR=.TRUE.
X                                 PRINT *,'ERROR in subroutine INITPT: ',
X     +                                   'Too many tangent points --'
X                                 PRINT *,'Increase MAXTAN.'
X                                 RETURN
X                              ENDIF
X                              INDEX(NTAN)=K
X                           ENDIF
X   80                   CONTINUE
X                     ENDIF
X                  ENDIF
X                  GOTO 200
X               ENDIF
X  100       CONTINUE
X         ENDIF
X  200 CONTINUE
XC
XC --- IF BOTTOM ENVELOPE HAS BEEN COMPUTED, SET Y VALUES AND SECOND
XC --- DERIVATIVES BACK TO ORIGINAL VALUES
X      IF(.NOT.TOP)THEN
X         DO 300 I=1,N
X            Y(I)=-Y(I)
X            DERIV2(I)=-DERIV2(I)
X  300    CONTINUE
X      ENDIF
XC
X      RETURN
X      END
END_OF_FILE
if test 4249 -ne `wc -c <'initpt.f'`; then
    echo shar: \"'initpt.f'\" unpacked with wrong size!
fi
# end of 'initpt.f'
fi
if test -f 'env.f' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'env.f'\"
else
echo shar: Extracting \"'env.f'\" \(4669 characters\)
sed "s/^X//" >'env.f' <<'END_OF_FILE'
X      SUBROUTINE ENV(ERROR,TOP,N,X,Y,DERIV2,NENV,XENV,YENV,NTAN,XTAN,
X     +               YTAN,D,WK)
XC
XC --- This subroutine calculates the top or bottom envelope of a given 
XC     set of data points.
XC
XC --- Written by M. McClain, January 1989.
XC     Latest revision, October 1992.
XC
XC --- Description of Input Variables
XC     TOP:        Flag indicating whether top or bottom envelope is to
XC                 be computed
XC     N:          Number of data points
XC     X(N):       Array containing x coordinates of data points
XC     Y(N):       Array containing y coordinates of data points
XC     DERIV2(N):  Array containing second derivatives of data points
XC     NTAN:       Number of tangent points where envelope touches data 
XC                 curve
XC     XTAN(NTAN): Array containing x coordinates of initial estimate
XC                 of tangent points
XC     YTAN(NTAN): Array containing y coordinates of initial estimate
XC                 of tangent points
XC
XC --- Description of Output Variables
XC     ERROR:      Error flag
XC     NENV:       Number of points in envelope curve
XC     XENV(NENV): Array containing x coordinates of envelope
XC     YENV(NENV): Array containing y coordinates of envelope
XC     XTAN(NTAN): Array containing x coordinates of tangent points
XC     YTAN(NTAN): Array containing y coordinates of tangent points
XC     D(N):       Work array
XC     WK(2*NTAN): Work array
XC
XC --- Declaration of Calling Sequence Variables
X      LOGICAL TOP,ERROR
X      INTEGER N,NTAN,NENV,IERR,LAST
X      REAL X(*),Y(*),DERIV2(*),XENV(*),YENV(*),XTAN(*),YTAN(*),D(*),
X     +     WK(*)
XC
XC --- Declaration of Internal Variables
X      LOGICAL SKIP
X      INTEGER I,J,COUNT,INTERV,BEGIN,END,NWK,IC(2)
X      REAL SWITCH,VC(2)
XC
XC --- If bottom envelope is to be computed, negate y values, second
XC     derivatives, and tangent values.
X      IF(.NOT.TOP)THEN
X         DO 100 I=1,N
X            Y(I)=-Y(I)
X            DERIV2(I)=-DERIV2(I)
X  100    CONTINUE
X         DO 150 I=1,NTAN
X            YTAN(I)=-YTAN(I)
X  150    CONTINUE
X      ENDIF
XC
XC --- Initialize error flag and iteration counter.
X      ERROR=.FALSE.
X      COUNT=0
XC
X  200 CONTINUE
XC --- Interpolate a monotone function through the estimated tangent 
XC     points.
X      COUNT=COUNT+1
X      IC(1)=0
X      IC(2)=0
X      SWITCH=-1.
X      NWK=2*(NTAN-1)
X      CALL PCHIC(IC,VC,SWITCH,NTAN,XTAN,YTAN,D,1,WK,NWK,IERR)
X      IF(IERR.LT.0)THEN
X         ERROR=.TRUE.
X         PRINT *,'ERROR in subroutine ENV -- IERR = ',IERR,
X     +           ' on return from PCHIC.'
X         RETURN
X      ENDIF
X      SKIP=.FALSE.
X      CALL PCHFE(NTAN,XTAN,YTAN,D,1,SKIP,N,X,YENV,IERR)
X      IF(IERR.LT.0)THEN
X         ERROR=.TRUE.
X         PRINT *,'ERROR in subroutine ENV -- IERR = ',IERR,
X     +           ' on return from PCHFE.'
X         RETURN
X      ENDIF
XC
XC --- Check for data points that lie above the envelope.  (Also check 
XC     that the data curve is concave at these points.)
X      INTERV=0
X      LAST=0
X      DO 500 I=2,N-1
X         IF(I.LE.LAST)GOTO 500
X         IF(Y(I).GT.YENV(I).AND.DERIV2(I).LE.0.)THEN
X            DO 300 J=I+1,N
X               IF(Y(J).LE.YENV(J).OR.DERIV2(J).GT.0.)THEN
X                  LAST=J
X                  GOTO 400
X               ENDIF
X  300       CONTINUE
X            LAST=N
X  400       CONTINUE
X            DO 450 J=1,NTAN
X               IF(XTAN(J).GE.X(I-1).AND.XTAN(J).LE.X(LAST))THEN
X                  XTAN(J)=X((I+LAST-1)/2)
X                  YTAN(J)=Y((I+LAST-1)/2)
X               ENDIF
X  450       CONTINUE
X            INTERV=INTERV+1
X         ENDIF
X  500 CONTINUE
XC
XC --- Stop if no data points are above the envelope, otherwise try again
XC     with new tangent point estimates.
X      IF(INTERV.GT.0.AND.COUNT.LT.20)GOTO 200
XC     WRITE(*,520)COUNT
XC 520 FORMAT(4X,I2,' iterations.')
XC
XC --- If bottom envelope has been computed, set y values and second
XC     derivatives back to their original values and negate envelope 
XC     and tangent values.
X      IF(.NOT.TOP)THEN
X         DO 550 I=1,N
X            Y(I)=-Y(I)
X            DERIV2(I)=-DERIV2(I)
X            YENV(I)=-YENV(I)
X  550    CONTINUE
X         DO 580 I=1,NTAN
X            YTAN(I)=-YTAN(I)
X  580    CONTINUE
X      ENDIF
XC
XC --- Eliminate extrapolation points.
X      DO 600 I=1,N
X         IF(X(I).GE.XTAN(1))THEN
X            BEGIN=I
X            GOTO 700
X         ENDIF
X  600 CONTINUE
X  700 CONTINUE
X      DO 800 I=BEGIN,N
X         IF(X(I).GT.XTAN(NTAN))THEN
X            END=I-1
X            GOTO 900
X         ENDIF
X  800 CONTINUE
X      END=NTAN
X  900 CONTINUE
X      NENV=END-BEGIN+1
X      DO 1000 I=1,NENV
X         XENV(I)=X(BEGIN+I-1)
X         YENV(I)=YENV(BEGIN+I-1)
X 1000 CONTINUE
XC
X      RETURN
X      END
END_OF_FILE
if test 4669 -ne `wc -c <'env.f'`; then
    echo shar: \"'env.f'\" unpacked with wrong size!
fi
# end of 'env.f'
fi
if test -f 'pchic.f' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'pchic.f'\"
else
echo shar: Extracting \"'pchic.f'\" \(47249 characters\)
sed "s/^X//" >'pchic.f' <<'END_OF_FILE'
X      SUBROUTINE PCHIC(IC,VC,SWITCH,N,X,F,D,INCFD,WK,NWK,IERR)
XC***BEGIN PROLOGUE  PCHIC
XC***DATE WRITTEN   820218   (YYMMDD)
XC***REVISION DATE  870707   (YYMMDD)
XC***CATEGORY NO.  E1B
XC***KEYWORDS  LIBRARY=SLATEC(PCHIP),
XC             TYPE=SINGLE PRECISION(PCHIC-S DPCHIC-D),
XC             CUBIC HERMITE INTERPOLATION,MONOTONE INTERPOLATION,
XC             PIECEWISE CUBIC INTERPOLATION,
XC             SHAPE-PRESERVING INTERPOLATION
XC***AUTHOR  FRITSCH, F. N., (LLNL)
XC             MATHEMATICS AND STATISTICS DIVISION
XC             LAWRENCE LIVERMORE NATIONAL LABORATORY
XC             P.O. BOX 808  (L-316)
XC             LIVERMORE, CA  94550
XC             FTS 532-4275, (415) 422-4275
XC***PURPOSE  Set derivatives needed to determine a piecewise monotone
XC            piecewise cubic Hermite interpolant to given data.
XC            User control is available over boundary conditions and/or
XC            treatment of points where monotonicity switches direction.
XC***DESCRIPTION
XC
XC         PCHIC:  Piecewise Cubic Hermite Interpolation Coefficients.
XC
XC     Sets derivatives needed to determine a piecewise monotone piece-
XC     wise cubic interpolant to the data given in X and F satisfying the
XC     boundary conditions specified by IC and VC.
XC
XC     The treatment of points where monotonicity switches direction is
XC     controlled by argument SWITCH.
XC
XC     To facilitate two-dimensional applications, includes an increment
XC     between successive values of the F- and D-arrays.
XC
XC     The resulting piecewise cubic Hermite function may be evaluated
XC     by PCHFE or PCHFD.
XC
XC ----------------------------------------------------------------------
XC
XC  Calling sequence:
XC
XC        PARAMETER  (INCFD = ...)
XC        INTEGER  IC(2), N, NWK, IERR
XC        REAL  VC(2), SWITCH, X(N), F(INCFD,N), D(INCFD,N), WK(NWK)
XC
XC        CALL  PCHIC (IC, VC, SWITCH, N, X, F, D, INCFD, WK, NWK, IERR)
XC
XC   Parameters:
XC
XC     IC -- (input) integer array of length 2 specifying desired
XC           boundary conditions:
XC           IC(1) = IBEG, desired condition at beginning of data.
XC           IC(2) = IEND, desired condition at end of data.
XC
XC           IBEG = 0  for the default boundary condition (the same as
XC                     used by PCHIM).
XC           If IBEG.NE.0, then its sign indicates whether the boundary
XC                     derivative is to be adjusted, if necessary, to be
XC                     compatible with monotonicity:
XC              IBEG.GT.0  if no adjustment is to be performed.
XC              IBEG.LT.0  if the derivative is to be adjusted for
XC                     monotonicity.
XC
XC           Allowable values for the magnitude of IBEG are:
XC           IBEG = 1  if first derivative at X(1) is given in VC(1).
XC           IBEG = 2  if second derivative at X(1) is given in VC(1).
XC           IBEG = 3  to use the 3-point difference formula for D(1).
XC                     (Reverts to the default b.c. if N.LT.3 .)
XC           IBEG = 4  to use the 4-point difference formula for D(1).
XC                     (Reverts to the default b.c. if N.LT.4 .)
XC           IBEG = 5  to set D(1) so that the second derivative is con-
XC              tinuous at X(2). (Reverts to the default b.c. if N.LT.4.)
XC              This option is somewhat analogous to the "not a knot"
XC              boundary condition provided by PCHSP.
XC
XC          NOTES (IBEG):
XC           1. An error return is taken if ABS(IBEG).GT.5 .
XC           2. Only in case  IBEG.LE.0  is it guaranteed that the
XC              interpolant will be monotonic in the first interval.
XC              If the returned value of D(1) lies between zero and
XC              3*SLOPE(1), the interpolant will be monotonic.  This
XC              is **NOT** checked if IBEG.GT.0 .
XC           3. If IBEG.LT.0 and D(1) had to be changed to achieve mono-
XC              tonicity, a warning error is returned.
XC
XC           IEND may take on the same values as IBEG, but applied to
XC           derivative at X(N).  In case IEND = 1 or 2, the value is
XC           given in VC(2).
XC
XC          NOTES (IEND):
XC           1. An error return is taken if ABS(IEND).GT.5 .
XC           2. Only in case  IEND.LE.0  is it guaranteed that the
XC              interpolant will be monotonic in the last interval.
XC              If the returned value of D(1+(N-1)*INCFD) lies between
XC              zero and 3*SLOPE(N-1), the interpolant will be monotonic.
XC              This is **NOT** checked if IEND.GT.0 .
XC           3. If IEND.LT.0 and D(1+(N-1)*INCFD) had to be changed to
XC              achieve monotonicity, a warning error is returned.
XC
XC     VC -- (input) real array of length 2 specifying desired boundary
XC           values, as indicated above.
XC           VC(1) need be set only if IC(1) = 1 or 2 .
XC           VC(2) need be set only if IC(2) = 1 or 2 .
XC
XC     SWITCH -- (input) indicates desired treatment of points where
XC           direction of monotonicity switches:
XC           Set SWITCH to zero if interpolant is required to be mono-
XC           tonic in each interval, regardless of monotonicity of data.
XC             NOTES:
XC              1. This will cause D to be set to zero at all switch
XC                 points, thus forcing extrema there.
XC              2. The result of using this option with the default boun-
XC                 dary conditions will be identical to using PCHIM, but
XC                 will generally cost more compute time.
XC                 This option is provided only to facilitate comparison
XC                 of different switch and/or boundary conditions.
XC           Set SWITCH nonzero to use a formula based on the 3-point
XC              difference formula in the vicinity of switch points.
XC           If SWITCH is positive, the interpolant on each interval
XC              containing an extremum is controlled to not deviate from
XC              the data by more than SWITCH*DFLOC, where DFLOC is the
XC              maximum of the change of F on this interval and its two
XC              immediate neighbors.
XC           If SWITCH is negative, no such control is to be imposed.
XC
XC     N -- (input) number of data points.  (Error return if N.LT.2 .)
XC
XC     X -- (input) real array of independent variable values.  The
XC           elements of X must be strictly increasing:
XC                X(I-1) .LT. X(I),  I = 2(1)N.
XC           (Error return if not.)
XC
XC     F -- (input) real array of dependent variable values to be inter-
XC           polated.  F(1+(I-1)*INCFD) is value corresponding to X(I).
XC
XC     D -- (output) real array of derivative values at the data points.
XC           These values will determine a monotone cubic Hermite func-
XC           tion on each subinterval on which the data are monotonic,
XC           except possibly adjacent to switches in monotonicity.
XC           The value corresponding to X(I) is stored in
XC                D(1+(I-1)*INCFD),  I=1(1)N.
XC           No other entries in D are changed.
XC
XC     INCFD -- (input) increment between successive values in F and D.
XC           This argument is provided primarily for 2-D applications.
XC           (Error return if  INCFD.LT.1 .)
XC
XC     WK -- (scratch) real array of working storage.  The user may wish
XC           to know that the returned values are:
XC              WK(I)     = H(I)     = X(I+1) - X(I) ;
XC              WK(N-1+I) = SLOPE(I) = (F(1,I+1) - F(1,I)) / H(I)
XC           for  I = 1(1)N-1.
XC
XC     NWK -- (input) length of work array.
XC           (Error return if  NWK.LT.2*(N-1) .)
XC
XC     IERR -- (output) error flag.
XC           Normal return:
XC              IERR = 0  (no errors).
XC           Warning errors:
XC              IERR = 1  if IBEG.LT.0 and D(1) had to be adjusted for
XC                        monotonicity.
XC              IERR = 2  if IEND.LT.0 and D(1+(N-1)*INCFD) had to be
XC                        adjusted for monotonicity.
XC              IERR = 3  if both of the above are true.
XC           "Recoverable" errors:
XC              IERR = -1  if N.LT.2 .
XC              IERR = -2  if INCFD.LT.1 .
XC              IERR = -3  if the X-array is not strictly increasing.
XC              IERR = -4  if ABS(IBEG).GT.5 .
XC              IERR = -5  if ABS(IEND).GT.5 .
XC              IERR = -6  if both of the above are true.
XC              IERR = -7  if NWK.LT.2*(N-1) .
XC             (The D-array has not been changed in any of these cases.)
XC               NOTE:  The above errors are checked in the order listed,
XC                   and following arguments have **NOT** been validated.
XC
XC***REFERENCES  1. F.N.FRITSCH AND R.E.CARLSON, 'MONOTONE PIECEWISE
XC                 CUBIC INTERPOLATION,' SIAM J.NUMER.ANAL. 17, 2 (APRIL
XC                 1980), 238-246.
XC               2. F.N.FRITSCH AND J.BUTLAND, 'A METHOD FOR CONSTRUCTING
XC                 LOCAL MONOTONE PIECEWISE CUBIC INTERPOLANTS,' SIAM
XC                 J.SCI.STAT.COMPUT.5,2 (JUNE 1984), 300-304.
XC               3. F.N.FRITSCH, 'PIECEWISE CUBIC INTERPOLATION PACKAGE,'
XC                 LLNL PREPRINT UCRL-87285 (JULY 1982).
XC***ROUTINES CALLED  PCHCE,PCHCI,PCHCS,XERROR
XC***END PROLOGUE  PCHIC
XC
XC ----------------------------------------------------------------------
XC
XC  Change record:
XC     82-08-04   Converted to SLATEC library version.
XC
XC ----------------------------------------------------------------------
XC
XC  Programming notes:
XC
XC     To produce a double precision version, simply:
XC        a. Change PCHIC to DPCHIC wherever it occurs,
XC        b. Change PCHCE to DPCHCE wherever it occurs,
XC        c. Change PCHCI to DPCHCI wherever it occurs,
XC        d. Change PCHCS to DPCHCS wherever it occurs,
XC        e. Change the real declarations to double precision, and
XC        f. Change the constant  ZERO  to double precision.
XC
XC  DECLARE ARGUMENTS.
XC
X      INTEGER  IC(2), N, INCFD, NWK, IERR
X      REAL  VC(2), SWITCH, X(N), F(INCFD,N), D(INCFD,N), WK(NWK)
XC
XC  DECLARE LOCAL VARIABLES.
XC
X      INTEGER  I, IBEG, IEND, NLESS1
X      REAL  ZERO
X      DATA  ZERO /0./
XC
XC  VALIDITY-CHECK ARGUMENTS.
XC
XC***FIRST EXECUTABLE STATEMENT  PCHIC
X      IF ( N.LT.2 )  GO TO 5001
X      IF ( INCFD.LT.1 )  GO TO 5002
X      DO 1  I = 2, N
X         IF ( X(I).LE.X(I-1) )  GO TO 5003
X    1 CONTINUE
XC
X      IBEG = IC(1)
X      IEND = IC(2)
X      IERR = 0
X      IF (IABS(IBEG) .GT. 5)  IERR = IERR - 1
X      IF (IABS(IEND) .GT. 5)  IERR = IERR - 2
X      IF (IERR .LT. 0)  GO TO 5004
XC
XC  FUNCTION DEFINITION IS OK -- GO ON.
XC
X      NLESS1 = N - 1
X      IF ( NWK .LT. 2*NLESS1 )  GO TO 5007
XC
XC  SET UP H AND SLOPE ARRAYS.
XC
X      DO 20  I = 1, NLESS1
X         WK(I) = X(I+1) - X(I)
X         WK(NLESS1+I) = (F(1,I+1) - F(1,I)) / WK(I)
X   20 CONTINUE
XC
XC  SPECIAL CASE N=2 -- USE LINEAR INTERPOLATION.
XC
X      IF (NLESS1 .GT. 1)  GO TO 1000
X      D(1,1) = WK(2)
X      D(1,N) = WK(2)
X      GO TO 3000
XC
XC  NORMAL CASE  (N .GE. 3) .
XC
X 1000 CONTINUE
XC
XC  SET INTERIOR DERIVATIVES AND DEFAULT END CONDITIONS.
XC
XC     --------------------------------------
X      CALL PCHCI (N, WK(1), WK(N), D, INCFD)
XC     --------------------------------------
XC
XC  SET DERIVATIVES AT POINTS WHERE MONOTONICITY SWITCHES DIRECTION.
XC
X      IF (SWITCH .EQ. ZERO)  GO TO 3000
XC     ----------------------------------------------------
X      CALL PCHCS (SWITCH, N, WK(1), WK(N), D, INCFD, IERR)
XC     ----------------------------------------------------
X      IF (IERR .NE. 0)  GO TO 5008
XC
XC  SET END CONDITIONS.
XC
X 3000 CONTINUE
X      IF ( (IBEG.EQ.0) .AND. (IEND.EQ.0) )  GO TO 5000
XC     -------------------------------------------------------
X      CALL PCHCE (IC, VC, N, X, WK(1), WK(N), D, INCFD, IERR)
XC     -------------------------------------------------------
X      IF (IERR .LT. 0)  GO TO 5009
XC
XC  NORMAL RETURN.
XC
X 5000 CONTINUE
X      RETURN
XC
XC  ERROR RETURNS.
XC
X 5001 CONTINUE
XC     N.LT.2 RETURN.
X      IERR = -1
X      CALL XERROR ('PCHIC -- NUMBER OF DATA POINTS LESS THAN TWO'
X     *           , 44, IERR, 1)
X      RETURN
XC
X 5002 CONTINUE
XC     INCFD.LT.1 RETURN.
X      IERR = -2
X      CALL XERROR ('PCHIC -- INCREMENT LESS THAN ONE'
X     *           , 32, IERR, 1)
X      RETURN
XC
X 5003 CONTINUE
XC     X-ARRAY NOT STRICTLY INCREASING.
X      IERR = -3
X      CALL XERROR ('PCHIC -- X-ARRAY NOT STRICTLY INCREASING'
X     *           , 40, IERR, 1)
X      RETURN
XC
X 5004 CONTINUE
XC     IC OUT OF RANGE RETURN.
X      IERR = IERR - 3
X      CALL XERROR ('PCHIC -- IC OUT OF RANGE'
X     *           , 24, IERR, 1)
X      RETURN
XC
X 5007 CONTINUE
XC     NWK .LT. 2*(N-1)  RETURN.
X      IERR = -7
X      CALL XERROR ('PCHIC -- WORK ARRAY TOO SMALL'
X     *           , 29, IERR, 1)
X      RETURN
XC
X 5008 CONTINUE
XC     ERROR RETURN FROM PCHCS.
X      IERR = -8
X      CALL XERROR ('PCHIC -- ERROR RETURN FROM PCHCS'
X     *           , 32, IERR, 1)
X      RETURN
XC
X 5009 CONTINUE
XC     ERROR RETURN FROM PCHCE.
XC   *** THIS CASE SHOULD NEVER OCCUR ***
X      IERR = -9
X      CALL XERROR ('PCHIC -- ERROR RETURN FROM PCHCE'
X     *           , 32, IERR, 1)
X      RETURN
XC------------- LAST LINE OF PCHIC FOLLOWS ------------------------------
X      END
X      SUBROUTINE PCHCE(IC,VC,N,X,H,SLOPE,D,INCFD,IERR)
XC***BEGIN PROLOGUE  PCHCE
XC***REFER TO  PCHIC
XC***ROUTINES CALLED  PCHDF,PCHST,XERROR
XC***REVISION DATE  870707   (YYMMDD)
XC***DESCRIPTION
XC
XC          PCHCE:  PCHIC End Derivative Setter.
XC
XC    Called by PCHIC to set end derivatives as requested by the user.
XC    It must be called after interior derivative values have been set.
XC                      -----
XC
XC    To facilitate two-dimensional applications, includes an increment
XC    between successive values of the D-array.
XC
XC ----------------------------------------------------------------------
XC
XC  Calling sequence:
XC
XC        PARAMETER  (INCFD = ...)
XC        INTEGER  IC(2), N, IERR
XC        REAL  VC(2), X(N), H(N), SLOPE(N), D(INCFD,N)
XC
XC        CALL  PCHCE (IC, VC, N, X, H, SLOPE, D, INCFD, IERR)
XC
XC   Parameters:
XC
XC     IC -- (input) integer array of length 2 specifying desired
XC           boundary conditions:
XC           IC(1) = IBEG, desired condition at beginning of data.
XC           IC(2) = IEND, desired condition at end of data.
XC           ( see prologue to PCHIC for details. )
XC
XC     VC -- (input) real array of length 2 specifying desired boundary
XC           values.  VC(1) need be set only if IC(1) = 2 or 3 .
XC                    VC(2) need be set only if IC(2) = 2 or 3 .
XC
XC     N -- (input) number of data points.  (assumes N.GE.2)
XC
XC     X -- (input) real array of independent variable values.  (the
XC           elements of X are assumed to be strictly increasing.)
XC
XC     H -- (input) real array of interval lengths.
XC     SLOPE -- (input) real array of data slopes.
XC           If the data are (X(I),Y(I)), I=1(1)N, then these inputs are:
XC                  H(I) =  X(I+1)-X(I),
XC              SLOPE(I) = (Y(I+1)-Y(I))/H(I),  I=1(1)N-1.
XC
XC     D -- (input) real array of derivative values at the data points.
XC           The value corresponding to X(I) must be stored in
XC                D(1+(I-1)*INCFD),  I=1(1)N.
XC          (output) the value of D at X(1) and/or X(N) is changed, if
XC           necessary, to produce the requested boundary conditions.
XC           no other entries in D are changed.
XC
XC     INCFD -- (input) increment between successive values in D.
XC           This argument is provided primarily for 2-D applications.
XC
XC     IERR -- (output) error flag.
XC           Normal return:
XC              IERR = 0  (no errors).
XC           Warning errors:
XC              IERR = 1  if IBEG.LT.0 and D(1) had to be adjusted for
XC                        monotonicity.
XC              IERR = 2  if IEND.LT.0 and D(1+(N-1)*INCFD) had to be
XC                        adjusted for monotonicity.
XC              IERR = 3  if both of the above are true.
XC
XC    -------
XC    WARNING:  This routine does no validity-checking of arguments.
XC    -------
XC
XC  Fortran intrinsics used:  ABS, IABS.
XC
XC***END PROLOGUE  PCHCE
XC
XC ----------------------------------------------------------------------
XC
XC  Programmed by:  Fred N. Fritsch,  FTS 532-4275, (415) 422-4275,
XC                  Mathematics and Statistics Division,
XC                  Lawrence Livermore National Laboratory.
XC
XC  Change record:
XC     82-08-05   Converted to SLATEC library version.
XC     87-07-07   Minor corrections made to prologue..
XC
XC ----------------------------------------------------------------------
XC
XC  Programming notes:
XC
XC     1. The function  PCHST(ARG1,ARG2)  is assumed to return zero if
XC        either argument is zero, +1 if they are of the same sign, and
XC        -1 if they are of opposite sign.
XC     2. To produce a double precision version, simply:
XC        a. Change PCHCE to DPCHCE wherever it occurs,
XC        b. Change PCHDF to DPCHCE wherever it occurs,
XC        c. Change PCHST to DPCHST wherever it occurs,
XC        d. Change all references to the Fortran intrinsics to their
XC           double presision equivalents,
XC        e. Change the real declarations to double precision, and
XC        f. Change the constants ZERO, HALF, ... to double precision.
XC     3. One could reduce the number of arguments and amount of local
XC        storage, at the expense of reduced code clarity, by passing in
XC        the array WK (rather than splitting it into H and SLOPE) and
XC        increasing its length enough to incorporate STEMP and XTEMP.
XC     4. The two monotonicity checks only use the sufficient conditions.
XC        Thus, it is possible (but unlikely) for a boundary condition to
XC        be changed, even though the original interpolant was monotonic.
XC        (At least the result is a continuous function of the data.)
XC
XC  DECLARE ARGUMENTS.
XC
X      INTEGER  IC(2), N, INCFD, IERR
X      REAL  VC(2), X(N), H(N), SLOPE(N), D(INCFD,N)
XC
XC  DELCARE LOCAL VARIABLES.
XC
X      INTEGER  IBEG, IEND, IERF, INDEX, J, K
X      REAL  HALF, STEMP(3), THREE, TWO, XTEMP(4), ZERO
X      REAL  PCHDF, PCHST
XC
XC  INITIALIZE.
XC
X      DATA  ZERO /0./,  HALF /0.5/,  TWO /2./,  THREE /3./
XC
XC***FIRST EXECUTABLE STATEMENT  PCHCE
X      IBEG = IC(1)
X      IEND = IC(2)
X      IERR = 0
XC
XC  SET TO DEFAULT BOUNDARY CONDITIONS IF N IS TOO SMALL.
XC
X      IF ( IABS(IBEG).GT.N )  IBEG = 0
X      IF ( IABS(IEND).GT.N )  IEND = 0
XC
XC  TREAT BEGINNING BOUNDARY CONDITION.
XC
X      IF (IBEG .EQ. 0)  GO TO 2000
X      K = IABS(IBEG)
X      IF (K .EQ. 1)  THEN
XC        BOUNDARY VALUE PROVIDED.
X         D(1,1) = VC(1)
X      ELSE IF (K .EQ. 2)  THEN
XC        BOUNDARY SECOND DERIVATIVE PROVIDED.
X         D(1,1) = HALF*( (THREE*SLOPE(1) - D(1,2)) - HALF*VC(1)*H(1) )
X      ELSE IF (K .LT. 5)  THEN
XC        USE K-POINT DERIVATIVE FORMULA.
XC        PICK UP FIRST K POINTS, IN REVERSE ORDER.
X         DO 10  J = 1, K
X            INDEX = K-J+1
XC           INDEX RUNS FROM K DOWN TO 1.
X            XTEMP(J) = X(INDEX)
X            IF (J .LT. K)  STEMP(J) = SLOPE(INDEX-1)
X   10    CONTINUE
XC                 -----------------------------
X         D(1,1) = PCHDF (K, XTEMP, STEMP, IERF)
XC                 -----------------------------
X         IF (IERF .NE. 0)  GO TO 5001
X      ELSE
XC        USE 'NOT A KNOT' CONDITION.
X         D(1,1) = ( THREE*(H(1)*SLOPE(2) + H(2)*SLOPE(1))
X     *             - TWO*(H(1)+H(2))*D(1,2) - H(1)*D(1,3) ) / H(2)
X      ENDIF
XC
X      IF (IBEG .GT. 0)  GO TO 2000
XC
XC  CHECK D(1,1) FOR COMPATIBILITY WITH MONOTONICITY.
XC
X      IF (SLOPE(1) .EQ. ZERO)  THEN
X         IF (D(1,1) .NE. ZERO)  THEN
X            D(1,1) = ZERO
X            IERR = IERR + 1
X         ENDIF
X      ELSE IF ( PCHST(D(1,1),SLOPE(1)) .LT. ZERO)  THEN
X         D(1,1) = ZERO
X         IERR = IERR + 1
X      ELSE IF ( ABS(D(1,1)) .GT. THREE*ABS(SLOPE(1)) )  THEN
X         D(1,1) = THREE*SLOPE(1)
X         IERR = IERR + 1
X      ENDIF
XC
XC  TREAT END BOUNDARY CONDITION.
XC
X 2000 CONTINUE
X      IF (IEND .EQ. 0)  GO TO 5000
X      K = IABS(IEND)
X      IF (K .EQ. 1)  THEN
XC        BOUNDARY VALUE PROVIDED.
X         D(1,N) = VC(2)
X      ELSE IF (K .EQ. 2)  THEN
XC        BOUNDARY SECOND DERIVATIVE PROVIDED.
X         D(1,N) = HALF*( (THREE*SLOPE(N-1) - D(1,N-1)) +
X     *                                           HALF*VC(2)*H(N-1) )
X      ELSE IF (K .LT. 5)  THEN
XC        USE K-POINT DERIVATIVE FORMULA.
XC        PICK UP LAST K POINTS.
X         DO 2010  J = 1, K
X            INDEX = N-K+J
XC           INDEX RUNS FROM N+1-K UP TO N.
X            XTEMP(J) = X(INDEX)
X            IF (J .LT. K)  STEMP(J) = SLOPE(INDEX)
X 2010    CONTINUE
XC                 -----------------------------
X         D(1,N) = PCHDF (K, XTEMP, STEMP, IERF)
XC                 -----------------------------
X         IF (IERF .NE. 0)  GO TO 5001
X      ELSE
XC        USE 'NOT A KNOT' CONDITION.
X         D(1,N) = ( THREE*(H(N-1)*SLOPE(N-2) + H(N-2)*SLOPE(N-1))
X     *             - TWO*(H(N-1)+H(N-2))*D(1,N-1) - H(N-1)*D(1,N-2) )
X     *                                                         / H(N-2)
X      ENDIF
XC
X      IF (IEND .GT. 0)  GO TO 5000
XC
XC  CHECK D(1,N) FOR COMPATIBILITY WITH MONOTONICITY.
XC
X      IF (SLOPE(N-1) .EQ. ZERO)  THEN
X         IF (D(1,N) .NE. ZERO)  THEN
X            D(1,N) = ZERO
X            IERR = IERR + 2
X         ENDIF
X      ELSE IF ( PCHST(D(1,N),SLOPE(N-1)) .LT. ZERO)  THEN
X         D(1,N) = ZERO
X         IERR = IERR + 2
X      ELSE IF ( ABS(D(1,N)) .GT. THREE*ABS(SLOPE(N-1)) )  THEN
X         D(1,N) = THREE*SLOPE(N-1)
X         IERR = IERR + 2
X      ENDIF
XC
XC  NORMAL RETURN.
XC
X 5000 CONTINUE
X      RETURN
XC
XC  ERROR RETURN.
XC
X 5001 CONTINUE
XC     ERROR RETURN FROM PCHDF.
XC   *** THIS CASE SHOULD NEVER OCCUR ***
X      IERR = -1
X      CALL XERROR ('PCHCE -- ERROR RETURN FROM PCHDF'
X     *           , 32, IERR, 1)
X      RETURN
XC------------- LAST LINE OF PCHCE FOLLOWS ------------------------------
X      END
X      SUBROUTINE PCHCI(N,H,SLOPE,D,INCFD)
XC***BEGIN PROLOGUE  PCHCI
XC***REFER TO  PCHIC
XC***ROUTINES CALLED  PCHST
XC***REVISION DATE  870707   (YYMMDD)
XC***DESCRIPTION
XC
XC          PCHCI:  PCHIC Initial Derivative Setter.
XC
XC    Called by PCHIC to set derivatives needed to determine a monotone
XC    piecewise cubic Hermite interpolant to the data.
XC
XC    Default boundary conditions are provided which are compatible
XC    with monotonicity.  If the data are only piecewise monotonic, the
XC    interpolant will have an extremum at each point where monotonicity
XC    switches direction.
XC
XC    To facilitate two-dimensional applications, includes an increment
XC    between successive values of the D-array.
XC
XC    The resulting piecewise cubic Hermite function should be identical
XC    (within roundoff error) to that produced by PCHIM.
XC
XC ----------------------------------------------------------------------
XC
XC  Calling sequence:
XC
XC        PARAMETER  (INCFD = ...)
XC        INTEGER  N
XC        REAL  H(N), SLOPE(N), D(INCFD,N)
XC
XC        CALL  PCHCI (N, H, SLOPE, D, INCFD)
XC
XC   Parameters:
XC
XC     N -- (input) number of data points.
XC           If N=2, simply does linear interpolation.
XC
XC     H -- (input) real array of interval lengths.
XC     SLOPE -- (input) real array of data slopes.
XC           If the data are (X(I),Y(I)), I=1(1)N, then these inputs are:
XC                  H(I) =  X(I+1)-X(I),
XC              SLOPE(I) = (Y(I+1)-Y(I))/H(I),  I=1(1)N-1.
XC
XC     D -- (output) real array of derivative values at the data points.
XC           If the data are monotonic, these values will determine a
XC           a monotone cubic Hermite function.
XC           The value corresponding to X(I) is stored in
XC                D(1+(I-1)*INCFD),  I=1(1)N.
XC           No other entries in D are changed.
XC
XC     INCFD -- (input) increment between successive values in D.
XC           This argument is provided primarily for 2-D applications.
XC
XC    -------
XC    WARNING:  This routine does no validity-checking of arguments.
XC    -------
XC
XC  Fortran intrinsics used:  ABS, AMAX1, AMIN1.
XC
XC***END PROLOGUE  PCHCI
XC
XC ----------------------------------------------------------------------
XC
XC  Programmed by:  Fred N. Fritsch,  FTS 532-4275, (415) 422-4275,
XC                  Mathematics and Statistics Division,
XC                  Lawrence Livermore National Laboratory.
XC
XC  Change record:
XC     82-06-01   Modified end conditions to be continuous functions of
XC                data when monotonicity switches in next interval.
XC     82-06-02   1. Modified formulas so end conditions are less prone
XC                   to over/underflow problems.
XC                2. Minor modification to HSUM calculation.
XC     82-08-05   Converted to SLATEC library version.
XC
XC ----------------------------------------------------------------------
XC
XC  Programming notes:
XC
XC     1. The function  PCHST(ARG1,ARG2)  is assumed to return zero if
XC        either argument is zero, +1 if they are of the same sign, and
XC        -1 if they are of opposite sign.
XC     2. To produce a double precision version, simply:
XC        a. Change PCHCI to DPCHCI wherever it occurs,
XC        b. Change PCHST to DPCHST wherever it occurs,
XC        c. Change all references to the Fortran intrinsics to their
XC           double presision equivalents,
XC        d. Change the real declarations to double precision, and
XC        e. Change the constants ZERO and THREE to double precision.
XC
XC  DECLARE ARGUMENTS.
XC
X      INTEGER  N, INCFD
X      REAL  H(N), SLOPE(N), D(INCFD,N)
XC
XC  DECLARE LOCAL VARIBLES.
XC
X      INTEGER  I, NLESS1
X      REAL  DEL1, DEL2, DMAX, DMIN, DRAT1, DRAT2, HSUM, HSUMT3, THREE,
X     *      W1, W2, ZERO
X      REAL  PCHST
XC
XC  INITIALIZE.
XC
X      DATA  ZERO /0./,  THREE /3./
XC***FIRST EXECUTABLE STATEMENT  PCHCI
X      NLESS1 = N - 1
X      DEL1 = SLOPE(1)
XC
XC  SPECIAL CASE N=2 -- USE LINEAR INTERPOLATION.
XC
X      IF (NLESS1 .GT. 1)  GO TO 10
X      D(1,1) = DEL1
X      D(1,N) = DEL1
X      GO TO 5000
XC
XC  NORMAL CASE  (N .GE. 3).
XC
X   10 CONTINUE
X      DEL2 = SLOPE(2)
XC
XC  SET D(1) VIA NON-CENTERED THREE-POINT FORMULA, ADJUSTED TO BE
XC     SHAPE-PRESERVING.
XC
X      HSUM = H(1) + H(2)
X      W1 = (H(1) + HSUM)/HSUM
X      W2 = -H(1)/HSUM
X      D(1,1) = W1*DEL1 + W2*DEL2
X      IF ( PCHST(D(1,1),DEL1) .LE. ZERO)  THEN
X         D(1,1) = ZERO
X      ELSE IF ( PCHST(DEL1,DEL2) .LT. ZERO)  THEN
XC        NEED DO THIS CHECK ONLY IF MONOTONICITY SWITCHES.
X         DMAX = THREE*DEL1
X         IF (ABS(D(1,1)) .GT. ABS(DMAX))  D(1,1) = DMAX
X      ENDIF
XC
XC  LOOP THROUGH INTERIOR POINTS.
XC
X      DO 50  I = 2, NLESS1
X         IF (I .EQ. 2)  GO TO 40
XC
X         HSUM = H(I-1) + H(I)
X         DEL1 = DEL2
X         DEL2 = SLOPE(I)
X   40    CONTINUE
XC
XC        SET D(I)=0 UNLESS DATA ARE STRICTLY MONOTONIC.
XC
X         D(1,I) = ZERO
X         IF ( PCHST(DEL1,DEL2) .LE. ZERO)  GO TO 50
XC
XC        USE BRODLIE MODIFICATION OF BUTLAND FORMULA.
XC
X         HSUMT3 = HSUM+HSUM+HSUM
X         W1 = (HSUM + H(I-1))/HSUMT3
X         W2 = (HSUM + H(I)  )/HSUMT3
X         DMAX = AMAX1( ABS(DEL1), ABS(DEL2) )
X         DMIN = AMIN1( ABS(DEL1), ABS(DEL2) )
X         DRAT1 = DEL1/DMAX
X         DRAT2 = DEL2/DMAX
X         D(1,I) = DMIN/(W1*DRAT1 + W2*DRAT2)
XC
X   50 CONTINUE
XC
XC  SET D(N) VIA NON-CENTERED THREE-POINT FORMULA, ADJUSTED TO BE
XC     SHAPE-PRESERVING.
XC
X      W1 = -H(N-1)/HSUM
X      W2 = (H(N-1) + HSUM)/HSUM
X      D(1,N) = W1*DEL1 + W2*DEL2
X      IF ( PCHST(D(1,N),DEL2) .LE. ZERO)  THEN
X         D(1,N) = ZERO
X      ELSE IF ( PCHST(DEL1,DEL2) .LT. ZERO)  THEN
XC        NEED DO THIS CHECK ONLY IF MONOTONICITY SWITCHES.
X         DMAX = THREE*DEL2
X         IF (ABS(D(1,N)) .GT. ABS(DMAX))  D(1,N) = DMAX
X      ENDIF
XC
XC  NORMAL RETURN.
XC
X 5000 CONTINUE
X      RETURN
XC------------- LAST LINE OF PCHCI FOLLOWS ------------------------------
X      END
X      SUBROUTINE PCHCS(SWITCH,N,H,SLOPE,D,INCFD,IERR)
XC***BEGIN PROLOGUE  PCHCS
XC***REFER TO  PCHIC
XC***ROUTINES CALLED  PCHST,PCHSW
XC***REVISION DATE  870707   (YYMMDD)
XC***DESCRIPTION
XC
XC         PCHCS:  PCHIC Monotonicity Switch Derivative Setter.
XC
XC     Called by  PCHIC  to adjust the values of D in the vicinity of a
XC     switch in direction of monotonicity, to produce a more "visually
XC     pleasing" curve than that given by  PCHIM .
XC
XC ----------------------------------------------------------------------
XC
XC  Calling sequence:
XC
XC        PARAMETER  (INCFD = ...)
XC        INTEGER  N, IERR
XC        REAL  SWITCH, H(N), SLOPE(N), D(INCFD,N)
XC
XC        CALL  PCHCS (SWITCH, N, H, SLOPE, D, INCFD, IERR)
XC
XC   Parameters:
XC
XC     SWITCH -- (input) indicates the amount of control desired over
XC           local excursions from data.
XC
XC     N -- (input) number of data points.  (assumes N.GT.2 .)
XC
XC     H -- (input) real array of interval lengths.
XC     SLOPE -- (input) real array of data slopes.
XC           If the data are (X(I),Y(I)), I=1(1)N, then these inputs are:
XC                  H(I) =  X(I+1)-X(I),
XC              SLOPE(I) = (Y(I+1)-Y(I))/H(I),  I=1(1)N-1.
XC
XC     D -- (input) real array of derivative values at the data points,
XC           as determined by PCHCI.
XC          (output) derivatives in the vicinity of switches in direction
XC           of monotonicity may be adjusted to produce a more "visually
XC           pleasing" curve.
XC           The value corresponding to X(I) is stored in
XC                D(1+(I-1)*INCFD),  I=1(1)N.
XC           No other entries in D are changed.
XC
XC     INCFD -- (input) increment between successive values in D.
XC           This argument is provided primarily for 2-D applications.
XC
XC     IERR -- (output) error flag.  should be zero.
XC           If negative, trouble in PCHSW.  (should never happen.)
XC
XC    -------
XC    WARNING:  This routine does no validity-checking of arguments.
XC    -------
XC
XC  Fortran intrinsics used:  ABS, AMAX1, AMIN1.
XC
XC***END PROLOGUE  PCHCS
XC
XC ----------------------------------------------------------------------
XC
XC  Programmed by:  Fred N. Fritsch,  FTS 532-4275, (415) 422-4275,
XC                  Mathematics and Statistics Division,
XC                  Lawrence Livermore National Laboratory.
XC
XC  Change record:
XC     82-06-17   Redesigned to (1) fix  problem with lack of continuity
XC                approaching a flat-topped peak (2) be cleaner and
XC                easier to verify.
XC                Eliminated subroutines PCHSA and PCHSX in the process.
XC     82-06-22   1. Limited fact to not exceed one, so computed D is a
XC                   convex combination of PCHCI value and PCHSD value.
XC                2. Changed fudge from 1 to 4 (based on experiments).
XC     82-06-23   Moved PCHSD to an inline function (eliminating MSWTYP).
XC     82-08-05   Converted to SLATEC library version.
XC
XC ----------------------------------------------------------------------
XC
XC  Programming notes:
XC
XC     1. The function  PCHST(ARG1,ARG2)  is assumed to return zero if
XC        either argument is zero, +1 if they are of the same sign, and
XC        -1 if they are of opposite sign.
XC     2. To produce a double precision version, simply:
XC        a. Change PCHCS to DPCHCS wherever it occurs,
XC        b. Change PCHSD to DPCHSD wherever it occurs,
XC        c. Change PCHST to DPCHST wherever it occurs,
XC        d. Change PCHSW to DPCHSW wherever it occurs,
XC        e. Change all references to the Fortran intrinsics to their
XC           double precision equivalents,
XC        f. Change the real declarations to double precision, and
XC        g. Change the constants ZERO and ONE to double precision.
XC
XC  DECLARE ARGUMENTS.
XC
X      INTEGER  N, INCFD, IERR
X      REAL  SWITCH, H(N), SLOPE(N), D(INCFD,N)
XC
XC  DECLARE LOCAL VARIABLES.
XC
X      INTEGER  I, INDX, K, NLESS1
X      REAL  DEL(3), DEXT, DFLOC, DFMX, FACT, FUDGE, ONE, SLMAX,
X     *      WTAVE(2), ZERO
X      REAL  PCHST
XC
XC  DEFINE INLINE FUNCTION FOR WEIGHTED AVERAGE OF SLOPES.
XC
X      REAL  PCHSD, S1, S2, H1, H2
X      PCHSD(S1,S2,H1,H2) = (H2/(H1+H2))*S1 + (H1/(H1+H2))*S2
XC
XC  INITIALIZE.
XC
X      DATA  ZERO /0./,  ONE /1./
X      DATA  FUDGE /4./
XC***FIRST EXECUTABLE STATEMENT  PCHCS
X      IERR = 0
X      NLESS1 = N - 1
XC
XC  LOOP OVER SEGMENTS.
XC
X      DO 900  I = 2, NLESS1
X         IF ( PCHST(SLOPE(I-1),SLOPE(I)) )  100, 300, 900
XC             --------------------------
XC
X  100    CONTINUE
XC
XC....... SLOPE SWITCHES MONOTONICITY AT I-TH POINT .....................
XC
XC           DO NOT CHANGE D IF 'UP-DOWN-UP'.
X            IF (I .GT. 2)  THEN
X               IF ( PCHST(SLOPE(I-2),SLOPE(I)) .GT. ZERO)  GO TO 900
XC                   --------------------------
X            ENDIF
X            IF (I .LT. NLESS1)  THEN
X               IF ( PCHST(SLOPE(I+1),SLOPE(I-1)) .GT. ZERO)  GO TO 900
XC                   ----------------------------
X            ENDIF
XC
XC   ....... COMPUTE PROVISIONAL VALUE FOR D(1,I).
XC
X            DEXT = PCHSD (SLOPE(I-1), SLOPE(I), H(I-1), H(I))
XC
XC   ....... DETERMINE WHICH INTERVAL CONTAINS THE EXTREMUM.
XC
X            IF ( PCHST(DEXT, SLOPE(I-1)) )  200, 900, 250
XC                -----------------------
XC
X  200       CONTINUE
XC              DEXT AND SLOPE(I-1) HAVE OPPOSITE SIGNS --
XC                        EXTREMUM IS IN (X(I-1),X(I)).
X               K = I-1
XC              SET UP TO COMPUTE NEW VALUES FOR D(1,I-1) AND D(1,I).
X               WTAVE(2) = DEXT
X               IF (K .GT. 1)
X     *            WTAVE(1) = PCHSD (SLOPE(K-1), SLOPE(K), H(K-1), H(K))
X               GO TO 400
XC
X  250       CONTINUE
XC              DEXT AND SLOPE(I) HAVE OPPOSITE SIGNS --
XC                        EXTREMUM IS IN (X(I),X(I+1)).
X               K = I
XC              SET UP TO COMPUTE NEW VALUES FOR D(1,I) AND D(1,I+1).
X               WTAVE(1) = DEXT
X               IF (K .LT. NLESS1)
X     *            WTAVE(2) = PCHSD (SLOPE(K), SLOPE(K+1), H(K), H(K+1))
X               GO TO 400
XC
X  300    CONTINUE
XC
XC....... AT LEAST ONE OF SLOPE(I-1) AND SLOPE(I) IS ZERO --
XC                     CHECK FOR FLAT-TOPPED PEAK .......................
XC
X            IF (I .EQ. NLESS1)  GO TO 900
X            IF ( PCHST(SLOPE(I-1), SLOPE(I+1)) .GE. ZERO)  GO TO 900
XC                -----------------------------
XC
XC           WE HAVE FLAT-TOPPED PEAK ON (X(I),X(I+1)).
X            K = I
XC           SET UP TO COMPUTE NEW VALUES FOR D(1,I) AND D(1,I+1).
X            WTAVE(1) = PCHSD (SLOPE(K-1), SLOPE(K), H(K-1), H(K))
X            WTAVE(2) = PCHSD (SLOPE(K), SLOPE(K+1), H(K), H(K+1))
XC
X  400    CONTINUE
XC
XC....... AT THIS POINT WE HAVE DETERMINED THAT THERE WILL BE AN EXTREMUM
XC        ON (X(K),X(K+1)), WHERE K=I OR I-1, AND HAVE SET ARRAY WTAVE--
XC           WTAVE(1) IS A WEIGHTED AVERAGE OF SLOPE(K-1) AND SLOPE(K),
XC                    IF K.GT.1
XC           WTAVE(2) IS A WEIGHTED AVERAGE OF SLOPE(K) AND SLOPE(K+1),
XC                    IF K.LT.N-1
XC
X         SLMAX = ABS(SLOPE(K))
X         IF (K .GT. 1)    SLMAX = AMAX1( SLMAX, ABS(SLOPE(K-1)) )
X         IF (K.LT.NLESS1) SLMAX = AMAX1( SLMAX, ABS(SLOPE(K+1)) )
XC
X         IF (K .GT. 1)  DEL(1) = SLOPE(K-1) / SLMAX
X         DEL(2) = SLOPE(K) / SLMAX
X         IF (K.LT.NLESS1)  DEL(3) = SLOPE(K+1) / SLMAX
XC
X         IF ((K.GT.1) .AND. (K.LT.NLESS1))  THEN
XC           NORMAL CASE -- EXTREMUM IS NOT IN A BOUNDARY INTERVAL.
X            FACT = FUDGE* ABS(DEL(3)*(DEL(1)-DEL(2))*(WTAVE(2)/SLMAX))
X            D(1,K) = D(1,K) + AMIN1(FACT,ONE)*(WTAVE(1) - D(1,K))
X            FACT = FUDGE* ABS(DEL(1)*(DEL(3)-DEL(2))*(WTAVE(1)/SLMAX))
X            D(1,K+1) = D(1,K+1) + AMIN1(FACT,ONE)*(WTAVE(2) - D(1,K+1))
X         ELSE
XC           SPECIAL CASE K=1 (WHICH CAN OCCUR ONLY IF I=2) OR
XC                        K=NLESS1 (WHICH CAN OCCUR ONLY IF I=NLESS1).
X            FACT = FUDGE* ABS(DEL(2))
X            D(1,I) = AMIN1(FACT,ONE) * WTAVE(I-K+1)
XC              NOTE THAT I-K+1 = 1 IF K=I  (=NLESS1),
XC                        I-K+1 = 2 IF K=I-1(=1).
X         ENDIF
XC
XC
XC....... ADJUST IF NECESSARY TO LIMIT EXCURSIONS FROM DATA.
XC
X         IF (SWITCH .LE. ZERO)  GO TO 900
XC
X         DFLOC = H(K)*ABS(SLOPE(K))
X         IF (K .GT. 1)    DFLOC = AMAX1( DFLOC, H(K-1)*ABS(SLOPE(K-1)) )
X         IF (K.LT.NLESS1) DFLOC = AMAX1( DFLOC, H(K+1)*ABS(SLOPE(K+1)) )
X         DFMX = SWITCH*DFLOC
X         INDX = I-K+1
XC        INDX = 1 IF K=I, 2 IF K=I-1.
XC        ---------------------------------------------------------------
X         CALL PCHSW (DFMX, INDX, D(1,K), D(1,K+1), H(K), SLOPE(K), IERR)
XC        ---------------------------------------------------------------
X         IF (IERR .NE. 0)  RETURN
XC
XC....... END OF SEGMENT LOOP.
XC
X  900 CONTINUE
XC
X      RETURN
XC------------- LAST LINE OF PCHCS FOLLOWS ------------------------------
X      END
X      REAL FUNCTION PCHDF(K,X,S,IERR)
XC***BEGIN PROLOGUE  PCHDF
XC***REFER TO  PCHCE,PCHSP
XC***ROUTINES CALLED  XERROR
XC***REVISION DATE  870707   (YYMMDD)
XC***DESCRIPTION
XC
XC          PCHDF:   PCHIP Finite Difference Formula
XC
XC     Uses a divided difference formulation to compute a K-point approx-
XC     imation to the derivative at X(K) based on the data in X and S.
XC
XC     Called by  PCHCE  and  PCHSP  to compute 3- and 4-point boundary
XC     derivative approximations.
XC
XC ----------------------------------------------------------------------
XC
XC     On input:
XC        K      is the order of the desired derivative approximation.
XC               K must be at least 3 (error return if not).
XC        X      contains the K values of the independent variable.
XC               X need not be ordered, but the values **MUST** be
XC               distinct.  (Not checked here.)
XC        S      contains the associated slope values:
XC                  S(I) = (F(I+1)-F(I))/(X(I+1)-X(I)), I=1(1)K-1.
XC               (Note that S need only be of length K-1.)
XC
XC     On return:
XC        S      will be destroyed.
XC        IERR   will be set to -1 if K.LT.2 .
XC        PCHDF  will be set to the desired derivative approximation if
XC               IERR=0 or to zero if IERR=-1.
XC
XC ----------------------------------------------------------------------
XC
XC  Reference:  Carl de Boor, A Practical Guide to Splines, Springer-
XC              Verlag (New York, 1978), pp. 10-16.
XC
XC***END PROLOGUE  PCHDF
XC
XC ----------------------------------------------------------------------
XC
XC  Programmed by:  Fred N. Fritsch,  FTS 532-4275, (415) 422-4275,
XC                  Mathematics and Statistics Division,
XC                  Lawrence Livermore National Laboratory.
XC
XC  Change record:
XC     82-08-05   Converted to SLATEC library version.
XC
XC ----------------------------------------------------------------------
XC
XC  Programming notes:
XC
XC     To produce a double precision version, simply:
XC        a. Change PCHDF to DPCHDF wherever it occurs,
XC        b. Change the real declarations to double precision, and
XC        c. Change the constant ZERO to double precision.
X      INTEGER  K, IERR
X      REAL  X(K), S(K)
XC
XC  DECLARE LOCAL VARIABLES.
XC
X      INTEGER  I, J
X      REAL  VALUE, ZERO
X      DATA  ZERO /0./
XC
XC  CHECK FOR LEGAL VALUE OF K.
XC
XC***FIRST EXECUTABLE STATEMENT  PCHDF
X      IF (K .LT. 3)  GO TO 5001
XC
XC  COMPUTE COEFFICIENTS OF INTERPOLATING POLYNOMIAL.
XC
X      DO 10  J = 2, K-1
X         DO 9  I = 1, K-J
X            S(I) = (S(I+1)-S(I))/(X(I+J)-X(I))
X    9    CONTINUE
X   10 CONTINUE
XC
XC  EVALUATE DERIVATIVE AT X(K).
XC
X      VALUE = S(1)
X      DO 20  I = 2, K-1
X         VALUE = S(I) + VALUE*(X(K)-X(I))
X   20 CONTINUE
XC
XC  NORMAL RETURN.
XC
X      IERR = 0
X      PCHDF = VALUE
X      RETURN
XC
XC  ERROR RETURN.
XC
X 5001 CONTINUE
XC     K.LT.3 RETURN.
X      IERR = -1
X      CALL XERROR ('PCHDF -- K LESS THAN THREE'
X     *           , 26, IERR, 1)
X      PCHDF = ZERO
X      RETURN
XC------------- LAST LINE OF PCHDF FOLLOWS ------------------------------
X      END
X      REAL FUNCTION PCHST(ARG1,ARG2)
XC***BEGIN PROLOGUE  PCHST
XC***REFER TO  PCHCE,PCHCI,PCHCS,PCHIM
XC***ROUTINES CALLED  (NONE)
XC***REVISION DATE  870707   (YYMMDD)
XC***DESCRIPTION
XC
XC         PCHST:  PCHIP Sign-Testing Routine.
XC
XC
XC     Returns:
XC        -1. if ARG1 and ARG2 are of opposite sign.
XC         0. if either argument is zero.
XC        +1. if ARG1 and ARG2 are of the same sign.
XC
XC     The object is to do this without multiplying ARG1*ARG2, to avoid
XC     possible over/underflow problems.
XC
XC  Fortran intrinsics used:  SIGN.
XC
XC***END PROLOGUE  PCHST
XC
XC ----------------------------------------------------------------------
XC
XC  Programmed by:  Fred N. Fritsch,  FTS 532-4275, (415) 422-4275,
XC                  Mathematics and Statistics Division,
XC                  Lawrence Livermore National Laboratory.
XC
XC  Change record:
XC     82-08-05   Converted to SLATEC library version.
XC
XC ----------------------------------------------------------------------
XC
XC  Programming notes:
XC
XC     To produce a double precision version, simply:
XC        a. Change PCHST to DPCHST wherever it occurs,
XC        b. Change all references to the Fortran intrinsics to their
XC           double presision equivalents,
XC        c. Change the real declarations to double precision, and
XC        d. Change the constants  ZERO  and  ONE  to double precision.
XC
XC  DECLARE ARGUMENTS.
XC
X      REAL  ARG1, ARG2
XC
XC  DECLARE LOCAL VARIABLES.
XC
X      REAL  ONE, ZERO
X      DATA  ZERO /0./,  ONE /1./
XC
XC  PERFORM THE TEST.
XC
XC***FIRST EXECUTABLE STATEMENT  PCHST
X      PCHST = SIGN(ONE,ARG1) * SIGN(ONE,ARG2)
X      IF ((ARG1.EQ.ZERO) .OR. (ARG2.EQ.ZERO))  PCHST = ZERO
XC
X      RETURN
XC------------- LAST LINE OF PCHST FOLLOWS ------------------------------
X      END
X      SUBROUTINE PCHSW(DFMAX,IEXTRM,D1,D2,H,SLOPE,IERR)
XC***BEGIN PROLOGUE  PCHSW
XC***REFER TO  PCHCS
XC***ROUTINES CALLED  R1MACH,XERROR
XC***REVISION DATE  870707   (YYMMDD)
XC***DESCRIPTION
XC
XC         PCHSW:  PCHCS Switch Excursion Limiter.
XC
XC     Called by  PCHCS  to adjust D1 and D2 if necessary to insure that
XC     the extremum on this interval is not further than DFMAX from the
XC     extreme data value.
XC
XC ----------------------------------------------------------------------
XC
XC  Calling sequence:
XC
XC        INTEGER  IEXTRM, IERR
XC        REAL  DFMAX, D1, D2, H, SLOPE
XC
XC        CALL  PCHSW (DFMAX, IEXTRM, D1, D2, H, SLOPE, IERR)
XC
XC   Parameters:
XC
XC     DFMAX -- (input) maximum allowed difference between F(IEXTRM) and
XC           the cubic determined by derivative values D1,D2.  (assumes
XC           DFMAX.GT.0.)
XC
XC     IEXTRM -- (input) index of the extreme data value.  (assumes
XC           IEXTRM = 1 or 2 .  Any value .NE.1 is treated as 2.)
XC
XC     D1,D2 -- (input) derivative values at the ends of the interval.
XC           (Assumes D1*D2 .LE. 0.)
XC          (output) may be modified if necessary to meet the restriction
XC           imposed by DFMAX.
XC
XC     H -- (input) interval length.  (Assumes  H.GT.0.)
XC
XC     SLOPE -- (input) data SLOPE on the interval.
XC
XC     IERR -- (output) error flag.  should be zero.
XC           If IERR=-1, assumption on D1 and D2 is not satisfied.
XC           If IERR=-2, quadratic equation locating extremum has
XC                       negative descriminant (should never occur).
XC
XC    -------
XC    WARNING:  This routine does no validity-checking of arguments.
XC    -------
XC
XC
XC  Fortran intrinsics used:  ABS, SIGN, SQRT.
XC
XC***END PROLOGUE  PCHSW
XC
XC ----------------------------------------------------------------------
XC
XC  Programmed by:  Fred N. Fritsch,  FTS 532-4275, (415) 422-4275,
XC                  Mathematics and Statistics Division,
XC                  Lawrence Livermore National Laboratory.
XC
XC  Change record:
XC     82-08-05   Converted to SLATEC library version.
XC     87-07-07   Replaced DATA statement for SMALL with a use of R1MACH.
XC
XC ----------------------------------------------------------------------
XC
XC  Programming notes:
XC
XC     To produce a double precision version, simply:
XC        a. Change PCHSW to DPCHSW wherever it occurs,
XC        b. Change PCHCS to DPCHCS wherever it occurs,
XC        c. Change R1MACH to D1MACH wherever it occurs,
XC        d. Change all references to the Fortran intrinsics to their
XC           double precision equivalents,
XC        e. Change the real declarations to double precision, and
XC        f. Change constants ZERO, ONE, TWO, ... to double precision.
XC
XC  DECLARE ARGUMENTS.
XC
X      INTEGER  IEXTRM, IERR
X      REAL  DFMAX, D1, D2, H, SLOPE
XC
XC  DECLARE LOCAL VARIABLES.
XC
X      REAL  CP, DMAX, FACT, LAMBDA, NU, ONE, PHI, RADCAL, RHO, SIGMA,
X     *      SMALL, THAT, THIRD, THREE, TWO, ZERO
X      DATA  ZERO /0./,  ONE /1./,  TWO /2./,  THREE /3./, FACT /100./
XC        THIRD SHOULD BE SLIGHTLY LESS THAN 1/3.
X      DATA  THIRD /0.33333/
XC
XC  NOTATION AND GENERAL REMARKS.
XC
XC     RHO IS THE RATIO OF THE DATA SLOPE TO THE DERIVATIVE BEING TESTED.
XC     LAMBDA IS THE RATIO OF D2 TO D1.
XC     THAT = T-HAT(RHO) IS THE NORMALIZED LOCATION OF THE EXTREMUM.
XC     PHI IS THE NORMALIZED VALUE OF P(X)-F1 AT X = XHAT = X-HAT(RHO),
XC           WHERE  THAT = (XHAT - X1)/H .
XC        THAT IS, P(XHAT)-F1 = D*H*PHI,  WHERE D=D1 OR D2.
XC     SIMILARLY,  P(XHAT)-F2 = D*H*(PHI-RHO) .
XC
XC      SMALL SHOULD BE A FEW ORDERS OF MAGNITUDE GREATER THAN MACHEPS.
XC***FIRST EXECUTABLE STATEMENT  PCHSW
X      SMALL = FACT*R1MACH(4)
XC
XC  DO MAIN CALCULATION.
XC
X      IF (D1 .EQ. ZERO)  THEN
XC
XC        SPECIAL CASE -- D1.EQ.ZERO .
XC
XC          IF D2 IS ALSO ZERO, THIS ROUTINE SHOULD NOT HAVE BEEN CALLED.
X         IF (D2 .EQ. ZERO)  GO TO 5001
XC
X         RHO = SLOPE/D2
XC          EXTREMUM IS OUTSIDE INTERVAL WHEN RHO .GE. 1/3 .
X         IF (RHO .GE. THIRD)  GO TO 5000
X         THAT = (TWO*(THREE*RHO-ONE)) / (THREE*(TWO*RHO-ONE))
X         PHI = THAT**2 * ((THREE*RHO-ONE)/THREE)
XC
XC          CONVERT TO DISTANCE FROM F2 IF IEXTRM.NE.1 .
X         IF (IEXTRM .NE. 1)  PHI = PHI - RHO
XC
XC          TEST FOR EXCEEDING LIMIT, AND ADJUST ACCORDINGLY.
X         DMAX = DFMAX / (H*ABS(PHI))
X         IF (ABS(D2) .GT. DMAX)  D2 = SIGN (DMAX, D2)
X      ELSE
XC
X         RHO = SLOPE/D1
X         LAMBDA = -D2/D1
X         IF (D2 .EQ. ZERO)  THEN
XC
XC           SPECIAL CASE -- D2.EQ.ZERO .
XC
XC             EXTREMUM IS OUTSIDE INTERVAL WHEN RHO .GE. 1/3 .
X            IF (RHO .GE. THIRD)  GO TO 5000
X            CP = TWO - THREE*RHO
X            NU = ONE - TWO*RHO
X            THAT = ONE / (THREE*NU)
X         ELSE
X            IF (LAMBDA .LE. ZERO)  GO TO 5001
XC
XC           NORMAL CASE -- D1 AND D2 BOTH NONZERO, OPPOSITE SIGNS.
XC
X            NU = ONE - LAMBDA - TWO*RHO
X            SIGMA = ONE - RHO
X            CP = NU + SIGMA
X            IF (ABS(NU) .GT. SMALL)  THEN
X               RADCAL = (NU - (TWO*RHO+ONE))*NU + SIGMA**2
X               IF (RADCAL .LT. ZERO)  GO TO 5002
X               THAT = (CP - SQRT(RADCAL)) / (THREE*NU)
X            ELSE
X               THAT = ONE/(TWO*SIGMA)
X            ENDIF
X         ENDIF
X         PHI = THAT*((NU*THAT - CP)*THAT + ONE)
XC
XC          CONVERT TO DISTANCE FROM F2 IF IEXTRM.NE.1 .
X         IF (IEXTRM .NE. 1)  PHI = PHI - RHO
XC
XC          TEST FOR EXCEEDING LIMIT, AND ADJUST ACCORDINGLY.
X         DMAX = DFMAX / (H*ABS(PHI))
X         IF (ABS(D1) .GT. DMAX)  THEN
X            D1 = SIGN (DMAX, D1)
X            D2 = -LAMBDA*D1
X         ENDIF
X      ENDIF
XC
XC  NORMAL RETURN.
XC
X 5000 CONTINUE
X      IERR = 0
X      RETURN
XC
XC  ERROR RETURNS.
XC
X 5001 CONTINUE
XC     D1 AND D2 BOTH ZERO, OR BOTH NONZERO AND SAME SIGN.
X      IERR = -1
X      CALL XERROR ('PCHSW -- D1 AND/OR D2 INVALID'
X     *           , 29, IERR, 1)
X      RETURN
XC
X 5002 CONTINUE
XC     NEGATIVE VALUE OF RADICAL (SHOULD NEVER OCCUR).
X      IERR = -2
X      CALL XERROR ('PCHSW -- NEGATIVE RADICAL'
X     *           , 25, IERR, 1)
X      RETURN
XC------------- LAST LINE OF PCHSW FOLLOWS ------------------------------
X      END
END_OF_FILE
if test 47249 -ne `wc -c <'pchic.f'`; then
    echo shar: \"'pchic.f'\" unpacked with wrong size!
fi
# end of 'pchic.f'
fi
if test -f 'pchfe.f' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'pchfe.f'\"
else
echo shar: Extracting \"'pchfe.f'\" \(15065 characters\)
sed "s/^X//" >'pchfe.f' <<'END_OF_FILE'
X      SUBROUTINE PCHFE(N,X,F,D,INCFD,SKIP,NE,XE,FE,IERR)
XC***BEGIN PROLOGUE  PCHFE
XC***DATE WRITTEN   811020   (YYMMDD)
XC***REVISION DATE  870707   (YYMMDD)
XC***CATEGORY NO.  E3
XC***KEYWORDS  LIBRARY=SLATEC(PCHIP),
XC             TYPE=SINGLE PRECISION(PCHFE-S DPCHFE-D),
XC             CUBIC HERMITE EVALUATION,HERMITE INTERPOLATION,
XC             PIECEWISE CUBIC EVALUATION
XC***AUTHOR  FRITSCH, F. N., (LLNL)
XC             MATHEMATICS AND STATISTICS DIVISION
XC             LAWRENCE LIVERMORE NATIONAL LABORATORY
XC             P.O. BOX 808  (L-316)
XC             LIVERMORE, CA  94550
XC             FTS 532-4275, (415) 422-4275
XC***PURPOSE  EVALUATE A PIECEWISE CUBIC HERMITE FUNCTION AT AN ARRAY OF
XC            POINTS.  MAY BE USED BY ITSELF FOR HERMITE INTERPOLATION,
XC            OR AS AN EVALUATOR FOR PCHIM OR PCHIC.
XC***DESCRIPTION
XC
XC          PCHFE:  PIECEWISE CUBIC HERMITE FUNCTION EVALUATOR
XC
XC     EVALUATES THE CUBIC HERMITE FUNCTION DEFINED BY  N, X, F, D  AT
XC     THE POINTS  XE(J), J=1(1)NE.
XC
XC     TO PROVIDE COMPATIBILITY WITH PCHIM AND PCHIC, INCLUDES AN
XC     INCREMENT BETWEEN SUCCESSIVE VALUES OF THE F- AND D-ARRAYS.
XC
XC ----------------------------------------------------------------------
XC
XC  CALLING SEQUENCE: 
XC
XC        PARAMETER  (INCFD = ...)
XC        INTEGER  N, NE, IERR
XC        REAL  X(N), F(INCFD,N), D(INCFD,N), XE(NE), FE(NE)
XC        LOGICAL  SKIP
XC
XC        CALL  PCHFE (N, X, F, D, INCFD, SKIP, NE, XE, FE, IERR)
XC
XC   PARAMETERS: 
XC
XC     N -- (INPUT) NUMBER OF DATA POINTS.  (ERROR RETURN IF N.LT.2 .)
XC
XC     X -- (INPUT) REAL ARRAY OF INDEPENDENT VARIABLE VALUES.  THE
XC           ELEMENTS OF X MUST BE STRICTLY INCREASING: 
XC                X(I-1) .LT. X(I),  I = 2(1)N.
XC           (ERROR RETURN IF NOT.)
XC
XC     F -- (INPUT) REAL ARRAY OF FUNCTION VALUES.  F(1+(I-1)*INCFD) IS
XC           THE VALUE CORRESPONDING TO X(I).
XC
XC     D -- (INPUT) REAL ARRAY OF DERIVATIVE VALUES.  D(1+(I-1)*INCFD) IS
XC           THE VALUE CORRESPONDING TO X(I).
XC
XC     INCFD -- (INPUT) INCREMENT BETWEEN SUCCESSIVE VALUES IN F AND D.
XC           (ERROR RETURN IF  INCFD.LT.1 .)
XC
XC     SKIP -- (INPUT/OUTPUT) LOGICAL VARIABLE WHICH SHOULD BE SET TO
XC           .TRUE. IF THE USER WISHES TO SKIP CHECKS FOR VALIDITY OF
XC           PRECEDING PARAMETERS, OR TO .FALSE. OTHERWISE.
XC           THIS WILL SAVE TIME IN CASE THESE CHECKS HAVE ALREADY
XC           BEEN PERFORMED (SAY, IN PCHIM OR PCHIC).
XC           SKIP WILL BE SET TO .TRUE. ON NORMAL RETURN.
XC
XC     NE -- (INPUT) NUMBER OF EVALUATION POINTS.  (ERROR RETURN IF
XC           NE.LT.1 .)
XC
XC     XE -- (INPUT) REAL ARRAY OF POINTS AT WHICH THE FUNCTION IS TO BE
XC           EVALUATED.
XC
XC          NOTES: 
XC           1. THE EVALUATION WILL BE MOST EFFICIENT IF THE ELEMENTS
XC              OF XE ARE INCREASING RELATIVE TO X;
XC              THAT IS,   XE(J) .GE. X(I)
XC              IMPLIES    XE(K) .GE. X(I),  ALL K.GE.J .
XC           2. IF ANY OF THE XE ARE OUTSIDE THE INTERVAL [X(1),X(N)],
XC              VALUES ARE EXTRAPOLATED FROM THE NEAREST EXTREME CUBIC,
XC              AND A WARNING ERROR IS RETURNED.
XC
XC     FE -- (OUTPUT) REAL ARRAY OF VALUES OF THE CUBIC HERMITE FUNCTION
XC           DEFINED BY  N, X, F, D  AT THE POINTS  XE.
XC
XC     IERR -- (OUTPUT) ERROR FLAG.
XC           NORMAL RETURN: 
XC              IERR = 0  (NO ERRORS).
XC           WARNING ERROR: 
XC              IERR.GT.0  MEANS THAT EXTRAPOLATION WAS PERFORMED AT
XC                 IERR POINTS.
XC           "RECOVERABLE" ERRORS: 
XC              IERR = -1  IF N.LT.2 .
XC              IERR = -2  IF INCFD.LT.1 .
XC              IERR = -3  IF THE X-ARRAY IS NOT STRICTLY INCREASING.
XC              IERR = -4  IF NE.LT.1 .
XC             (THE FE-ARRAY HAS NOT BEEN CHANGED IN ANY OF THESE CASES.)
XC               NOTE:  THE ABOVE ERRORS ARE CHECKED IN THE ORDER LISTED,
XC                   AND FOLLOWING ARGUMENTS HAVE **NOT** BEEN VALIDATED.
XC
XC***REFERENCES  (NONE)
XC***ROUTINES CALLED  CHFEV,XERROR
XC***END PROLOGUE  PCHFE
XC
XC ----------------------------------------------------------------------
XC
XC  CHANGE RECORD: 
XC     82-08-03   MINOR COSMETIC CHANGES FOR RELEASE 1.
XC     87-07-07   MINOR COSMETIC CHANGES TO PROLOGUE.
XC
XC ----------------------------------------------------------------------
XC
XC  PROGRAMMING NOTES: 
XC
XC     1. TO PRODUCE A DOUBLE PRECISION VERSION, SIMPLY: 
XC        A. CHANGE PCHFE TO DPCHFE, AND CHFEV TO DCHFEV, WHEREVER THEY
XC           OCCUR,
XC        B. CHANGE THE REAL DECLARATION TO DOUBLE PRECISION,
XC
XC     2. MOST OF THE CODING BETWEEN THE CALL TO CHFEV AND THE END OF
XC        THE IR-LOOP COULD BE ELIMINATED IF IT WERE PERMISSIBLE TO
XC        ASSUME THAT XE IS ORDERED RELATIVE TO X.
XC
XC     3. CHFEV DOES NOT ASSUME THAT X1 IS LESS THAN X2.  THUS, IT WOULD
XC        BE POSSIBLE TO WRITE A VERSION OF PCHFE THAT ASSUMES A STRICT-
XC        LY DECREASING X-ARRAY BY SIMPLY RUNNING THE IR-LOOP BACKWARDS
XC        (AND REVERSING THE ORDER OF APPROPRIATE TESTS).
XC
XC     4. THE PRESENT CODE HAS A MINOR BUG, WHICH I HAVE DECIDED IS NOT
XC        WORTH THE EFFORT THAT WOULD BE REQUIRED TO FIX IT.
XC        IF XE CONTAINS POINTS IN [X(N-1),X(N)], FOLLOWED BY POINTS .LT.
XC        X(N-1), FOLLOWED BY POINTS .GT.X(N), THE EXTRAPOLATION POINTS
XC        WILL BE COUNTED (AT LEAST) TWICE IN THE TOTAL RETURNED IN IERR.
XC
XC  DECLARE ARGUMENTS.
XC
X      INTEGER  N, INCFD, NE, IERR
X      REAL  X(N), F(INCFD,N), D(INCFD,N), XE(NE), FE(NE)
X      LOGICAL  SKIP
XC
XC  DECLARE LOCAL VARIABLES.
XC
X      INTEGER  I, IERC, IR, J, JFIRST, NEXT(2), NJ
XC
XC  VALIDITY-CHECK ARGUMENTS.
XC
XC***FIRST EXECUTABLE STATEMENT  PCHFE
X      IF (SKIP)  GO TO 5
XC
X      IF ( N.LT.2 )  GO TO 5001
X      IF ( INCFD.LT.1 )  GO TO 5002
X      DO 1  I = 2, N
X         IF ( X(I).LE.X(I-1) )  GO TO 5003
X    1 CONTINUE
XC
XC  FUNCTION DEFINITION IS OK, GO ON.
XC
X    5 CONTINUE
X      IF ( NE.LT.1 )  GO TO 5004
X      IERR = 0
X      SKIP = .TRUE.
XC
XC  LOOP OVER INTERVALS.        (   INTERVAL INDEX IS  IL = IR-1  . )
XC                              ( INTERVAL IS X(IL).LE.X.LT.X(IR) . )
X      JFIRST = 1
X      IR = 2
X   10 CONTINUE
XC
XC     SKIP OUT OF LOOP IF HAVE PROCESSED ALL EVALUATION POINTS.
XC
X         IF (JFIRST .GT. NE)  GO TO 5000
XC
XC     LOCATE ALL POINTS IN INTERVAL.
XC
X         DO 20  J = JFIRST, NE
X            IF (XE(J) .GE. X(IR))  GO TO 30
X   20    CONTINUE
X         J = NE + 1
X         GO TO 40
XC
XC     HAVE LOCATED FIRST POINT BEYOND INTERVAL.
XC
X   30    CONTINUE
X         IF (IR .EQ. N)  J = NE + 1
XC
X   40    CONTINUE
X         NJ = J - JFIRST
XC
XC     SKIP EVALUATION IF NO POINTS IN INTERVAL.
XC
X         IF (NJ .EQ. 0)  GO TO 50
XC
XC     EVALUATE CUBIC AT XE(I),  I = JFIRST (1) J-1 .
XC
XC       ----------------------------------------------------------------
X        CALL CHFEV (X(IR-1),X(IR), F(1,IR-1),F(1,IR), D(1,IR-1),D(1,IR),
X     *              NJ, XE(JFIRST), FE(JFIRST), NEXT, IERC)
XC       ----------------------------------------------------------------
X         IF (IERC .LT. 0)  GO TO 5005
XC
X         IF (NEXT(2) .EQ. 0)  GO TO 42
XC        IF (NEXT(2) .GT. 0)  THEN
XC           IN THE CURRENT SET OF XE-POINTS, THERE ARE NEXT(2) TO THE
XC           RIGHT OF X(IR).
XC
X            IF (IR .LT. N)  GO TO 41
XC           IF (IR .EQ. N)  THEN
XC              THESE ARE ACTUALLY EXTRAPOLATION POINTS.
X               IERR = IERR + NEXT(2)
X               GO TO 42
X   41       CONTINUE
XC           ELSE
XC              WE SHOULD NEVER HAVE GOTTEN HERE.
X               GO TO 5005
XC           ENDIF
XC        ENDIF
X   42    CONTINUE
XC
X         IF (NEXT(1) .EQ. 0)  GO TO 49
XC        IF (NEXT(1) .GT. 0)  THEN
XC           IN THE CURRENT SET OF XE-POINTS, THERE ARE NEXT(1) TO THE
XC           LEFT OF X(IR-1).
XC
X            IF (IR .GT. 2)  GO TO 43
XC           IF (IR .EQ. 2)  THEN
XC              THESE ARE ACTUALLY EXTRAPOLATION POINTS.
X               IERR = IERR + NEXT(1)
X               GO TO 49
X   43       CONTINUE
XC           ELSE
XC              XE IS NOT ORDERED RELATIVE TO X, SO MUST ADJUST
XC              EVALUATION INTERVAL.
XC
XC              FIRST, LOCATE FIRST POINT TO LEFT OF X(IR-1).
X               DO 44  I = JFIRST, J-1
X                  IF (XE(I) .LT. X(IR-1))  GO TO 45
X   44          CONTINUE
XC              NOTE-- CANNOT DROP THROUGH HERE UNLESS THERE IS AN ERROR
XC                     IN CHFEV.
X               GO TO 5005
XC
X   45          CONTINUE
XC              RESET J.  (THIS WILL BE THE NEW JFIRST.)
X               J = I
XC
XC              NOW FIND OUT HOW FAR TO BACK UP IN THE X-ARRAY.
X               DO 46  I = 1, IR-1
X                  IF (XE(J) .LT. X(I)) GO TO 47
X   46          CONTINUE
XC              NB-- CAN NEVER DROP THROUGH HERE, SINCE XE(J).LT.X(IR-1).
XC
X   47          CONTINUE
XC              AT THIS POINT, EITHER  XE(J) .LT. X(1)
XC                 OR      X(I-1) .LE. XE(J) .LT. X(I) .
XC              RESET IR, RECOGNIZING THAT IT WILL BE INCREMENTED BEFORE
XC              CYCLING.
X               IR = MAX0(1, I-1)
XC           ENDIF
XC        ENDIF
X   49    CONTINUE
XC
X         JFIRST = J
XC
XC     END OF IR-LOOP.
XC
X   50 CONTINUE
X      IR = IR + 1
X      IF (IR .LE. N)  GO TO 10
XC
XC  NORMAL RETURN.
XC
X 5000 CONTINUE
X      RETURN
XC
XC  ERROR RETURNS.
XC
X 5001 CONTINUE
XC     N.LT.2 RETURN.
X      IERR = -1
X      CALL XERROR ('PCHFE -- NUMBER OF DATA POINTS LESS THAN TWO'
X     *           , 44, IERR, 1)
X      RETURN
XC
X 5002 CONTINUE
XC     INCFD.LT.1 RETURN.
X      IERR = -2
X      CALL XERROR ('PCHFE -- INCREMENT LESS THAN ONE'
X     *           , 32, IERR, 1)
X      RETURN
XC
X 5003 CONTINUE
XC     X-ARRAY NOT STRICTLY INCREASING.
X      IERR = -3
X      CALL XERROR ('PCHFE -- X-ARRAY NOT STRICTLY INCREASING'
X     *           , 40, IERR, 1)
X      RETURN
XC
X 5004 CONTINUE
XC     NE.LT.1 RETURN.
X      IERR = -4
X      CALL XERROR ('PCHFE -- NUMBER OF EVALUATION POINTS LESS THAN ONE'
X     *           , 50, IERR, 1)
X      RETURN
XC
X 5005 CONTINUE
XC     ERROR RETURN FROM CHFEV.
XC   *** THIS CASE SHOULD NEVER OCCUR ***
X      IERR = -5
X      CALL XERROR ('PCHFE -- ERROR RETURN FROM CHFEV -- FATAL'
X     *           , 41, IERR, 2)
X      RETURN
XC------------- LAST LINE OF PCHFE FOLLOWS ------------------------------
X      END
X      SUBROUTINE CHFEV(X1,X2,F1,F2,D1,D2,NE,XE,FE,NEXT,IERR)
XC***BEGIN PROLOGUE  CHFEV
XC***DATE WRITTEN   811019   (YYMMDD)
XC***REVISION DATE  870707   (YYMMDD)
XC***CATEGORY NO.  E3,H1
XC***KEYWORDS  LIBRARY=SLATEC(PCHIP),
XC             TYPE=SINGLE PRECISION(CHFEV-S DCHFEV-D),
XC             CUBIC HERMITE EVALUATION,CUBIC POLYNOMIAL EVALUATION
XC***AUTHOR  FRITSCH, F. N., (LLNL)
XC             MATHEMATICS AND STATISTICS DIVISION
XC             LAWRENCE LIVERMORE NATIONAL LABORATORY
XC             P.O. BOX 808  (L-316)
XC             LIVERMORE, CA  94550
XC             FTS 532-4275, (415) 422-4275
XC***PURPOSE  EVALUATE A CUBIC POLYNOMIAL GIVEN IN HERMITE FORM AT AN
XC            ARRAY OF POINTS.  WHILE DESIGNED FOR USE BY PCHFE, IT MAY
XC            BE USEFUL DIRECTLY AS AN EVALUATOR FOR A PIECEWISE CUBIC
XC            HERMITE FUNCTION IN APPLICATIONS, SUCH AS GRAPHING, WHERE
XC            THE INTERVAL IS KNOWN IN ADVANCE.
XC***DESCRIPTION
XC
XC          CHFEV:  CUBIC HERMITE FUNCTION EVALUATOR
XC
XC     EVALUATES THE CUBIC POLYNOMIAL DETERMINED BY FUNCTION VALUES
XC     F1,F2 AND DERIVATIVES D1,D2 ON INTERVAL (X1,X2) AT THE POINTS
XC     XE(J), J=1(1)NE.
XC
XC ----------------------------------------------------------------------
XC
XC  CALLING SEQUENCE: 
XC
XC        INTEGER  NE, NEXT(2), IERR
XC        REAL  X1, X2, F1, F2, D1, D2, XE(NE), FE(NE)
XC
XC        CALL  CHFEV (X1,X2, F1,F2, D1,D2, NE, XE, FE, NEXT, IERR)
XC
XC   PARAMETERS: 
XC
XC     X1,X2 -- (INPUT) ENDPOINTS OF INTERVAL OF DEFINITION OF CUBIC.
XC           (ERROR RETURN IF  X1.EQ.X2 .)
XC
XC     F1,F2 -- (INPUT) VALUES OF FUNCTION AT X1 AND X2, RESPECTIVELY.
XC
XC     D1,D2 -- (INPUT) VALUES OF DERIVATIVE AT X1 AND X2, RESPECTIVELY.
XC
XC     NE -- (INPUT) NUMBER OF EVALUATION POINTS.  (ERROR RETURN IF
XC           NE.LT.1 .)
XC
XC     XE -- (INPUT) REAL ARRAY OF POINTS AT WHICH THE FUNCTION IS TO BE
XC           EVALUATED.  IF ANY OF THE XE ARE OUTSIDE THE INTERVAL
XC           [X1,X2], A WARNING ERROR IS RETURNED IN NEXT.
XC
XC     FE -- (OUTPUT) REAL ARRAY OF VALUES OF THE CUBIC FUNCTION DEFINED
XC           BY  X1,X2, F1,F2, D1,D2  AT THE POINTS  XE.
XC
XC     NEXT -- (OUTPUT) INTEGER ARRAY INDICATING NUMBER OF EXTRAPOLATION
XC           POINTS: 
XC            NEXT(1) = NUMBER OF EVALUATION POINTS TO LEFT OF INTERVAL.
XC            NEXT(2) = NUMBER OF EVALUATION POINTS TO RIGHT OF INTERVAL.
XC
XC     IERR -- (OUTPUT) ERROR FLAG.
XC           NORMAL RETURN: 
XC              IERR = 0  (NO ERRORS).
XC           "RECOVERABLE" ERRORS: 
XC              IERR = -1  IF NE.LT.1 .
XC              IERR = -2  IF X1.EQ.X2 .
XC                (THE FE-ARRAY HAS NOT BEEN CHANGED IN EITHER CASE.)
XC
XC***REFERENCES  (NONE)
XC***ROUTINES CALLED  XERROR
XC***END PROLOGUE  CHFEV
XC
XC ----------------------------------------------------------------------
XC
XC  CHANGE RECORD: 
XC     82-08-03   MINOR COSMETIC CHANGES FOR RELEASE 1.
XC
XC ----------------------------------------------------------------------
XC
XC  PROGRAMMING NOTES: 
XC
XC     TO PRODUCE A DOUBLE PRECISION VERSION, SIMPLY: 
XC        A. CHANGE CHFEV TO DCHFEV WHEREVER IT OCCURS,
XC        B. CHANGE THE REAL DECLARATION TO DOUBLE PRECISION,
XC        C. CHANGE THE CONSTANT ZERO TO DOUBLE PRECISION, AND
XC        D. CHANGE THE NAMES OF THE FORTRAN FUNCTIONS:  AMAX1, AMIN1.
XC
XC  DECLARE ARGUMENTS.
XC
X      INTEGER  NE, NEXT(2), IERR
X      REAL  X1, X2, F1, F2, D1, D2, XE(NE), FE(NE)
XC
XC  DECLARE LOCAL VARIABLES.
XC
X      INTEGER  I
X      REAL  C2, C3, DEL1, DEL2, DELTA, H, X, XMI, XMA, ZERO
X      DATA  ZERO /0./
XC
XC  VALIDITY-CHECK ARGUMENTS.
XC
XC***FIRST EXECUTABLE STATEMENT  CHFEV
X      IF (NE .LT. 1)  GO TO 5001
X      H = X2 - X1
X      IF (H .EQ. ZERO)  GO TO 5002
XC
XC  INITIALIZE.
XC
X      IERR = 0
X      NEXT(1) = 0
X      NEXT(2) = 0
X      XMI = AMIN1(ZERO, H)
X      XMA = AMAX1(ZERO, H)
XC
XC  COMPUTE CUBIC COEFFICIENTS (EXPANDED ABOUT X1).
XC
X      DELTA = (F2 - F1)/H
X      DEL1 = (D1 - DELTA)/H
X      DEL2 = (D2 - DELTA)/H
XC                                           (DELTA IS NO LONGER NEEDED.)
X      C2 = -(DEL1+DEL1 + DEL2)
X      C3 = (DEL1 + DEL2)/H
XC                               (H, DEL1 AND DEL2 ARE NO LONGER NEEDED.)
XC
XC  EVALUATION LOOP.
XC
X      DO 500  I = 1, NE
X         X = XE(I) - X1
X         FE(I) = F1 + X*(D1 + X*(C2 + X*C3))
XC          COUNT EXTRAPOLATION POINTS.
X         IF ( X.LT.XMI )  NEXT(1) = NEXT(1) + 1
X         IF ( X.GT.XMA )  NEXT(2) = NEXT(2) + 1
XC        (NOTE REDUNDANCY--IF EITHER CONDITION IS TRUE, OTHER IS FALSE.)
X  500 CONTINUE
XC
XC  NORMAL RETURN.
XC
X      RETURN
XC
XC  ERROR RETURNS.
XC
X 5001 CONTINUE
XC     NE.LT.1 RETURN.
X      IERR = -1
X      CALL XERROR ('CHFEV -- NUMBER OF EVALUATION POINTS LESS THAN ONE'
X     *           , 50, IERR, 1)
X      RETURN
XC
X 5002 CONTINUE
XC     X1.EQ.X2 RETURN.
X      IERR = -2
X      CALL XERROR ('CHFEV -- INTERVAL ENDPOINTS EQUAL'
X     *           , 33, IERR, 1)
X      RETURN
XC------------- LAST LINE OF CHFEV FOLLOWS ------------------------------
X      END
END_OF_FILE
if test 15065 -ne `wc -c <'pchfe.f'`; then
    echo shar: \"'pchfe.f'\" unpacked with wrong size!
fi
# end of 'pchfe.f'
fi
if test -f 'savenv.f' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'savenv.f'\"
else
echo shar: Extracting \"'savenv.f'\" \(8362 characters\)
sed "s/^X//" >'savenv.f' <<'END_OF_FILE'
X      SUBROUTINE SAVENV(FILNAM,FULLEN,NAMLEN,TOL1,TOL2,N,X,
X     +                  NTENV,XTENV,YTENV,NBENV,XBENV,YBENV,
X     +                  NTTAN,XTTAN,YTTAN,NBTAN,XBTAN,YBTAN)
XC
XC --- THIS SUBROUTINE SAVES THE RESULTS OF THE ENVELOPE COMPUTATIONS IN
XC     TWO FILES.  A FILE WITH EXTENSION ".ENV" CONTAINS THE TOP AND
XC     BOTTOM ENVELOPE VALUES FOR EACH X VALUE IN THE ORIGINAL DATA FILE
XC     (WITH AN OPTION TO SKIP OVER SOME X VALUES).  A FILE WITH
XC     EXTENSION ".TAN" CONTAINS THE X VALUES FOR EACH TANGENT POINT
XC     BETWEEN THE DATA CURVE AND THE ENVELOPE CURVES, ALONG WITH THE
XC     CORRESPONDING TOP AND BOTTOM ENVELOPE VALUES.
XC
XC --- DESCRIPTION OF INPUT VARIABLES
XC     FILNAM:       FULL NAME OF USER'S INPUT DATA FILE
XC     FULLEN:       NUMBER OF CHARACTERS IN FULL FILE NAME
XC     NAMLEN:       NUMBER OF CHARACTERS IN FILE NAME, NOT INCLUDING
XC                   EXTENSION
XC     TOL1:         TOLERANCE PARAMETER FOR INITIAL DATA SMOOTHING
XC     TOL2:         TOLERANCE PARAMETER FOR FINAL DATA SMOOTHING
XC     N:            NUMBER OF DATA POINTS IN USER'S INPUT FILE
XC     X(N):         ARRAY CONTAINING X COORDINATES OF USER'S DATA
XC     NTENV:        NUMBER OF CALCULATED POINTS IN TOP ENVELOPE
XC     XTENV(NTENV): ARRAY CONTAINING X COORDINATES OF TOP ENVELOPE
XC                   POINTS
XC     YTENV(NTENV): ARRAY CONTAINING Y COORDINATES OF TOP ENVELOPE
XC                   POINTS
XC     NBENV:        NUMBER OF CALCULATED POINTS IN BOTTOM ENVELOPE
XC     XBENV(NBENV): ARRAY CONTAINING X COORDINATES OF BOTTOM ENVELOPE
XC                   POINTS
XC     YBENV(NBENV): ARRAY CONTAINING Y COORDINATES OF BOTTOM ENVELOPE
XC                   POINTS
XC     NTTAN:        NUMBER OF TANGENT POINTS BETWEEN TOP ENVELOPE AND
XC                   DATA CURVE
XC     XTTAN(NTTAN): ARRAY CONTAINING X COORDINATES OF TOP ENVELOPE
XC                   TANGENT POINTS
XC     YTTAN(NTTAN): ARRAY CONTAINING Y COORDINATES OF TOP ENVELOPE
XC                   TANGENT POINTS
XC     NBTAN:        NUMBER OF TANGENT POINTS BETWEEN BOTTOM ENVELOPE AND
XC                   DATA CURVE
XC     XBTAN(NBTAN): ARRAY CONTAINING X COORDINATES OF BOTTOM ENVELOPE
XC                   TANGENT POINTS
XC     YBTAN(NBTAN): ARRAY CONTAINING Y COORDINATES OF BOTTOM ENVELOPE
XC                   TANGENT POINTS
XC
XC --- DECLARATION OF CALLING SEQUENCE VARIABLES
X      CHARACTER FILNAM*20
X      INTEGER FULLEN,NAMLEN,N,NTENV,NBENV,NTTAN,NBTAN
X      REAL TOL1,TOL2,X(*),XTENV(*),YTENV(*),XBENV(*),YBENV(*),XTTAN(*),
X     +     YTTAN(*),XBTAN(*),YBTAN(*)
XC
XC --- DECLARATION OF INTERNAL VARIABLES
X      CHARACTER ANSWER*1,FILE2*20,FILE3*20
X      INTEGER I,STEP,LENGTH,OFFSET,TCOUNT,BCOUNT,TPNTR,BPNTR
XC
XC --- SAVE ENVELOPE DATA IN ".ENV" FILE
X      FILE2=FILNAM(1:NAMLEN)//'.env'
X      LENGTH=NAMLEN+4
X      OPEN(2,FILE=FILE2,STATUS='UNKNOWN')
X      PRINT *,'Do you want to save envelope values for every x ',
X     +        'value in your '
X      PRINT *,'original data file (Y/N)? '
X      READ(*,2000)ANSWER
X 2000 FORMAT(A)
X      IF(ANSWER.EQ.'Y'.OR.ANSWER.EQ.'y')THEN
X         STEP=1
X      ELSE
X         PRINT *,'Enter an increment for stepping through the x ',
X     +           'values in your file: '
X         READ(*,*)STEP
X      ENDIF
X      CALL SEARCH(XTENV(1),N,X,TCOUNT)
X      IF(TCOUNT.EQ.0)THEN
X         PRINT *,'ERROR: X value',XTENV(1),' not found in original ',
X     +           'data --'
X         PRINT *,'       Contact programmer for correction.'
X      ENDIF
X      OFFSET=MOD(TCOUNT,STEP)
X      TCOUNT=MOD(STEP-OFFSET+1,STEP)+1
X      IF(TCOUNT.GT.NTENV)TCOUNT=1
X      CALL SEARCH(XBENV(1),N,X,BCOUNT)
X      IF(BCOUNT.EQ.0)THEN
X         PRINT *,'ERROR: X value',XBENV(1),' not found in original ',
X     +           'data --'
X         PRINT *,'       Contact programmer for correction.'
X      ENDIF
X      OFFSET=MOD(BCOUNT,STEP)
X      BCOUNT=MOD(STEP-OFFSET+1,STEP)+1
X      IF(BCOUNT.GT.NBENV)BCOUNT=1
X      DO 2400 I=1,N,STEP
X         IF(XTENV(TCOUNT).EQ.X(I))THEN
X            IF(XBENV(BCOUNT).EQ.X(I))THEN
X               WRITE(2,2300)X(I),YTENV(TCOUNT),YBENV(BCOUNT)
X 2300          FORMAT(2X,F8.2,12X,F7.4,12X,F7.4)
X               IF(TCOUNT+STEP.LE.NTENV)TCOUNT=TCOUNT+STEP
X               IF(BCOUNT+STEP.LE.NBENV)BCOUNT=BCOUNT+STEP
X            ELSE
X               WRITE(2,2320)X(I),YTENV(TCOUNT)
X 2320          FORMAT(2X,F8.2,12X,F7.4,14X,''' ''')
X               IF(TCOUNT+STEP.LE.NTENV)TCOUNT=TCOUNT+STEP
X            ENDIF
X         ELSE
X            IF(XBENV(BCOUNT).EQ.X(I))THEN
X               WRITE(2,2350)X(I),YBENV(BCOUNT)
X 2350          FORMAT(2X,F8.2,14X,''' ''',14X,F7.4)
X               IF(BCOUNT+STEP.LE.NBENV)BCOUNT=BCOUNT+STEP
X            ELSE
X               WRITE(2,2380)X(I)
X 2380          FORMAT(2X,F8.2,14X,''' ''',16X,''' ''')
X            ENDIF
X         ENDIF
X 2400 CONTINUE
X      WRITE(2,2450)
X 2450 FORMAT('''',5X,'X',12X,'Top Envelope',6X,'Bottom Envelope''')
X      WRITE(2,*)
X      WRITE(2,*)'''Envelope data generated by program ENVELOPE ',
X     +          'using data from file ',FILNAM(1:FULLEN),''''
X      WRITE(2,2500)TOL1,TOL2
X 2500 FORMAT('''with initial tolerance ',F7.4,' and final ',
X     +       'tolerance ',F7.4,'''')
X      WRITE(2,*)'''(A '' '' entry indicates no envelope point was ',
X     +          'generated.)'''
X      CLOSE(2)
X      PRINT *,'Envelope data saved in file  ',FILE2(1:LENGTH),'.'
XC
XC --- SAVE TANGENT POINT DATA IN ".TAN" FILE
X      FILE3=FILNAM(1:NAMLEN)//'.tan'
X      OPEN(3,FILE=FILE3,STATUS='UNKNOWN')
X      TPNTR=1
X      BPNTR=1
X 2800 CONTINUE
X      IF(TPNTR.NE.NTTAN+1)THEN
X         IF((BPNTR.EQ.NBTAN+1).OR.
X     +     ((BPNTR.NE.NBTAN+1).AND.
X     +     (XTTAN(TPNTR).LT.XBTAN(BPNTR))))THEN
X            CALL SEARCH(XTTAN(TPNTR),NBENV,XBENV,BCOUNT)
X            IF(BCOUNT.EQ.0)THEN
X               WRITE(3,2820)XTTAN(TPNTR),YTTAN(TPNTR)
X 2820          FORMAT(2X,F8.2,12X,F7.4,14X,''' ''')
X            ELSE
X               WRITE(3,2850)XTTAN(TPNTR),YTTAN(TPNTR),
X     +            YBENV(BCOUNT)
X 2850          FORMAT(2X,F8.2,12X,F7.4,12X,F7.4)
X            ENDIF
X            TPNTR=TPNTR+1
X            GOTO 2800
X         ENDIF
X      ENDIF
X      IF(BPNTR.NE.NBTAN+1)THEN
X         IF((TPNTR.EQ.NTTAN+1).OR.
X     +     ((TPNTR.NE.NTTAN+1).AND.
X     +      (XTTAN(TPNTR).GE.XBTAN(BPNTR))))THEN
X            CALL SEARCH(XBTAN(BPNTR),NTENV,XTENV,TCOUNT)
X            IF(TCOUNT.EQ.0)THEN
X               WRITE(3,2880)XBTAN(BPNTR),YBTAN(BPNTR)
X 2880          FORMAT(2X,F8.2,14X,''' ''',14X,F7.4)
X            ELSE
X               WRITE(3,2850)XBTAN(BPNTR),YTENV(TCOUNT),
X     +            YBTAN(BPNTR)
X            ENDIF
X            BPNTR=BPNTR+1
X            GOTO 2800
X         ENDIF
X      ENDIF
X      IF((TPNTR.NE.NTTAN+1).OR.(BPNTR.NE.NBTAN+1))THEN
X         PRINT *,'ERROR: Incorrect merge of tangent points --'
X         PRINT *,'       Contact programmer for correction.'
X      ENDIF
X      WRITE(3,2900)
X 2900 FORMAT('''',5X,'X',17X,'Tmax',15X,'Tmin''')
X      WRITE(3,*)
X      WRITE(3,*)'''Tangent data generated by program ENVELOPE ',
X     +          'using data from file ',FILNAM(1:FULLEN),''''
X      WRITE(3,2500)TOL1,TOL2
X      CLOSE(3)
X      PRINT *,'Tangent points saved in file ',FILE3(1:LENGTH),'.'
XC
X      RETURN
X      END
XC
XC     ******************************************************************
XC
X      SUBROUTINE SEARCH(X,N,LIST,POS)
XC
XC --- THIS SUBROUTINE PERFORMS A BINARY LIST SEARCH.
XC
XC --- INPUT VARIABLES
XC     X:       VALUE TO SEARCH FOR
XC     N:       NUMBER OF ITEMS IN LIST
XC     LIST(N): ARRAY CONTAINING LIST ITEMS, IN INCREASING ORDER
XC
XC --- OUTPUT VARIABLE
XC     POS:     POSITION OF X IN LIST -- LIST(POS)=X
XC              (POS=0 IF X WAS NOT FOUND)
XC
XC --- DECLARATION OF CALLING SEQUENCE VARIABLES
X      INTEGER N,POS
X      REAL X,LIST(*)
XC
XC --- DECLARATION OF INTERNAL VARIABLES
X      INTEGER LEFT,RIGHT,MIDPT
XC
XC --- SEARCH FOR X IN LIST
X      POS=0
X      LEFT=1
X      RIGHT=N
X      IF((X.LT.LIST(1)).OR.(X.GT.LIST(N)))RETURN
X  100 CONTINUE
X      IF(LEFT.LT.RIGHT)THEN
X         MIDPT=(LEFT+RIGHT)/2.
X         IF(X.EQ.LIST(MIDPT))THEN
X            POS=MIDPT
X            RETURN
X         ELSEIF(X.LT.LIST(MIDPT))THEN
X            RIGHT=MIDPT
X         ELSE
X            LEFT=MIDPT
X         ENDIF
X         GOTO 100
X      ELSEIF(LEFT.EQ.RIGHT)THEN
X         MIDPT=LEFT
X         IF(X.EQ.LIST(MIDPT))THEN
X            POS=MIDPT
X            RETURN
X         ENDIF
X      ENDIF
XC
X      RETURN
X      END
END_OF_FILE
if test 8362 -ne `wc -c <'savenv.f'`; then
    echo shar: \"'savenv.f'\" unpacked with wrong size!
fi
# end of 'savenv.f'
fi
if test -f 'r1mach.f' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'r1mach.f'\"
else
echo shar: Extracting \"'r1mach.f'\" \(12723 characters\)
sed "s/^X//" >'r1mach.f' <<'END_OF_FILE'
X      REAL FUNCTION R1MACH(I)
XC***BEGIN PROLOGUE  R1MACH
XC***DATE WRITTEN   790101   (YYMMDD)
XC***REVISION DATE  910131   (YYMMDD)
XC***CATEGORY NO.  R1
XC***KEYWORDS  MACHINE CONSTANTS
XC***AUTHOR  FOX, P. A., (BELL LABS)
XC           HALL, A. D., (BELL LABS)
XC           SCHRYER, N. L., (BELL LABS)
XC***PURPOSE  Returns single precision machine dependent constants
XC***DESCRIPTION
XC
XC     This is the CMLIB version of R1MACH, the real machine
XC     constants subroutine originally developed for the PORT library.
XC
XC     R1MACH can be used to obtain machine-dependent parameters
XC     for the local machine environment.  It is a function
XC     subroutine with one (input) argument, and can be called
XC     as follows, for example
XC
XC          A = R1MACH(I)
XC
XC     where I=1,...,5.  The (output) value of A above is
XC     determined by the (input) value of I.  The results for
XC     various values of I are discussed below.
XC
XC  Single-Precision Machine Constants
XC  R1MACH(1) = B**(EMIN-1), the smallest positive magnitude.
XC  R1MACH(2) = B**EMAX*(1 - B**(-T)), the largest magnitude.
XC  R1MACH(3) = B**(-T), the smallest relative spacing.
XC  R1MACH(4) = B**(1-T), the largest relative spacing.
XC  R1MACH(5) = LOG10(B)
XC***REFERENCES  FOX, P.A., HALL, A.D., SCHRYER, N.L, *FRAMEWORK FOR
XC                 A PORTABLE LIBRARY*, ACM TRANSACTIONS ON MATHE-
XC                 MATICAL SOFTWARE, VOL. 4, NO. 2, JUNE 1978,
XC                 PP. 177-188.
XC***ROUTINES CALLED  XERROR
XC***END PROLOGUE  R1MACH
XC
X      INTEGER SMALL(2)
X      INTEGER LARGE(2)
X      INTEGER RIGHT(2)
X      INTEGER DIVER(2)
X      INTEGER LOG10(2)
XC
X      REAL RMACH(5)
XC
X      EQUIVALENCE (RMACH(1),SMALL(1))
X      EQUIVALENCE (RMACH(2),LARGE(1))
X      EQUIVALENCE (RMACH(3),RIGHT(1))
X      EQUIVALENCE (RMACH(4),DIVER(1))
X      EQUIVALENCE (RMACH(5),LOG10(1))
XC
XC
XC     MACHINE CONSTANTS FOR IEEE ARITHMETIC MACHINES, SUCH AS THE AT&T
XC     3B SERIES, MOTOROLA 68000 BASED MACHINES (E.G. SUN 3 AND AT&T
XC     PC 7300), AND 8087 BASED MICROS (E.G. IBM PC AND AT&T 6300).
XC
XC === MACHINE = IEEE.MOST-SIG-BYTE-FIRST
XC === MACHINE = IEEE.LEAST-SIG-BYTE-FIRST
XC === MACHINE = SUN
XC === MACHINE = 68000
XC === MACHINE = 8087
XC === MACHINE = IBM.PC
XC === MACHINE = ATT.3B
XC === MACHINE = ATT.6300
XC === MACHINE = ATT.7300
X       DATA SMALL(1) /     8388608 /
X       DATA LARGE(1) /  2139095039 /
X       DATA RIGHT(1) /   864026624 /
X       DATA DIVER(1) /   872415232 /
X       DATA LOG10(1) /  1050288283 /
XC
XC     MACHINE CONSTANTS FOR AMDAHL MACHINES.
XC
XC === MACHINE = AMDAHL
XC      DATA SMALL(1) /    1048576 /
XC      DATA LARGE(1) / 2147483647 /
XC      DATA RIGHT(1) /  990904320 /
XC      DATA DIVER(1) / 1007681536 /
XC      DATA LOG10(1) / 1091781651 /
XC
XC     MACHINE CONSTANTS FOR THE BURROUGHS 1700 SYSTEM.
XC
XC === MACHINE = BURROUGHS.1700
XC      DATA RMACH(1) / Z400800000 /
XC      DATA RMACH(2) / Z5FFFFFFFF /
XC      DATA RMACH(3) / Z4E9800000 /
XC      DATA RMACH(4) / Z4EA800000 /
XC      DATA RMACH(5) / Z500E730E8 /
XC
XC     MACHINE CONSTANTS FOR THE BURROUGHS 5700/6700/7700 SYSTEMS.
XC
XC === MACHINE = BURROUGHS.5700
XC === MACHINE = BURROUGHS.6700
XC === MACHINE = BURROUGHS.7700
XC      DATA RMACH(1) / O1771000000000000 /
XC      DATA RMACH(2) / O0777777777777777 /
XC      DATA RMACH(3) / O1311000000000000 /
XC      DATA RMACH(4) / O1301000000000000 /
XC      DATA RMACH(5) / O1157163034761675 /
XC
XC     MACHINE CONSTANTS FOR THE CONVEX C-120 (NATIVE MODE)
XC
XC === MACHINE = CONVEX.C1
XC      DATA RMACH(1) / 2.9387360E-39 /
XC      DATA RMACH(2) / 1.7014117E+38 /
XC      DATA RMACH(3) / 5.9604645E-08 /
XC      DATA RMACH(4) / 1.1920929E-07 /
XC      DATA RMACH(5) / 3.0102999E-01 /
XC
XC     MACHINE CONSTANTS FOR THE CONVEX C-120 (NATIVE MODE)
XC     WITH -R8 OPTION
XC
XC === MACHINE = CONVEX.C1.R8
XC      DATA RMACH(1) / 5.562684646268007D-309 /
XC      DATA RMACH(2) / 8.988465674311577D+307 /
XC      DATA RMACH(3) / 1.110223024625157D-016 /
XC      DATA RMACH(4) / 2.220446049250313D-016 /
XC      DATA RMACH(5) / 3.010299956639812D-001 /
XC
XC     MACHINE CONSTANTS FOR THE CONVEX C-120 (IEEE MODE)
XC
XC === MACHINE = CONVEX.C1.IEEE
XC      DATA RMACH(1) / 1.1754945E-38 /
XC      DATA RMACH(2) / 3.4028234E+38 /
XC      DATA RMACH(3) / 5.9604645E-08 /
XC      DATA RMACH(4) / 1.1920929E-07 /
XC      DATA RMACH(5) / 3.0102999E-01 /
XC
XC     MACHINE CONSTANTS FOR THE CONVEX C-120 (IEEE MODE)
XC     WITH -R8 OPTION
XC
XC === MACHINE = CONVEX.C1.IEEE.R8
XC      DATA RMACH(1) / 2.225073858507202D-308 /
XC      DATA RMACH(2) / 1.797693134862315D+308 /
XC      DATA RMACH(3) / 1.110223024625157D-016 /
XC      DATA RMACH(4) / 2.220446049250313D-016 /
XC      DATA RMACH(5) / 3.010299956639812D-001 /
XC
XC     MACHINE CONSTANTS FOR THE CYBER 170/180 SERIES USING NOS (FTN5).
XC
XC === MACHINE = CYBER.170.NOS
XC === MACHINE = CYBER.180.NOS
XC      DATA RMACH(1) / O"00014000000000000000" /
XC      DATA RMACH(2) / O"37767777777777777777" /
XC      DATA RMACH(3) / O"16404000000000000000" /
XC      DATA RMACH(4) / O"16414000000000000000" /
XC      DATA RMACH(5) / O"17164642023241175720" /
XC
XC     MACHINE CONSTANTS FOR THE CDC 180 SERIES USING NOS/VE
XC
XC === MACHINE = CYBER.180.NOS/VE
XC      DATA RMACH(1) / Z"3001800000000000" /
XC      DATA RMACH(2) / Z"4FFEFFFFFFFFFFFE" /
XC      DATA RMACH(3) / Z"3FD2800000000000" /
XC      DATA RMACH(4) / Z"3FD3800000000000" /
XC      DATA RMACH(5) / Z"3FFF9A209A84FBCF" /
XC
XC     MACHINE CONSTANTS FOR THE CYBER 205
XC
XC === MACHINE = CYBER.205
XC      DATA RMACH(1) / X'9000400000000000' /
XC      DATA RMACH(2) / X'6FFF7FFFFFFFFFFF' /
XC      DATA RMACH(3) / X'FFA3400000000000' /
XC      DATA RMACH(4) / X'FFA4400000000000' /
XC      DATA RMACH(5) / X'FFD04D104D427DE8' /
XC
XC     MACHINE CONSTANTS FOR THE CDC 6000/7000 SERIES.
XC
XC === MACHINE = CDC.6000
XC === MACHINE = CDC.7000
XC      DATA RMACH(1) / 00014000000000000000B /
XC      DATA RMACH(2) / 37767777777777777777B /
XC      DATA RMACH(3) / 16404000000000000000B /
XC      DATA RMACH(4) / 16414000000000000000B /
XC      DATA RMACH(5) / 17164642023241175720B /
XC
XC     MACHINE CONSTANTS FOR THE CRAY 1, XMP, 2, AND 3.
XC
XC === MACHINE = CRAY.46-BIT-INTEGER
XC === MACHINE = CRAY.64-BIT-INTEGER
XC      DATA RMACH(1) / 200034000000000000000B /
XC      DATA RMACH(2) / 577767777777777777776B /
XC      DATA RMACH(3) / 377224000000000000000B /
XC      DATA RMACH(4) / 377234000000000000000B /
XC      DATA RMACH(5) / 377774642023241175720B /
XC
XC     MACHINE CONSTANTS FOR THE DATA GENERAL ECLIPSE S/200
XC
XC     NOTE - IT MAY BE APPROPRIATE TO INCLUDE THE FOLLOWING LINE -
XC     STATIC RMACH(5)
XC
XC === MACHINE = DATA_GENERAL.ECLIPSE.S/200
XC      DATA SMALL/20K,0/,LARGE/77777K,177777K/
XC      DATA RIGHT/35420K,0/,DIVER/36020K,0/
XC      DATA LOG10/40423K,42023K/
XC
XC     ELXSI 6400
XC
XC === MACHINE = ELSXI.6400
XC      DATA SMALL(1) / '00800000'X /
XC      DATA LARGE(1) / '7F7FFFFF'X /
XC      DATA RIGHT(1) / '33800000'X /
XC      DATA DIVER(1) / '34000000'X /
XC      DATA LOG10(1) / '3E9A209B'X /
XC
XC     MACHINE CONSTANTS FOR THE HARRIS 220
XC     MACHINE CONSTANTS FOR THE HARRIS SLASH 6 AND SLASH 7
XC
XC === MACHINE = HARRIS.220
XC === MACHINE = HARRIS.SLASH6
XC === MACHINE = HARRIS.SLASH7
XC      DATA SMALL(1),SMALL(2) / '20000000, '00000201 /
XC      DATA LARGE(1),LARGE(2) / '37777777, '00000177 /
XC      DATA RIGHT(1),RIGHT(2) / '20000000, '00000352 /
XC      DATA DIVER(1),DIVER(2) / '20000000, '00000353 /
XC      DATA LOG10(1),LOG10(2) / '23210115, '00000377 /
XC
XC     MACHINE CONSTANTS FOR THE HONEYWELL 600/6000 SERIES.
XC     MACHINE CONSTANTS FOR THE HONEYWELL DPS 8/70 SERIES.
XC
XC === MACHINE = HONEYWELL.600/6000
XC === MACHINE = HONEYWELL.DPS.8/70
XC      DATA RMACH(1) / O402400000000 /
XC      DATA RMACH(2) / O376777777777 /
XC      DATA RMACH(3) / O714400000000 /
XC      DATA RMACH(4) / O716400000000 /
XC      DATA RMACH(5) / O776464202324 /
XC
XC     MACHINE CONSTANTS FOR THE HP 2100
XC     3 WORD DOUBLE PRECISION WITH FTN4
XC
XC === MACHINE = HP.2100.3_WORD_DP
XC      DATA SMALL(1), SMALL(2) / 40000B,       1 /
XC      DATA LARGE(1), LARGE(2) / 77777B, 177776B /
XC      DATA RIGHT(1), RIGHT(2) / 40000B,    325B /
XC      DATA DIVER(1), DIVER(2) / 40000B,    327B /
XC      DATA LOG10(1), LOG10(2) / 46420B,  46777B /
XC
XC     MACHINE CONSTANTS FOR THE HP 2100
XC     4 WORD DOUBLE PRECISION WITH FTN4
XC
XC === MACHINE = HP.2100.4_WORD_DP
XC      DATA SMALL(1), SMALL(2) / 40000B,       1 /
XC      DATA LARGE91), LARGE(2) / 77777B, 177776B /
XC      DATA RIGHT(1), RIGHT(2) / 40000B,    325B /
XC      DATA DIVER(1), DIVER(2) / 40000B,    327B /
XC      DATA LOG10(1), LOG10(2) / 46420B,  46777B /
XC
XC     HP 9000
XC
XC      R1MACH(1) = 1.17549435E-38
XC      R1MACH(2) = 1.70141163E+38
XC      R1MACH(3) = 5.960464478E-8
XC      R1MACH(4) = 1.119209290E-7
XC      R1MACH(5) = 3.01030010E-1
XC
XC === MACHINE = HP.9000
XC      DATA SMALL(1) / 00040000000B /
XC      DATA LARGE(1) / 17677777777B /
XC      DATA RIGHT(1) / 06340000000B /
XC      DATA DIVER(1) / 06400000000B /
XC      DATA LOG10(1) / 07646420233B /
XC
XC     MACHINE CONSTANTS FOR THE IBM 360/370 SERIES,
XC     THE XEROX SIGMA 5/7/9, THE SEL SYSTEMS 85/86 AND
XC     THE INTERDATA 3230 AND INTERDATA 7/32.
XC
XC === MACHINE = IBM.360
XC === MACHINE = IBM.370
XC === MACHINE = XEROX.SIGMA.5
XC === MACHINE = XEROX.SIGMA.7
XC === MACHINE = XEROX.SIGMA.9
XC === MACHINE = SEL.85
XC === MACHINE = SEL.86
XC === MACHINE = INTERDATA.3230
XC === MACHINE = INTERDATA.7/32
XC      DATA RMACH(1) / Z00100000 /
XC      DATA RMACH(2) / Z7FFFFFFF /
XC      DATA RMACH(3) / Z3B100000 /
XC      DATA RMACH(4) / Z3C100000 /
XC      DATA RMACH(5) / Z41134413 /
XC
XC     MACHINE CONSTANTS FOR THE INTERDATA 8/32
XC     WITH THE UNIX SYSTEM FORTRAN 77 COMPILER.
XC
XC     FOR THE INTERDATA FORTRAN VII COMPILER REPLACE
XC     THE Z'S SPECIFYING HEX CONSTANTS WITH Y'S.
XC
XC === MACHINE = INTERDATA.8/32.UNIX
XC      DATA RMACH(1) / Z'00100000' /
XC      DATA RMACH(2) / Z'7EFFFFFF' /
XC      DATA RMACH(3) / Z'3B100000' /
XC      DATA RMACH(4) / Z'3C100000' /
XC      DATA RMACH(5) / Z'41134413' /
XC
XC     MACHINE CONSTANTS FOR THE PDP-10 (KA OR KI PROCESSOR).
XC
XC === MACHINE = PDP-10.KA
XC === MACHINE = PDP-10.KI
XC      DATA RMACH(1) / "000400000000 /
XC      DATA RMACH(2) / "377777777777 /
XC      DATA RMACH(3) / "146400000000 /
XC      DATA RMACH(4) / "147400000000 /
XC      DATA RMACH(5) / "177464202324 /
XC
XC     MACHINE CONSTANTS FOR PDP-11 FORTRAN SUPPORTING
XC     32-BIT INTEGERS (EXPRESSED IN INTEGER AND OCTAL).
XC
XC === MACHINE = PDP-11.32-BIT
XC      DATA SMALL(1) /    8388608 /
XC      DATA LARGE(1) / 2147483647 /
XC      DATA RIGHT(1) /  880803840 /
XC      DATA DIVER(1) /  889192448 /
XC      DATA LOG10(1) / 1067065499 /
XC
XC      DATA RMACH(1) / O00040000000 /
XC      DATA RMACH(2) / O17777777777 /
XC      DATA RMACH(3) / O06440000000 /
XC      DATA RMACH(4) / O06500000000 /
XC      DATA RMACH(5) / O07746420233 /
XC
XC     MACHINE CONSTANTS FOR PDP-11 FORTRAN SUPPORTING
XC     16-BIT INTEGERS  (EXPRESSED IN INTEGER AND OCTAL).
XC
XC === MACHINE = PDP-11.16-BIT
XC      DATA SMALL(1),SMALL(2) /   128,     0 /
XC      DATA LARGE(1),LARGE(2) / 32767,    -1 /
XC      DATA RIGHT(1),RIGHT(2) / 13440,     0 /
XC      DATA DIVER(1),DIVER(2) / 13568,     0 /
XC      DATA LOG10(1),LOG10(2) / 16282,  8347 /
XC
XC      DATA SMALL(1),SMALL(2) / O000200, O000000 /
XC      DATA LARGE(1),LARGE(2) / O077777, O177777 /
XC      DATA RIGHT(1),RIGHT(2) / O032200, O000000 /
XC      DATA DIVER(1),DIVER(2) / O032400, O000000 /
XC      DATA LOG10(1),LOG10(2) / O037632, O020233 /
XC
XC     MACHINE CONSTANTS FOR THE SEQUENT BALANCE 8000.
XC
XC === MACHINE = SEQUENT.BALANCE.8000
XC      DATA SMALL(1) / $00800000 /
XC      DATA LARGE(1) / $7F7FFFFF /
XC      DATA RIGHT(1) / $33800000 /
XC      DATA DIVER(1) / $34000000 /
XC      DATA LOG10(1) / $3E9A209B /
XC
XC     MACHINE CONSTANTS FOR THE UNIVAC 1100 SERIES.
XC
XC === MACHINE = UNIVAC.1100
XC      DATA RMACH(1) / O000400000000 /
XC      DATA RMACH(2) / O377777777777 /
XC      DATA RMACH(3) / O146400000000 /
XC      DATA RMACH(4) / O147400000000 /
XC      DATA RMACH(5) / O177464202324 /
XC
XC     MACHINE CONSTANTS FOR THE VAX 11/780
XC    (EXPRESSED IN INTEGER AND HEXADECIMAL)
XC  *** THE INTEGER FORMAT SHOULD BE OK FOR UNIX SYSTEMS***
XC
XC === MACHINE = VAX.11/780
XC      DATA SMALL(1) /       128 /
XC      DATA LARGE(1) /    -32769 /
XC      DATA RIGHT(1) /     13440 /
XC      DATA DIVER(1) /     13568 /
XC      DATA LOG10(1) / 547045274 /
XC
XC  ***THE HEX FORMAT BELOW MAY NOT BE SUITABLE FOR UNIX SYSTEMS***
XC
XC      DATA SMALL(1) / Z00000080 /
XC      DATA LARGE(1) / ZFFFF7FFF /
XC      DATA RIGHT(1) / Z00003480 /
XC      DATA DIVER(1) / Z00003500 /
XC      DATA LOG10(1) / Z209B3F9A /
XC
XC
XC***FIRST EXECUTABLE STATEMENT  R1MACH
X      IF (I .LT. 1  .OR.  I .GT. 5)
X     1   CALL XERROR ( 'R1MACH -- I OUT OF BOUNDS',25,1,2)
XC
X      R1MACH = RMACH(I)
X      RETURN
XC
X      END
END_OF_FILE
if test 12723 -ne `wc -c <'r1mach.f'`; then
    echo shar: \"'r1mach.f'\" unpacked with wrong size!
fi
# end of 'r1mach.f'
fi
if test -f 'test.dat' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'test.dat'\"
else
echo shar: Extracting \"'test.dat'\" \(18042 characters\)
sed "s/^X//" >'test.dat' <<'END_OF_FILE'
X 2997.5        69.8 
X 3002.5        70 
X 3007.5        70.1 
X 3012.5        70.4 
X 3017.5        70.625 
X 3022.5        70.825 
X 3027.5        71.125 
X 3032.5        71.25 
X 3037.5        71.05 
X 3042.5        71.4 
X 3047.5        71.575 
X 3052.5        71.6 
X 3057.5        71.575 
X 3062.5        71.60001 
X 3067.5        71.7 
X 3072.5        71.725 
X 3077.5        71.75 
X 3082.5        71.8 
X 3087.5        71.775 
X 3092.5        71.7 
X 3097.5        71.725 
X 3102.5        71.625 
X 3107.5        71.55 
X 3112.5        71.525 
X 3117.5        71.45 
X 3122.5        71.3 
X 3127.5        71.175 
X 3132.5        71 
X 3137.5        70.875 
X 3142.5        70.7 
X 3147.5        70.675 
X 3152.5        70.525 
X 3157.5        70.45 
X 3162.5        70.15 
X 3167.5        70.05 
X 3172.5        70.025 
X 3177.5        69.75 
X 3182.5        69.5 
X 3187.5        69.425 
X 3192.5        69.22501 
X 3197.5        69.05 
X 3202.5        68.925 
X 3207.5        68.8 
X 3212.5        68.5 
X 3217.5        68.45 
X 3222.5        68.325 
X 3227.5        68.125 
X 3232.5        67.95 
X 3237.5        67.875 
X 3242.5        67.8 
X 3247.5        67.9 
X 3252.5        67.55 
X 3257.5        67.575 
X 3262.5        67.5 
X 3267.5        67.45 
X 3272.5        67.375 
X 3277.5        67.25 
X 3282.5        67.375 
X 3287.5        67.375 
X 3292.5        67.025 
X 3297.5        67.3 
X 3302.5        67.375 
X 3307.5        67.225 
X 3312.5        67.225 
X 3317.5        67.525 
X 3322.5        67.325 
X 3327.5        67.65 
X 3332.5        67.65 
X 3337.5        67.825 
X 3342.5        67.875 
X 3347.5        68.05 
X 3352.5        68.1 
X 3357.5        68.25 
X 3362.5        68.375 
X 3367.5        68.47501 
X 3372.5        68.75 
X 3377.5        68.925 
X 3382.5        69.1 
X 3387.5        69.35 
X 3392.5        69.475 
X 3397.5        69.8 
X 3402.5        69.85001 
X 3407.5        70.375 
X 3412.5        70.525 
X 3417.5        70.65 
X 3422.5        70.9 
X 3427.5        71.15 
X 3432.5        71.55 
X 3437.5        71.775 
X 3442.5        71.9 
X 3447.5        72.22501 
X 3452.5        72.625 
X 3457.5        72.925 
X 3462.5        72.975 
X 3467.5        73.35 
X 3472.5        73.675 
X 3477.5        74 
X 3482.5        74.4 
X 3487.5        74.475 
X 3492.5        74.875 
X 3497.5        75.05 
X 3502.5        75.375 
X 3507.5        75.6 
X 3512.5        75.775 
X 3517.5        76.025 
X 3522.5        76.375 
X 3527.5        76.575 
X 3532.5        76.775 
X 3537.5        77.075 
X 3542.5        77.25 
X 3547.5        77.475 
X 3552.5        77.675 
X 3557.5        77.975 
X 3562.5        78.125 
X 3567.5        78.375 
X 3572.5        78.425 
X 3577.5        78.625 
X 3582.5        78.775 
X 3587.5        78.85 
X 3592.5        79.05 
X 3597.5        79.125 
X 3602.5        79.275 
X 3607.5        79.475 
X 3612.5        79.375 
X 3617.5        79.47501 
X 3622.5        79.6 
X 3627.5        79.675 
X 3632.5        79.55 
X 3637.5        79.75 
X 3642.5        79.675 
X 3647.5        79.5 
X 3652.5        79.65 
X 3657.5        79.775 
X 3662.5        79.575 
X 3667.5        79.6 
X 3672.5        79.525 
X 3677.5        79.6 
X 3682.5        79.525 
X 3687.5        79.45 
X 3692.5        79.35001 
X 3697.5        79.2 
X 3702.5        79.1 
X 3707.5        79.1 
X 3712.5        79.025 
X 3717.5        78.95 
X 3722.5        78.65 
X 3727.5        78.55 
X 3732.5        78.425 
X 3737.5        78.425 
X 3742.5        78.1 
X 3747.5        77.97501 
X 3752.5        77.925 
X 3757.5        77.8 
X 3762.5        77.7 
X 3767.5        77.525 
X 3772.5        77.375 
X 3777.5        77.22501 
X 3782.5        77.125 
X 3787.5        77 
X 3792.5        76.75 
X 3797.5        76.625 
X 3802.5        76.475 
X 3807.5        76.35 
X 3812.5        76.325 
X 3817.5        76.1 
X 3822.5        75.95 
X 3827.5        75.85001 
X 3832.5        75.65 
X 3837.5        75.5 
X 3842.5        75.425 
X 3847.5        75.325 
X 3852.5        75.225 
X 3857.5        75.125 
X 3862.5        74.95 
X 3867.5        74.875 
X 3872.5        74.7 
X 3877.5        74.65 
X 3882.5        74.575 
X 3887.5        74.4 
X 3892.5        74.425 
X 3897.5        74.275 
X 3902.5        74.125 
X 3907.5        74.2 
X 3912.5        74.10001 
X 3917.5        73.9 
X 3922.5        73.9 
X 3927.5        73.975 
X 3932.5        73.85 
X 3937.5        73.925 
X 3942.5        73.85001 
X 3947.5        73.7 
X 3952.5        73.7 
X 3957.5        73.72501 
X 3962.5        73.65 
X 3967.5        73.725 
X 3972.5        73.75 
X 3977.5        73.8 
X 3982.5        73.725 
X 3987.5        73.85001 
X 3992.5        73.9 
X 3997.5        73.8 
X 4002.5        73.85 
X 4007.5        73.975 
X 4012.5        74.025 
X 4017.5        74.075 
X 4022.5        74.225 
X 4027.5        74.2 
X 4032.5        74.225 
X 4037.5        74.275 
X 4042.5        74.425 
X 4047.5        74.55 
X 4052.5        74.625 
X 4057.5        74.65 
X 4062.5        74.775 
X 4067.5        74.9 
X 4072.5        74.95 
X 4077.5        75.075 
X 4082.5        75.275 
X 4087.5        75.425 
X 4092.5        75.575 
X 4097.5        75.725 
X 4102.5        75.9 
X 4107.5        75.975 
X 4112.5        76.175 
X 4117.5        76.225 
X 4122.5        76.35 
X 4127.5        76.55 
X 4132.5        76.7 
X 4137.5        76.85 
X 4142.5        77.075 
X 4147.5        77.275 
X 4152.5        77.4 
X 4157.5        77.47501 
X 4162.5        77.625 
X 4167.5        77.75 
X 4172.5        77.975 
X 4177.5        78.2 
X 4182.5        78.4 
X 4187.5        78.625 
X 4192.5        78.85 
X 4197.5        79.025 
X 4202.5        79.05 
X 4207.5        79.375 
X 4212.5        79.6 
X 4217.5        79.625 
X 4222.5        79.95 
X 4227.5        80.15 
X 4232.5        80.325 
X 4237.5        80.4 
X 4242.5        80.75 
X 4247.5        80.875 
X 4252.5        81.05 
X 4257.5        81.25 
X 4262.5        81.55 
X 4267.5        81.65 
X 4272.5        81.75 
X 4277.5        81.9 
X 4282.5        82.175 
X 4287.5        82.375 
X 4292.5        82.60001 
X 4297.5        82.7 
X 4302.5        82.9 
X 4307.5        83.075 
X 4312.5        83.2 
X 4317.5        83.375 
X 4322.5        83.525 
X 4327.5        83.575 
X 4332.5        83.75 
X 4337.5        83.925 
X 4342.5        84.05 
X 4347.5        84.175 
X 4352.5        84.375 
X 4357.5        84.425 
X 4362.5        84.6 
X 4367.5        84.725 
X 4372.5        84.825 
X 4377.5        85.025 
X 4382.5        85.25 
X 4387.5        85.275 
X 4392.5        85.225 
X 4397.5        85.4 
X 4402.5        85.5 
X 4407.5        85.55 
X 4412.5        85.675 
X 4417.5        85.875 
X 4422.5        85.8 
X 4427.5        85.875 
X 4432.5        85.97501 
X 4437.5        86.02499 
X 4442.5        86.125 
X 4447.5        86.2 
X 4452.5        86.22501 
X 4457.5        86.225 
X 4462.5        86.225 
X 4467.5        86.325 
X 4472.5        86.275 
X 4477.5        86.375 
X 4482.5        86.425 
X 4487.5        86.39999 
X 4492.5        86.4 
X 4497.5        86.4 
X 4502.5        86.325 
X 4507.5        86.4 
X 4512.5        86.39999 
X 4517.5        86.475 
X 4522.5        86.45 
X 4527.5        86.425 
X 4532.5        86.35 
X 4537.5        86.275 
X 4542.5        86.2 
X 4547.5        86.175 
X 4552.5        86.1 
X 4557.5        86.1 
X 4562.5        86 
X 4567.5        85.97501 
X 4572.5        85.925 
X 4577.5        85.8 
X 4582.5        85.72501 
X 4587.5        85.7 
X 4592.5        85.625 
X 4597.5        85.625 
X 4602.5        85.675 
X 4607.5        85.52499 
X 4612.5        85.45 
X 4617.5        85.45 
X 4622.5        85.375 
X 4627.5        85.125 
X 4632.5        85.1 
X 4637.5        85.15 
X 4642.5        84.89999 
X 4647.5        84.8 
X 4652.5        84.85001 
X 4657.5        84.7 
X 4662.5        84.55 
X 4667.5        84.55 
X 4672.5        84.325 
X 4677.5        84.25 
X 4682.5        84.2 
X 4687.5        84.05 
X 4692.5        83.925 
X 4697.5        83.875 
X 4702.5        83.875 
X 4707.5        83.675 
X 4712.5        83.65 
X 4717.5        83.475 
X 4722.5        83.4 
X 4727.5        83.25 
X 4732.5        83.15 
X 4737.5        83.075 
X 4742.5        83.10001 
X 4747.5        82.925 
X 4752.5        82.775 
X 4757.5        82.8 
X 4762.5        82.65 
X 4767.5        82.45 
X 4772.5        82.525 
X 4777.5        82.475 
X 4782.5        82.25 
X 4787.5        82.1 
X 4792.5        82.125 
X 4797.5        81.925 
X 4802.5        81.875 
X 4807.5        81.825 
X 4812.5        81.7 
X 4817.5        81.525 
X 4822.5        81.6 
X 4827.5        81.575 
X 4832.5        81.425 
X 4837.5        81.35 
X 4842.5        81.3 
X 4847.5        81.275 
X 4852.5        81.175 
X 4857.5        81.05 
X 4862.5        81 
X 4867.5        80.875 
X 4872.5        80.9 
X 4877.5        80.875 
X 4882.5        80.85 
X 4887.5        80.7 
X 4892.5        80.60001 
X 4897.5        80.525 
X 4902.5        80.5 
X 4907.5        80.4 
X 4912.5        80.45 
X 4917.5        80.35 
X 4922.5        80.25 
X 4927.5        80.25 
X 4932.5        80.275 
X 4937.5        80.25 
X 4942.5        80.175 
X 4947.5        80.125 
X 4952.5        79.975 
X 4957.5        79.9 
X 4962.5        79.95 
X 4967.5        80 
X 4972.5        79.925 
X 4977.5        79.875 
X 4982.5        80.025 
X 4987.5        79.925 
X 4992.5        79.85001 
X 4997.5        79.925 
X 5002.5        79.9 
X 5007.5        79.7 
X 5012.5        79.8 
X 5017.5        79.875 
X 5022.5        79.8 
X 5027.5        79.8 
X 5032.5        79.95 
X 5037.5        79.825 
X 5042.5        79.75 
X 5047.5        79.85001 
X 5052.5        79.85 
X 5057.5        79.8 
X 5062.5        79.875 
X 5067.5        79.925 
X 5072.5        79.775 
X 5077.5        79.875 
X 5082.5        80.025 
X 5087.5        80 
X 5092.5        80 
X 5097.5        80.10001 
X 5102.5        80.1 
X 5107.5        80.125 
X 5112.5        80.125 
X 5117.5        80.125 
X 5122.5        80.10001 
X 5127.5        80.175 
X 5132.5        80.375 
X 5137.5        80.375 
X 5142.5        80.375 
X 5147.5        80.5 
X 5152.5        80.47501 
X 5157.5        80.6 
X 5162.5        80.725 
X 5167.5        80.725 
X 5172.5        80.775 
X 5177.5        80.825 
X 5182.5        80.9 
X 5187.5        80.925 
X 5192.5        80.95 
X 5197.5        81 
X 5202.5        81.10001 
X 5207.5        81.25 
X 5212.5        81.275 
X 5217.5        81.3 
X 5222.5        81.375 
X 5227.5        81.375 
X 5232.5        81.475 
X 5237.5        81.60001 
X 5242.5        81.65 
X 5247.5        81.825 
X 5252.5        82 
X 5257.5        81.875 
X 5262.5        81.975 
X 5267.5        82.15 
X 5272.5        82.175 
X 5277.5        82.225 
X 5282.5        82.4 
X 5287.5        82.575 
X 5292.5        82.55 
X 5297.5        82.675 
X 5302.5        82.725 
X 5307.5        82.825 
X 5312.5        82.925 
X 5317.5        83.15 
X 5322.5        83.125 
X 5327.5        83.2 
X 5332.5        83.4 
X 5337.5        83.45 
X 5342.5        83.47501 
X 5347.5        83.60001 
X 5352.5        83.7 
X 5357.5        83.825 
X 5362.5        83.975 
X 5367.5        84.1 
X 5372.5        84.15 
X 5377.5        84.25 
X 5382.5        84.3 
X 5387.5        84.425 
X 5392.5        84.5 
X 5397.5        84.625 
X 5402.5        84.825 
X 5407.5        84.85001 
X 5412.5        84.95 
X 5417.5        85.025 
X 5422.5        85.225 
X 5427.5        85.425 
X 5432.5        85.375 
X 5437.5        85.47501 
X 5442.5        85.625 
X 5447.5        85.675 
X 5452.5        85.825 
X 5457.5        85.97501 
X 5462.5        85.975 
X 5467.5        86.175 
X 5472.5        86.325 
X 5477.5        86.325 
X 5482.5        86.425 
X 5487.5        86.475 
X 5492.5        86.65 
X 5497.5        86.72501 
X 5502.5        86.9 
X 5507.5        87.05 
X 5512.5        86.95 
X 5517.5        87.125 
X 5522.5        87.275 
X 5527.5        87.35 
X 5532.5        87.45 
X 5537.5        87.47501 
X 5542.5        87.575 
X 5547.5        87.625 
X 5552.5        87.775 
X 5557.5        87.8 
X 5562.5        87.925 
X 5567.5        88.14999 
X 5572.5        88.3 
X 5577.5        88.39999 
X 5582.5        88.39999 
X 5587.5        88.4 
X 5592.5        88.55 
X 5597.5        88.60001 
X 5602.5        88.64999 
X 5607.5        88.75 
X 5612.5        88.925 
X 5617.5        88.825 
X 5622.5        88.9 
X 5627.5        89.125 
X 5632.5        89.3 
X 5637.5        89.325 
X 5642.5        89.39999 
X 5647.5        89.375 
X 5652.5        89.475 
X 5657.5        89.625 
X 5662.5        89.6 
X 5667.5        89.65 
X 5672.5        89.775 
X 5677.5        89.925 
X 5682.5        89.925 
X 5687.5        90 
X 5692.5        90.10001 
X 5697.5        90 
X 5702.5        90.15 
X 5707.5        90.25 
X 5712.5        90.475 
X 5717.5        90.14999 
X 5722.5        90.55 
X 5727.5        90.5 
X 5732.5        90.4 
X 5737.5        90.575 
X 5742.5        90.55 
X 5747.5        90.55 
X 5752.5        90.625 
X 5757.5        90.675 
X 5762.5        90.64999 
X 5767.5        90.725 
X 5772.5        90.925 
X 5777.5        90.925 
X 5782.5        90.85001 
X 5787.5        91.05 
X 5792.5        91.05 
X 5797.5        90.97501 
X 5802.5        91.02499 
X 5807.5        90.975 
X 5812.5        91 
X 5817.5        91.075 
X 5822.5        91.05 
X 5827.5        91.10001 
X 5832.5        91.05 
X 5837.5        91.175 
X 5842.5        91.125 
X 5847.5        91.14999 
X 5852.5        91.125 
X 5857.5        91.2 
X 5862.5        91.125 
X 5867.5        91.2 
X 5872.5        91.2 
X 5877.5        91.2 
X 5882.5        91.2 
X 5887.5        91.14999 
X 5892.5        91.2 
X 5897.5        91.175 
X 5902.5        91.175 
X 5907.5        91.2 
X 5912.5        91.075 
X 5917.5        91.075 
X 5922.5        91.3 
X 5927.5        91.05 
X 5932.5        90.95 
X 5937.5        91.125 
X 5942.5        91.22501 
X 5947.5        90.95 
X 5952.5        91.175 
X 5957.5        91.125 
X 5962.5        90.95 
X 5967.5        90.97501 
X 5972.5        91.075 
X 5977.5        90.75 
X 5982.5        90.925 
X 5987.5        90.925 
X 5992.5        90.775 
X 5997.5        90.825 
X 6002.5        90.8 
X 6007.5        90.85 
X 6012.5        90.60001 
X 6017.5        90.75 
X 6022.5        90.75 
X 6027.5        90.45 
X 6032.5        90.625 
X 6037.5        90.60001 
X 6042.5        90.425 
X 6047.5        90.5 
X 6052.5        90.35001 
X 6057.5        90.35 
X 6062.5        90.2 
X 6067.5        90.45 
X 6072.5        90.175 
X 6077.5        90.175 
X 6082.5        90.075 
X 6087.5        90.125 
X 6092.5        89.8 
X 6097.5        90.22501 
X 6102.5        90 
X 6107.5        89.9 
X 6112.5        90.025 
X 6117.5        89.675 
X 6122.5        89.7 
X 6127.5        89.72501 
X 6132.5        89.52499 
X 6137.5        89.75 
X 6142.5        89.225 
X 6147.5        89.575 
X 6152.5        89.4 
X 6157.5        89.275 
X 6162.5        89.39999 
X 6167.5        89.175 
X 6172.5        89.175 
X 6177.5        89.10001 
X 6182.5        89.02499 
X 6187.5        89.075 
X 6192.5        88.925 
X 6197.5        89.02499 
X 6202.5        88.75 
X 6207.5        88.75 
X 6212.5        88.65 
X 6217.5        88.675 
X 6222.5        88.55 
X 6227.5        88.625 
X 6232.5        88.6 
X 6237.5        88.275 
X 6242.5        88.425 
X 6247.5        88.15 
X 6252.5        88.25 
X 6257.5        88.025 
X 6262.5        88.225 
X 6267.5        87.925 
X 6272.5        87.9 
X 6277.5        87.85 
X 6282.5        87.75 
X 6287.5        87.60001 
X 6292.5        87.725 
X 6297.5        87.55 
X 6302.5        87.6 
X 6307.5        87.45 
X 6312.5        87.375 
X 6317.5        87.375 
X 6322.5        87.225 
X 6327.5        87.175 
X 6332.5        87.075 
X 6337.5        87.02499 
X 6342.5        87.125 
X 6347.5        87 
X 6352.5        87 
X 6357.5        86.925 
X 6362.5        86.75 
X 6367.5        86.625 
X 6372.5        86.5 
X 6377.5        86.6 
X 6382.5        86.5 
X 6387.5        86.39999 
X 6392.5        86.475 
X 6397.5        86.35 
X 6402.5        86.125 
X 6407.5        86.375 
X 6412.5        86.15 
X 6417.5        86 
X 6422.5        85.97501 
X 6427.5        85.95 
X 6432.5        85.9 
X 6437.5        85.95 
X 6442.5        85.8 
X 6447.5        85.8 
X 6452.5        85.575 
X 6457.5        85.77499 
X 6462.5        85.45 
X 6467.5        85.525 
X 6472.5        85.45 
X 6477.5        85.39999 
X 6482.5        85.14999 
X 6487.5        85.375 
X 6492.5        85.14999 
X 6497.5        85.10001 
X 6502.5        84.95 
X 6507.5        85.225 
X 6512.5        84.89999 
X 6517.5        85.05 
X 6522.5        84.875 
X 6527.5        84.775 
X 6532.5        84.8 
X 6537.5        84.775 
X 6542.5        84.775 
X 6547.5        84.64999 
X 6552.5        84.55 
X 6557.5        84.45 
X 6562.5        84.55 
X 6567.5        84.35 
X 6572.5        84.325 
X 6577.5        84.325 
X 6582.5        84.325 
X 6587.5        84.225 
X 6592.5        84.10001 
X 6597.5        84.025 
X 6602.5        84.1 
X 6607.5        84.075 
X 6612.5        83.95 
X 6617.5        83.975 
X 6622.5        83.95 
X 6627.5        83.875 
X 6632.5        83.8 
X 6637.5        83.9 
X 6642.5        83.7 
X 6647.5        83.725 
X 6652.5        83.725 
X 6657.5        83.7 
X 6662.5        83.7 
X 6667.5        83.625 
X 6672.5        83.425 
X 6677.5        83.475 
X 6682.5        83.55 
X 6687.5        83.375 
X 6692.5        83.4 
X 6697.5        83.35 
X 6702.5        83.275 
X 6707.5        83.35001 
X 6712.5        83.375 
X 6717.5        83.325 
X 6722.5        83.2 
X 6727.5        83.225 
X 6732.5        83.1 
X 6737.5        83.175 
X 6742.5        83.22501 
X 6747.5        83.05 
X 6752.5        83.05 
X 6757.5        82.97501 
X 6762.5        83.025 
X 6767.5        83.025 
X 6772.5        82.875 
X 6777.5        82.85001 
X 6782.5        82.775 
X 6787.5        82.95 
X 6792.5        82.825 
X 6797.5        82.72501 
X 6802.5        82.825 
X 6807.5        82.8 
X 6812.5        82.775 
X 6817.5        82.825 
X 6822.5        82.775 
X 6827.5        82.60001 
X 6832.5        82.75 
X 6837.5        82.7 
X 6842.5        82.65 
X 6847.5        82.675 
X 6852.5        82.65 
X 6857.5        82.675 
X 6862.5        82.575 
X 6867.5        82.6 
X 6872.5        82.575 
X 6877.5        82.625 
X 6882.5        82.6 
X 6887.5        82.625 
X 6892.5        82.625 
X 6897.5        82.65 
X 6902.5        82.475 
X 6907.5        82.575 
X 6912.5        82.55 
X 6917.5        82.525 
X 6922.5        82.6 
X 6927.5        82.65 
X 6932.5        82.22501 
X 6937.5        82.45 
X 6942.5        82.7 
X 6947.5        82.4 
X 6952.5        82.625 
X 6957.5        82.55 
X 6962.5        82.5 
X 6967.5        82.475 
X 6972.5        82.525 
X 6977.5        82.425 
X 6982.5        82.60001 
X 6987.5        82.675 
X 6992.5        82.6 
X 6997.5        82.6 
END_OF_FILE
if test 18042 -ne `wc -c <'test.dat'`; then
    echo shar: \"'test.dat'\" unpacked with wrong size!
fi
# end of 'test.dat'
fi
if test -f 'test.env' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'test.env'\"
else
echo shar: Extracting \"'test.env'\" \(39360 characters\)
sed "s/^X//" >'test.env' <<'END_OF_FILE'
X   2997.50              ' '                ' '
X   3002.50              ' '                ' '
X   3007.50              ' '                ' '
X   3012.50              ' '                ' '
X   3017.50              ' '                ' '
X   3022.50              ' '                ' '
X   3027.50              ' '                ' '
X   3032.50              ' '                ' '
X   3037.50              ' '                ' '
X   3042.50              ' '                ' '
X   3047.50              ' '                ' '
X   3052.50            71.5549              ' '
X   3057.50            71.6389              ' '
X   3062.50            71.7228              ' '
X   3067.50            71.8066              ' '
X   3072.50            71.8903              ' '
X   3077.50            71.9738              ' '
X   3082.50            72.0573              ' '
X   3087.50            72.1406              ' '
X   3092.50            72.2238              ' '
X   3097.50            72.3068              ' '
X   3102.50            72.3898              ' '
X   3107.50            72.4726              ' '
X   3112.50            72.5552              ' '
X   3117.50            72.6378              ' '
X   3122.50            72.7201              ' '
X   3127.50            72.8024              ' '
X   3132.50            72.8844              ' '
X   3137.50            72.9663              ' '
X   3142.50            73.0481              ' '
X   3147.50            73.1297              ' '
X   3152.50            73.2111              ' '
X   3157.50            73.2924              ' '
X   3162.50            73.3735              ' '
X   3167.50            73.4544              ' '
X   3172.50            73.5351              ' '
X   3177.50            73.6157              ' '
X   3182.50            73.6960              ' '
X   3187.50            73.7762              ' '
X   3192.50            73.8562              ' '
X   3197.50            73.9360              ' '
X   3202.50            74.0156              ' '
X   3207.50            74.0950              ' '
X   3212.50            74.1742              ' '
X   3217.50            74.2531              ' '
X   3222.50            74.3319              ' '
X   3227.50            74.4104              ' '
X   3232.50            74.4888              ' '
X   3237.50            74.5669              ' '
X   3242.50            74.6447              ' '
X   3247.50            74.7224              ' '
X   3252.50            74.7998              ' '
X   3257.50            74.8770              ' '
X   3262.50            74.9539              ' '
X   3267.50            75.0306              ' '
X   3272.50            75.1071              ' '
X   3277.50            75.1833              ' '
X   3282.50            75.2592              ' '
X   3287.50            75.3349              ' '
X   3292.50            75.4104              ' '
X   3297.50            75.4855              ' '
X   3302.50            75.5605              ' '
X   3307.50            75.6351              ' '
X   3312.50            75.7095            67.3530
X   3317.50            75.7836            67.4073
X   3322.50            75.8574            67.4615
X   3327.50            75.9309            67.5157
X   3332.50            76.0041            67.5698
X   3337.50            76.0771            67.6238
X   3342.50            76.1497            67.6778
X   3347.50            76.2221            67.7317
X   3352.50            76.2942            67.7856
X   3357.50            76.3659            67.8394
X   3362.50            76.4374            67.8931
X   3367.50            76.5085            67.9468
X   3372.50            76.5794            68.0004
X   3377.50            76.6499            68.0539
X   3382.50            76.7201            68.1074
X   3387.50            76.7900            68.1608
X   3392.50            76.8595            68.2141
X   3397.50            76.9287            68.2673
X   3402.50            76.9976            68.3205
X   3407.50            77.0662            68.3736
X   3412.50            77.1344            68.4266
X   3417.50            77.2023            68.4796
X   3422.50            77.2698            68.5324
X   3427.50            77.3370            68.5852
X   3432.50            77.4038            68.6379
X   3437.50            77.4702            68.6906
X   3442.50            77.5363            68.7431
X   3447.50            77.6021            68.7956
X   3452.50            77.6675            68.8479
X   3457.50            77.7325            68.9002
X   3462.50            77.7971            68.9525
X   3467.50            77.8614            69.0046
X   3472.50            77.9252            69.0566
X   3477.50            77.9887            69.1086
X   3482.50            78.0518            69.1604
X   3487.50            78.1145            69.2122
X   3492.50            78.1769            69.2638
X   3497.50            78.2388            69.3154
X   3502.50            78.3003            69.3669
X   3507.50            78.3614            69.4183
X   3512.50            78.4222            69.4696
X   3517.50            78.4825            69.5208
X   3522.50            78.5424            69.5719
X   3527.50            78.6018            69.6229
X   3532.50            78.6609            69.6738
X   3537.50            78.7195            69.7245
X   3542.50            78.7777            69.7752
X   3547.50            78.8355            69.8258
X   3552.50            78.8929            69.8763
X   3557.50            78.9498            69.9267
X   3562.50            79.0062            69.9769
X   3567.50            79.0623            70.0271
X   3572.50            79.1179            70.0771
X   3577.50            79.1730            70.1271
X   3582.50            79.2277            70.1769
X   3587.50            79.2819            70.2266
X   3592.50            79.3356            70.2762
X   3597.50            79.3889            70.3257
X   3602.50            79.4418            70.3751
X   3607.50            79.4941            70.4243
X   3612.50            79.5460            70.4735
X   3617.50            79.5974            70.5225
X   3622.50            79.6485            70.5714
X   3627.50            79.6995            70.6201
X   3632.50            79.7503            70.6688
X   3637.50            79.8011            70.7173
X   3642.50            79.8516            70.7657
X   3647.50            79.9021            70.8140
X   3652.50            79.9524            70.8622
X   3657.50            80.0026            70.9102
X   3662.50            80.0527            70.9581
X   3667.50            80.1026            71.0058
X   3672.50            80.1524            71.0535
X   3677.50            80.2020            71.1010
X   3682.50            80.2515            71.1484
X   3687.50            80.3009            71.1956
X   3692.50            80.3502            71.2427
X   3697.50            80.3993            71.2897
X   3702.50            80.4483            71.3365
X   3707.50            80.4972            71.3832
X   3712.50            80.5459            71.4297
X   3717.50            80.5945            71.4761
X   3722.50            80.6429            71.5224
X   3727.50            80.6912            71.5685
X   3732.50            80.7394            71.6145
X   3737.50            80.7874            71.6604
X   3742.50            80.8353            71.7061
X   3747.50            80.8831            71.7516
X   3752.50            80.9307            71.7970
X   3757.50            80.9782            71.8423
X   3762.50            81.0256            71.8874
X   3767.50            81.0728            71.9323
X   3772.50            81.1199            71.9771
X   3777.50            81.1668            72.0218
X   3782.50            81.2136            72.0662
X   3787.50            81.2603            72.1106
X   3792.50            81.3068            72.1548
X   3797.50            81.3532            72.1988
X   3802.50            81.3995            72.2426
X   3807.50            81.4456            72.2864
X   3812.50            81.4915            72.3299
X   3817.50            81.5374            72.3733
X   3822.50            81.5830            72.4165
X   3827.50            81.6286            72.4596
X   3832.50            81.6740            72.5024
X   3837.50            81.7193            72.5452
X   3842.50            81.7644            72.5877
X   3847.50            81.8094            72.6301
X   3852.50            81.8542            72.6723
X   3857.50            81.8989            72.7144
X   3862.50            81.9435            72.7563
X   3867.50            81.9879            72.7980
X   3872.50            82.0321            72.8395
X   3877.50            82.0762            72.8809
X   3882.50            82.1202            72.9221
X   3887.50            82.1641            72.9631
X   3892.50            82.2078            73.0039
X   3897.50            82.2513            73.0446
X   3902.50            82.2947            73.0851
X   3907.50            82.3380            73.1253
X   3912.50            82.3811            73.1655
X   3917.50            82.4240            73.2054
X   3922.50            82.4669            73.2451
X   3927.50            82.5095            73.2847
X   3932.50            82.5521            73.3241
X   3937.50            82.5944            73.3633
X   3942.50            82.6367            73.4023
X   3947.50            82.6788            73.4411
X   3952.50            82.7207            73.4797
X   3957.50            82.7625            73.5181
X   3962.50            82.8041            73.5564
X   3967.50            82.8456            73.5944
X   3972.50            82.8870            73.6322
X   3977.50            82.9282            73.6699
X   3982.50            82.9692            73.7074
X   3987.50            83.0101            73.7446
X   3992.50            83.0509            73.7817
X   3997.50            83.0915            73.8185
X   4002.50            83.1319            73.8552
X   4007.50            83.1722            73.8917
X   4012.50            83.2124            73.9280
X   4017.50            83.2524            73.9644
X   4022.50            83.2922            74.0008
X   4027.50            83.3319            74.0372
X   4032.50            83.3714            74.0737
X   4037.50            83.4108            74.1101
X   4042.50            83.4501            74.1466
X   4047.50            83.4892            74.1831
X   4052.50            83.5281            74.2195
X   4057.50            83.5669            74.2560
X   4062.50            83.6055            74.2925
X   4067.50            83.6440            74.3290
X   4072.50            83.6823            74.3655
X   4077.50            83.7205            74.4021
X   4082.50            83.7585            74.4386
X   4087.50            83.7963            74.4751
X   4092.50            83.8340            74.5116
X   4097.50            83.8716            74.5481
X   4102.50            83.9090            74.5846
X   4107.50            83.9462            74.6211
X   4112.50            83.9833            74.6576
X   4117.50            84.0202            74.6941
X   4122.50            84.0570            74.7306
X   4127.50            84.0936            74.7671
X   4132.50            84.1301            74.8035
X   4137.50            84.1664            74.8400
X   4142.50            84.2025            74.8764
X   4147.50            84.2385            74.9128
X   4152.50            84.2743            74.9492
X   4157.50            84.3100            74.9856
X   4162.50            84.3455            75.0220
X   4167.50            84.3808            75.0583
X   4172.50            84.4160            75.0947
X   4177.50            84.4510            75.1310
X   4182.50            84.4859            75.1672
X   4187.50            84.5206            75.2035
X   4192.50            84.5552            75.2397
X   4197.50            84.5896            75.2759
X   4202.50            84.6238            75.3121
X   4207.50            84.6579            75.3482
X   4212.50            84.6918            75.3843
X   4217.50            84.7255            75.4204
X   4222.50            84.7591            75.4564
X   4227.50            84.7925            75.4924
X   4232.50            84.8258            75.5284
X   4237.50            84.8589            75.5643
X   4242.50            84.8918            75.6002
X   4247.50            84.9246            75.6360
X   4252.50            84.9572            75.6718
X   4257.50            84.9896            75.7075
X   4262.50            85.0219            75.7432
X   4267.50            85.0540            75.7789
X   4272.50            85.0860            75.8145
X   4277.50            85.1178            75.8501
X   4282.50            85.1494            75.8856
X   4287.50            85.1809            75.9210
X   4292.50            85.2122            75.9564
X   4297.50            85.2433            75.9918
X   4302.50            85.2742            76.0271
X   4307.50            85.3050            76.0623
X   4312.50            85.3357            76.0975
X   4317.50            85.3661            76.1326
X   4322.50            85.3964            76.1676
X   4327.50            85.4266            76.2026
X   4332.50            85.4565            76.2375
X   4337.50            85.4863            76.2724
X   4342.50            85.5159            76.3072
X   4347.50            85.5454            76.3419
X   4352.50            85.5747            76.3766
X   4357.50            85.6038            76.4112
X   4362.50            85.6327            76.4457
X   4367.50            85.6615            76.4801
X   4372.50            85.6901            76.5145
X   4377.50            85.7186            76.5488
X   4382.50            85.7468            76.5830
X   4387.50            85.7749            76.6171
X   4392.50            85.8029            76.6511
X   4397.50            85.8306            76.6851
X   4402.50            85.8582            76.7190
X   4407.50            85.8856            76.7528
X   4412.50            85.9129            76.7865
X   4417.50            85.9399            76.8202
X   4422.50            85.9668            76.8537
X   4427.50            85.9936            76.8871
X   4432.50            86.0201            76.9205
X   4437.50            86.0465            76.9538
X   4442.50            86.0727            76.9870
X   4447.50            86.0987            77.0200
X   4452.50            86.1246            77.0530
X   4457.50            86.1503            77.0859
X   4462.50            86.1758            77.1187
X   4467.50            86.2011            77.1514
X   4472.50            86.2263            77.1840
X   4477.50            86.2513            77.2165
X   4482.50            86.2762            77.2488
X   4487.50            86.3011            77.2811
X   4492.50            86.3259            77.3133
X   4497.50            86.3508            77.3454
X   4502.50            86.3756            77.3773
X   4507.50            86.4005            77.4092
X   4512.50            86.4253            77.4409
X   4517.50            86.4501            77.4725
X   4522.50            86.4748            77.5040
X   4527.50            86.4996            77.5354
X   4532.50            86.5244            77.5667
X   4537.50            86.5491            77.5978
X   4542.50            86.5738            77.6288
X   4547.50            86.5985            77.6598
X   4552.50            86.6232            77.6905
X   4557.50            86.6479            77.7212
X   4562.50            86.6725            77.7517
X   4567.50            86.6971            77.7822
X   4572.50            86.7217            77.8124
X   4577.50            86.7463            77.8426
X   4582.50            86.7709            77.8726
X   4587.50            86.7954            77.9025
X   4592.50            86.8200            77.9323
X   4597.50            86.8445            77.9619
X   4602.50            86.8689            77.9914
X   4607.50            86.8934            78.0207
X   4612.50            86.9178            78.0500
X   4617.50            86.9422            78.0790
X   4622.50            86.9666            78.1080
X   4627.50            86.9910            78.1368
X   4632.50            87.0153            78.1654
X   4637.50            87.0396            78.1939
X   4642.50            87.0639            78.2223
X   4647.50            87.0882            78.2505
X   4652.50            87.1124            78.2785
X   4657.50            87.1366            78.3064
X   4662.50            87.1608            78.3342
X   4667.50            87.1849            78.3618
X   4672.50            87.2090            78.3893
X   4677.50            87.2331            78.4165
X   4682.50            87.2572            78.4437
X   4687.50            87.2812            78.4707
X   4692.50            87.3052            78.4975
X   4697.50            87.3292            78.5241
X   4702.50            87.3531            78.5506
X   4707.50            87.3770            78.5770
X   4712.50            87.4009            78.6031
X   4717.50            87.4247            78.6292
X   4722.50            87.4485            78.6550
X   4727.50            87.4723            78.6806
X   4732.50            87.4960            78.7061
X   4737.50            87.5197            78.7315
X   4742.50            87.5434            78.7566
X   4747.50            87.5671            78.7816
X   4752.50            87.5907            78.8064
X   4757.50            87.6142            78.8310
X   4762.50            87.6377            78.8555
X   4767.50            87.6612            78.8797
X   4772.50            87.6847            78.9038
X   4777.50            87.7081            78.9277
X   4782.50            87.7315            78.9515
X   4787.50            87.7548            78.9750
X   4792.50            87.7781            78.9983
X   4797.50            87.8014            79.0215
X   4802.50            87.8246            79.0445
X   4807.50            87.8477            79.0673
X   4812.50            87.8709            79.0899
X   4817.50            87.8940            79.1123
X   4822.50            87.9170            79.1345
X   4827.50            87.9400            79.1565
X   4832.50            87.9630            79.1783
X   4837.50            87.9859            79.1999
X   4842.50            88.0088            79.2213
X   4847.50            88.0316            79.2425
X   4852.50            88.0544            79.2636
X   4857.50            88.0772            79.2844
X   4862.50            88.0999            79.3050
X   4867.50            88.1225            79.3254
X   4872.50            88.1451            79.3456
X   4877.50            88.1677            79.3656
X   4882.50            88.1902            79.3853
X   4887.50            88.2127            79.4049
X   4892.50            88.2351            79.4243
X   4897.50            88.2574            79.4434
X   4902.50            88.2798            79.4623
X   4907.50            88.3020            79.4810
X   4912.50            88.3242            79.4995
X   4917.50            88.3464            79.5178
X   4922.50            88.3685            79.5358
X   4927.50            88.3906            79.5537
X   4932.50            88.4126            79.5713
X   4937.50            88.4346            79.5886
X   4942.50            88.4565            79.6058
X   4947.50            88.4783            79.6227
X   4952.50            88.5001            79.6394
X   4957.50            88.5219            79.6559
X   4962.50            88.5436            79.6721
X   4967.50            88.5652            79.6881
X   4972.50            88.5868            79.7039
X   4977.50            88.6083            79.7194
X   4982.50            88.6298            79.7347
X   4987.50            88.6512            79.7498
X   4992.50            88.6726            79.7646
X   4997.50            88.6939            79.7792
X   5002.50            88.7151            79.7936
X   5007.50            88.7363            79.8077
X   5012.50            88.7574            79.8215
X   5017.50            88.7785            79.8351
X   5022.50            88.7995            79.8485
X   5027.50            88.8204            79.8616
X   5032.50            88.8413            79.8745
X   5037.50            88.8621            79.8871
X   5042.50            88.8829            79.8994
X   5047.50            88.9036            79.9115
X   5052.50            88.9242            79.9234
X   5057.50            88.9448            79.9351
X   5062.50            88.9653            79.9468
X   5067.50            88.9857            79.9585
X   5072.50            89.0061            79.9702
X   5077.50            89.0264            79.9818
X   5082.50            89.0467            79.9935
X   5087.50            89.0669            80.0051
X   5092.50            89.0870            80.0167
X   5097.50            89.1070            80.0283
X   5102.50            89.1270            80.0398
X   5107.50            89.1470            80.0514
X   5112.50            89.1668            80.0629
X   5117.50            89.1866            80.0744
X   5122.50            89.2063            80.0860
X   5127.50            89.2259            80.0974
X   5132.50            89.2455            80.1089
X   5137.50            89.2650            80.1204
X   5142.50            89.2845            80.1318
X   5147.50            89.3038            80.1432
X   5152.50            89.3231            80.1546
X   5157.50            89.3423            80.1660
X   5162.50            89.3615            80.1774
X   5167.50            89.3806            80.1887
X   5172.50            89.3996            80.2000
X   5177.50            89.4185            80.2114
X   5182.50            89.4373            80.2226
X   5187.50            89.4561            80.2339
X   5192.50            89.4748            80.2452
X   5197.50            89.4934            80.2564
X   5202.50            89.5120            80.2677
X   5207.50            89.5305            80.2789
X   5212.50            89.5489            80.2900
X   5217.50            89.5672            80.3012
X   5222.50            89.5854            80.3124
X   5227.50            89.6036            80.3235
X   5232.50            89.6217            80.3346
X   5237.50            89.6397            80.3457
X   5242.50            89.6576            80.3568
X   5247.50            89.6755            80.3678
X   5252.50            89.6933            80.3789
X   5257.50            89.7109            80.3899
X   5262.50            89.7286            80.4009
X   5267.50            89.7461            80.4119
X   5272.50            89.7635            80.4228
X   5277.50            89.7809            80.4338
X   5282.50            89.7982            80.4447
X   5287.50            89.8154            80.4556
X   5292.50            89.8325            80.4665
X   5297.50            89.8495            80.4774
X   5302.50            89.8664            80.4882
X   5307.50            89.8833            80.4990
X   5312.50            89.9001            80.5098
X   5317.50            89.9167            80.5206
X   5322.50            89.9333            80.5314
X   5327.50            89.9498            80.5421
X   5332.50            89.9663            80.5529
X   5337.50            89.9826            80.5636
X   5342.50            89.9988            80.5742
X   5347.50            90.0150            80.5849
X   5352.50            90.0311            80.5956
X   5357.50            90.0471            80.6062
X   5362.50            90.0629            80.6168
X   5367.50            90.0787            80.6274
X   5372.50            90.0944            80.6379
X   5377.50            90.1101            80.6485
X   5382.50            90.1256            80.6590
X   5387.50            90.1410            80.6695
X   5392.50            90.1564            80.6800
X   5397.50            90.1716            80.6904
X   5402.50            90.1868            80.7009
X   5407.50            90.2018            80.7113
X   5412.50            90.2168            80.7217
X   5417.50            90.2316            80.7320
X   5422.50            90.2464            80.7424
X   5427.50            90.2611            80.7527
X   5432.50            90.2757            80.7630
X   5437.50            90.2901            80.7733
X   5442.50            90.3045            80.7836
X   5447.50            90.3188            80.7938
X   5452.50            90.3330            80.8040
X   5457.50            90.3471            80.8142
X   5462.50            90.3611            80.8244
X   5467.50            90.3750            80.8346
X   5472.50            90.3888            80.8447
X   5477.50            90.4025            80.8548
X   5482.50            90.4161            80.8649
X   5487.50            90.4296            80.8750
X   5492.50            90.4429            80.8850
X   5497.50            90.4562            80.8950
X   5502.50            90.4694            80.9050
X   5507.50            90.4825            80.9150
X   5512.50            90.4955            80.9249
X   5517.50            90.5083            80.9349
X   5522.50            90.5211            80.9448
X   5527.50            90.5338            80.9547
X   5532.50            90.5463            80.9645
X   5537.50            90.5588            80.9743
X   5542.50            90.5711            80.9842
X   5547.50            90.5834            80.9939
X   5552.50            90.5955            81.0037
X   5557.50            90.6075            81.0134
X   5562.50            90.6194            81.0232
X   5567.50            90.6312            81.0329
X   5572.50            90.6429            81.0425
X   5577.50            90.6545            81.0522
X   5582.50            90.6660            81.0618
X   5587.50            90.6774            81.0714
X   5592.50            90.6886            81.0810
X   5597.50            90.6998            81.0905
X   5602.50            90.7108            81.1000
X   5607.50            90.7217            81.1095
X   5612.50            90.7326            81.1190
X   5617.50            90.7433            81.1285
X   5622.50            90.7538            81.1379
X   5627.50            90.7643            81.1473
X   5632.50            90.7747            81.1567
X   5637.50            90.7849            81.1660
X   5642.50            90.7950            81.1753
X   5647.50            90.8051            81.1846
X   5652.50            90.8149            81.1939
X   5657.50            90.8247            81.2032
X   5662.50            90.8344            81.2124
X   5667.50            90.8439            81.2216
X   5672.50            90.8534            81.2308
X   5677.50            90.8627            81.2399
X   5682.50            90.8719            81.2490
X   5687.50            90.8809            81.2581
X   5692.50            90.8899            81.2672
X   5697.50            90.8987            81.2763
X   5702.50            90.9074            81.2853
X   5707.50            90.9160            81.2943
X   5712.50            90.9245            81.3033
X   5717.50            90.9328            81.3122
X   5722.50            90.9411            81.3211
X   5727.50            90.9492            81.3300
X   5732.50            90.9572            81.3389
X   5737.50            90.9650            81.3477
X   5742.50            90.9727            81.3565
X   5747.50            90.9803            81.3653
X   5752.50            90.9878            81.3741
X   5757.50            90.9952            81.3828
X   5762.50            91.0024            81.3915
X   5767.50            91.0095            81.4002
X   5772.50            91.0165            81.4088
X   5777.50            91.0234            81.4175
X   5782.50            91.0301            81.4261
X   5787.50            91.0367            81.4346
X   5792.50            91.0431            81.4432
X   5797.50            91.0495            81.4517
X   5802.50            91.0557            81.4602
X   5807.50            91.0618            81.4686
X   5812.50            91.0677            81.4771
X   5817.50            91.0735            81.4855
X   5822.50            91.0792            81.4938
X   5827.50            91.0848            81.5022
X   5832.50            91.0902            81.5105
X   5837.50            91.0955            81.5188
X   5842.50            91.1006            81.5271
X   5847.50            91.1057            81.5353
X   5852.50            91.1106            81.5435
X   5857.50            91.1153            81.5517
X   5862.50            91.1199            81.5599
X   5867.50              ' '              81.5680
X   5872.50              ' '              81.5761
X   5877.50              ' '              81.5841
X   5882.50              ' '              81.5922
X   5887.50              ' '              81.6002
X   5892.50              ' '              81.6082
X   5897.50              ' '              81.6161
X   5902.50              ' '              81.6240
X   5907.50              ' '              81.6319
X   5912.50              ' '              81.6398
X   5917.50              ' '              81.6476
X   5922.50              ' '              81.6554
X   5927.50              ' '              81.6632
X   5932.50              ' '              81.6710
X   5937.50              ' '              81.6787
X   5942.50              ' '              81.6864
X   5947.50              ' '              81.6940
X   5952.50              ' '              81.7017
X   5957.50              ' '              81.7093
X   5962.50              ' '              81.7168
X   5967.50              ' '              81.7244
X   5972.50              ' '              81.7319
X   5977.50              ' '              81.7394
X   5982.50              ' '              81.7468
X   5987.50              ' '              81.7542
X   5992.50              ' '              81.7616
X   5997.50              ' '              81.7690
X   6002.50              ' '              81.7763
X   6007.50              ' '              81.7836
X   6012.50              ' '              81.7909
X   6017.50              ' '              81.7981
X   6022.50              ' '              81.8053
X   6027.50              ' '              81.8125
X   6032.50              ' '              81.8196
X   6037.50              ' '              81.8267
X   6042.50              ' '              81.8338
X   6047.50              ' '              81.8409
X   6052.50              ' '              81.8479
X   6057.50              ' '              81.8549
X   6062.50              ' '              81.8618
X   6067.50              ' '              81.8687
X   6072.50              ' '              81.8756
X   6077.50              ' '              81.8825
X   6082.50              ' '              81.8893
X   6087.50              ' '              81.8961
X   6092.50              ' '              81.9029
X   6097.50              ' '              81.9096
X   6102.50              ' '              81.9163
X   6107.50              ' '              81.9230
X   6112.50              ' '              81.9296
X   6117.50              ' '              81.9362
X   6122.50              ' '              81.9428
X   6127.50              ' '              81.9493
X   6132.50              ' '              81.9558
X   6137.50              ' '              81.9623
X   6142.50              ' '              81.9687
X   6147.50              ' '              81.9752
X   6152.50              ' '              81.9815
X   6157.50              ' '              81.9879
X   6162.50              ' '              81.9942
X   6167.50              ' '              82.0005
X   6172.50              ' '              82.0067
X   6177.50              ' '              82.0129
X   6182.50              ' '              82.0191
X   6187.50              ' '              82.0252
X   6192.50              ' '              82.0313
X   6197.50              ' '              82.0374
X   6202.50              ' '              82.0434
X   6207.50              ' '              82.0495
X   6212.50              ' '              82.0554
X   6217.50              ' '              82.0614
X   6222.50              ' '              82.0673
X   6227.50              ' '              82.0732
X   6232.50              ' '              82.0790
X   6237.50              ' '              82.0848
X   6242.50              ' '              82.0906
X   6247.50              ' '              82.0963
X   6252.50              ' '              82.1020
X   6257.50              ' '              82.1077
X   6262.50              ' '              82.1133
X   6267.50              ' '              82.1189
X   6272.50              ' '              82.1245
X   6277.50              ' '              82.1300
X   6282.50              ' '              82.1355
X   6287.50              ' '              82.1409
X   6292.50              ' '              82.1464
X   6297.50              ' '              82.1517
X   6302.50              ' '              82.1571
X   6307.50              ' '              82.1624
X   6312.50              ' '              82.1677
X   6317.50              ' '              82.1729
X   6322.50              ' '              82.1782
X   6327.50              ' '              82.1833
X   6332.50              ' '              82.1885
X   6337.50              ' '              82.1936
X   6342.50              ' '              82.1986
X   6347.50              ' '              82.2037
X   6352.50              ' '              82.2087
X   6357.50              ' '              82.2136
X   6362.50              ' '              82.2186
X   6367.50              ' '              82.2234
X   6372.50              ' '              82.2283
X   6377.50              ' '              82.2331
X   6382.50              ' '              82.2379
X   6387.50              ' '              82.2426
X   6392.50              ' '              82.2473
X   6397.50              ' '              82.2520
X   6402.50              ' '              82.2566
X   6407.50              ' '              82.2612
X   6412.50              ' '              82.2658
X   6417.50              ' '              82.2703
X   6422.50              ' '              82.2748
X   6427.50              ' '              82.2792
X   6432.50              ' '              82.2836
X   6437.50              ' '              82.2880
X   6442.50              ' '              82.2924
X   6447.50              ' '              82.2967
X   6452.50              ' '              82.3009
X   6457.50              ' '              82.3051
X   6462.50              ' '              82.3093
X   6467.50              ' '              82.3135
X   6472.50              ' '              82.3176
X   6477.50              ' '              82.3216
X   6482.50              ' '              82.3257
X   6487.50              ' '              82.3297
X   6492.50              ' '              82.3336
X   6497.50              ' '              82.3376
X   6502.50              ' '              82.3414
X   6507.50              ' '              82.3453
X   6512.50              ' '              82.3491
X   6517.50              ' '              82.3528
X   6522.50              ' '              82.3566
X   6527.50              ' '              82.3603
X   6532.50              ' '              82.3639
X   6537.50              ' '              82.3675
X   6542.50              ' '              82.3711
X   6547.50              ' '              82.3746
X   6552.50              ' '              82.3781
X   6557.50              ' '              82.3816
X   6562.50              ' '              82.3850
X   6567.50              ' '              82.3884
X   6572.50              ' '              82.3917
X   6577.50              ' '              82.3950
X   6582.50              ' '              82.3982
X   6587.50              ' '              82.4015
X   6592.50              ' '              82.4046
X   6597.50              ' '              82.4078
X   6602.50              ' '              82.4109
X   6607.50              ' '              82.4139
X   6612.50              ' '              82.4170
X   6617.50              ' '              82.4199
X   6622.50              ' '              82.4229
X   6627.50              ' '              82.4258
X   6632.50              ' '              82.4286
X   6637.50              ' '              82.4314
X   6642.50              ' '              82.4342
X   6647.50              ' '              82.4370
X   6652.50              ' '              82.4396
X   6657.50              ' '              82.4423
X   6662.50              ' '              82.4449
X   6667.50              ' '              82.4475
X   6672.50              ' '              82.4500
X   6677.50              ' '              82.4525
X   6682.50              ' '              82.4550
X   6687.50              ' '              82.4574
X   6692.50              ' '              82.4597
X   6697.50              ' '              82.4621
X   6702.50              ' '              82.4643
X   6707.50              ' '              82.4666
X   6712.50              ' '              82.4688
X   6717.50              ' '              82.4709
X   6722.50              ' '              82.4731
X   6727.50              ' '              82.4751
X   6732.50              ' '              82.4772
X   6737.50              ' '              82.4792
X   6742.50              ' '              82.4811
X   6747.50              ' '              82.4830
X   6752.50              ' '              82.4849
X   6757.50              ' '              82.4867
X   6762.50              ' '              82.4885
X   6767.50              ' '              82.4902
X   6772.50              ' '              82.4919
X   6777.50              ' '              82.4936
X   6782.50              ' '              82.4952
X   6787.50              ' '              82.4968
X   6792.50              ' '              82.4983
X   6797.50              ' '              82.4998
X   6802.50              ' '              82.5012
X   6807.50              ' '              82.5026
X   6812.50              ' '              82.5040
X   6817.50              ' '              82.5053
X   6822.50              ' '              82.5065
X   6827.50              ' '              82.5078
X   6832.50              ' '              82.5089
X   6837.50              ' '              82.5101
X   6842.50              ' '              82.5112
X   6847.50              ' '              82.5122
X   6852.50              ' '              82.5132
X   6857.50              ' '              82.5142
X   6862.50              ' '              82.5151
X   6867.50              ' '              82.5160
X   6872.50              ' '              82.5168
X   6877.50              ' '              82.5176
X   6882.50              ' '              82.5183
X   6887.50              ' '              82.5190
X   6892.50              ' '              82.5197
X   6897.50              ' '              82.5203
X   6902.50              ' '              82.5208
X   6907.50              ' '              82.5214
X   6912.50              ' '              82.5218
X   6917.50              ' '              82.5223
X   6922.50              ' '              82.5227
X   6927.50              ' '              82.5230
X   6932.50              ' '              82.5233
X   6937.50              ' '              82.5235
X   6942.50              ' '              82.5237
X   6947.50              ' '              82.5239
X   6952.50              ' '              82.5240
X   6957.50              ' '              82.5241
X   6962.50              ' '              82.5241
X   6967.50              ' '                ' '
X   6972.50              ' '                ' '
X   6977.50              ' '                ' '
X   6982.50              ' '                ' '
X   6987.50              ' '                ' '
X   6992.50              ' '                ' '
X   6997.50              ' '                ' '
X'     X            Top Envelope      Bottom Envelope'
X
X'Envelope data generated by program ENVELOPE using data from file TEST.DAT'
X'with initial tolerance  0.0800 and final tolerance  0.0100'
X'(A ' ' entry indicates no envelope point was generated.)'
END_OF_FILE
if test 39360 -ne `wc -c <'test.env'`; then
    echo shar: \"'test.env'\" unpacked with wrong size!
fi
# end of 'test.env'
fi
if test -f 'test.tan' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'test.tan'\"
else
echo shar: Extracting \"'test.tan'\" \(576 characters\)
sed "s/^X//" >'test.tan' <<'END_OF_FILE'
X   3052.50            71.5549              ' '
X   3312.50            75.7095            67.3530
X   3617.50            79.5974            70.5225
X   4007.50            83.1722            73.8917
X   4477.50            86.2513            77.2165
X   5052.50            88.9242            79.9234
X   5862.50            91.1199            81.5599
X   6962.50              ' '              82.5241
X'     X                 Tmax               Tmin'
X
X'Tangent data generated by program ENVELOPE using data from file TEST.DAT'
X'with initial tolerance  0.0800 and final tolerance  0.0100'
END_OF_FILE
if test 576 -ne `wc -c <'test.tan'`; then
    echo shar: \"'test.tan'\" unpacked with wrong size!
fi
# end of 'test.tan'
fi
echo shar: End of shell archive.
exit 0
